[{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\app.module.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RequestLoggerMiddleware' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';\nimport { PrismaModule } from './database/prisma.module';\nimport { UsersModule } from './modules/users/users.module';\nimport { CommentsModule } from './modules/comments/comments.module';\nimport { AuthModule } from './modules/auth/auth.module';\nimport { PostMediasModule } from './modules/post-medias/postMedias.module';\nimport { FollowsModule } from './modules/follow/follow.module';\nimport { ReactionsModule } from './modules/reactions/reactions.module';\nimport { CloudinaryModule } from './modules/cloudinary/cloudinary.module';\nimport { PostsModule } from './modules/posts/posts.module';\nimport { MailerModule } from './modules/mailer/mailer.module';\nimport { RedisCacheModule } from './modules/cache/cache.module';\nimport { NotificationModule } from './modules/notification/notification.module';\nimport { SearchHistoryModule } from './modules/search-history/search-history.module';\nimport { MessagingModule } from './modules/messaging/messaging.module';\nimport {\n  CorsMiddleware,\n  RateLimitMiddleware,\n  RequestLoggerMiddleware,\n  SecurityLoggerMiddleware,\n  CookieParserMiddleware,\n  SecurityHeadersMiddleware,\n  FileUploadSecurityMiddleware,\n  WebSocketSecurityMiddleware,\n} from './shared/middlewares';\nimport { ErrorMonitoringService } from './shared/services/error-monitoring.service';\n\n@Module({\n  imports: [\n    UsersModule,\n    CommentsModule,\n    AuthModule,\n    PostMediasModule,\n    FollowsModule,\n    ReactionsModule,\n    CloudinaryModule,\n    PostsModule,\n    MailerModule,\n    RedisCacheModule,\n    NotificationModule,\n    SearchHistoryModule,\n    MessagingModule,\n    PrismaModule,\n  ],\n  controllers: [],\n  providers: [ErrorMonitoringService],\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    // Apply middleware in order of execution\n\n    // 1. Security headers - first for all requests\n    consumer.apply(SecurityHeadersMiddleware).forRoutes('*');\n\n    // 2. CORS - before any processing\n    consumer.apply(CorsMiddleware).forRoutes('*');\n\n    // 3. Cookie parser - needed for auth\n    consumer.apply(CookieParserMiddleware).forRoutes('*');\n\n    // 4. Request logging - general logging\n    // consumer.apply(RequestLoggerMiddleware).forRoutes('*');\n\n    // 5. Security logging - sensitive operations\n    consumer.apply(SecurityLoggerMiddleware).forRoutes('*');\n\n    // 6. Rate limiting - protect against abuse\n    consumer.apply(RateLimitMiddleware).forRoutes('*');\n\n    // 7. File upload security - apply globally but middleware will only act on upload/cloudinary paths\n    consumer.apply(FileUploadSecurityMiddleware).forRoutes('*');\n\n    // 8. WebSocket security - Socket.IO routes\n    consumer.apply(WebSocketSecurityMiddleware).forRoutes('/socket.io/*path');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\cloudinary.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\cloudinary.constant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\google.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\jwt.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\mailer.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\queue.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\config\\redis.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\database\\prisma.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\database\\prisma.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\main.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PrismaService' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":23},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":32,"column":1,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":32,"endColumn":13,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1071,1071],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1071,1071],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { PrismaService } from './database/prisma.service';\nimport { ValidationPipe } from '@nestjs/common';\nimport { GlobalExceptionFilter } from './shared/filters/global-exception.filter';\nimport { ErrorMonitoringService } from './shared/services/error-monitoring.service';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Global pipes for validation\n  app.useGlobalPipes(\n    new ValidationPipe({\n      transform: true,\n      whitelist: true,\n      forbidNonWhitelisted: true,\n      transformOptions: {\n        enableImplicitConversion: true,\n      },\n    }),\n  );\n\n  // Get ErrorMonitoringService instance for dependency injection\n  const errorMonitoringService = app.get(ErrorMonitoringService);\n\n  // Global exception filter for centralized error handling\n  app.useGlobalFilters(new GlobalExceptionFilter(errorMonitoringService));\n\n  await app.listen(process.env.PORT ?? 3000);\n  console.log(`Server is running on: ${await app.getUrl()}`);\n}\nbootstrap();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\auth.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Param' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Query' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":58,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":62,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":58,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":62,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":59,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":59,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .query on an `any` value.","line":60,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":60,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":62,"column":7,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":62,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":67,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":67,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":67,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":108,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":110,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":114,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'clientType' is assigned a value but never used.","line":110,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":110,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":114,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":111,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .query on an `any` value.","line":112,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":114,"column":7,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":151,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":155,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":151,"column":26,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":155,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":152,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":152,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .query on an `any` value.","line":153,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":153,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":155,"column":9,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":156,"column":21,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":156,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":156,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":156,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":170,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":183,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":187,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":183,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":187,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":184,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":184,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .query on an `any` value.","line":185,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":185,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":187,"column":7,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":187,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":188,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":188,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":188,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":188,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":190,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":192,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .cookies on an `any` value.","line":191,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":191,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":198,"column":62,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":198,"endColumn":74},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'googleAuthCallback' has no 'await' expression.","line":245,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":245,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6567,6573],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":247,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":247,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":247,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":247,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accessToken on an `any` value.","line":257,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":257,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accessToken on an `any` value.","line":258,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":258,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .refreshToken on an `any` value.","line":267,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":267,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .refreshToken on an `any` value.","line":268,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":268,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":278,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":278,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":278,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":278,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":279,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":279,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .email on an `any` value.","line":279,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":279,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":280,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":280,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":280,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":280,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":281,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":281,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .avatar on an `any` value.","line":281,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":281,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":282,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":282,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isEmailVerified on an `any` value.","line":282,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":282,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":299,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":299,"endColumn":36}],"suppressedMessages":[],"errorCount":51,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  UseGuards,\n  Request,\n  HttpCode,\n  HttpStatus,\n  Param,\n  Res,\n  Query,\n  UnauthorizedException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { UserApplicationService } from '../users/application/user-application.service';\nimport { LoginDto } from './dto/login.dto';\nimport { JwtAuthGuard } from '../../shared/guards/jwt.guard';\nimport { RegisterDto } from './dto/register.dto';\nimport { ResendVerificationDto, VerifyEmailDto } from './dto/verifyEmail.dto';\nimport { GoogleAuthGuard } from '../../shared/guards/google.guard';\nimport { GoogleLoginDto } from './dto/google-auth.dto';\nimport { ForgotPasswordDto } from './dto/forgotPassword.dto';\nimport { ResetPasswordDto } from './dto/resetPassword.dto';\nimport { CurrentUser } from 'src/shared/decorators/currentUser.decorator';\nimport { Response } from 'express';\nimport { URLS } from '../../shared/constants/urls.constant';\nimport { JWT } from 'src/config/jwt.config';\nimport { AuthService } from './auth.service';\n\n@Controller('auth')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly userApplicationService: UserApplicationService,\n  ) {}\n\n  @UseGuards(JwtAuthGuard)\n  @Get('me')\n  @HttpCode(HttpStatus.OK)\n  async getCurrentUser(@CurrentUser('id') userId: string) {\n    return this.userApplicationService.getUserProfile(userId);\n  }\n\n  @Post('register')\n  @HttpCode(HttpStatus.CREATED)\n  async register(@Body() registerDto: RegisterDto) {\n    return this.authService.register(registerDto);\n  }\n\n  @Post('login')\n  @HttpCode(HttpStatus.OK)\n  async login(\n    @Body() loginDto: LoginDto,\n    @Request() req,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const clientType = (\n      req.headers['x-client-type'] ||\n      req.query.client ||\n      ''\n    ).toString();\n\n    const result = await this.authService.login(loginDto);\n\n    // If web client, set HttpOnly cookies and return minimal body\n    const isWeb = clientType.toLowerCase() === 'web';\n    const isProd = process.env.NODE_ENV === 'production';\n\n    if (isWeb) {\n      const accessMaxAge = parseExpiryToMs(JWT.EXPIRES_IN);\n      const refreshMaxAge = parseExpiryToMs(JWT.REFRESH_EXPIRES_IN);\n\n      // Set access token in HTTP-only cookie\n      if (result.accessToken) {\n        res.cookie('access_token', result.accessToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: accessMaxAge,\n        });\n      }\n\n      if (result.refreshToken) {\n        res.cookie('refresh_token', result.refreshToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: refreshMaxAge,\n        });\n      }\n\n      return {\n        message: 'Login successful',\n        user: result.user,\n      };\n    }\n\n    // Default: return tokens in body (mobile clients)\n    return result;\n  }\n\n  @Post('verify-email')\n  @HttpCode(HttpStatus.OK)\n  async verifyEmail(\n    @Body() verifyDto: VerifyEmailDto,\n    @Request() req,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const clientType = (\n      req.headers['x-client-type'] ||\n      req.query.client ||\n      ''\n    ).toString();\n\n    const result = await this.authService.verifyEmail(\n      verifyDto.token,\n      verifyDto.password,\n    );\n\n    // Email verification doesn't return tokens, just success message\n    return {\n      success: true,\n      message: result.message,\n      data: result,\n    };\n  }\n\n  @Post('resend-verification')\n  @HttpCode(HttpStatus.OK)\n  async resendVerificationEmail(@Body() resendDto: ResendVerificationDto) {\n    const result = await this.authService.resendVerificationEmail(\n      resendDto.email,\n    );\n    return {\n      success: true,\n      message: 'Verification email sent successfully',\n      data: result,\n    };\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Post('logout')\n  @HttpCode(HttpStatus.OK)\n  async logout(\n    @Body() body: { refreshToken?: string },\n    @Request() req,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    try {\n      const clientType = (\n        req.headers['x-client-type'] ||\n        req.query.client ||\n        ''\n      ).toString();\n      const isWeb = clientType.toLowerCase() === 'web';\n\n      // If web client, clear cookies\n      if (isWeb) {\n        res.clearCookie('access_token');\n        res.clearCookie('refresh_token');\n      }\n\n      // Revoke refresh token if provided\n      if (body.refreshToken) {\n        await this.authService.revokeRefreshToken(body.refreshToken);\n      }\n\n      return { message: 'Logged out successfully' };\n    } catch (error) {\n      return { message: 'Logged out successfully' };\n    }\n  }\n\n  @Post('refresh')\n  @HttpCode(HttpStatus.OK)\n  async refreshToken(\n    @Body() body: { refreshToken?: string },\n    @Request() req,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    // Accept refresh token either in body (mobile) or cookie (web)\n    const clientType = (\n      req.headers['x-client-type'] ||\n      req.query.client ||\n      ''\n    ).toString();\n    const isWeb = clientType.toLowerCase() === 'web';\n\n    const refreshToken = isWeb\n      ? req.cookies['refresh_token']\n      : body.refreshToken;\n\n    if (!refreshToken) {\n      throw new UnauthorizedException('Refresh token not found');\n    }\n\n    const tokens = await this.authService.refreshAccessToken(refreshToken);\n\n    if (isWeb) {\n      const isProd = process.env.NODE_ENV === 'production';\n      const accessMaxAge = parseExpiryToMs(JWT.EXPIRES_IN);\n      const refreshMaxAge = parseExpiryToMs(JWT.REFRESH_EXPIRES_IN);\n\n      // Set access token in HTTP-only cookie\n      if (tokens.accessToken) {\n        res.cookie('access_token', tokens.accessToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: accessMaxAge,\n        });\n      }\n\n      if (tokens.refreshToken) {\n        res.cookie('refresh_token', tokens.refreshToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: refreshMaxAge,\n        });\n      }\n\n      return {\n        message: 'Token refreshed',\n        expiresIn: JWT.EXPIRES_IN,\n      };\n    }\n\n    return tokens;\n  }\n\n  // ===== GOOGLE AUTHENTICATION ENDPOINTS =====\n\n  // For WEB: Redirect to Google OAuth\n  @Get('google')\n  @UseGuards(GoogleAuthGuard)\n  async googleAuth() {\n    // Initiates the Google OAuth flow\n  }\n\n  // For WEB: Google OAuth callback\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  async googleAuthCallback(@Request() req, @Res() res: Response) {\n    try {\n      const user = req.user;\n\n      // Set cookies for tokens (HttpOnly). Do not expose tokens via query string.\n      const isProd = process.env.NODE_ENV === 'production';\n\n      // Determine cookie options\n      const accessMaxAge = parseExpiryToMs(JWT.EXPIRES_IN);\n      const refreshMaxAge = parseExpiryToMs(JWT.REFRESH_EXPIRES_IN);\n\n      // Access token cookie\n      if (user.accessToken) {\n        res.cookie('access_token', user.accessToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: accessMaxAge,\n        });\n      }\n\n      // Refresh token cookie (if provided)\n      if (user.refreshToken) {\n        res.cookie('refresh_token', user.refreshToken, {\n          httpOnly: true,\n          secure: isProd,\n          sameSite: isProd ? 'none' : 'lax',\n          maxAge: refreshMaxAge,\n        });\n      }\n\n      // Return HTML with postMessage script for popup auth flow\n      const userData = {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        avatar: user.avatar,\n        isEmailVerified: user.isEmailVerified,\n      };\n\n      res.send(`\n        <script>\n          window.opener?.postMessage({\n            type: 'GOOGLE_AUTH_SUCCESS',\n            payload: { user: ${JSON.stringify(userData)} }\n          }, '${URLS.FRONT_END_WEB}');\n          window.close();\n        </script>\n      `);\n    } catch (error) {\n      res.send(`\n        <script>\n          window.opener?.postMessage({\n            type: 'GOOGLE_AUTH_ERROR',\n            error: '${error.message}'\n          }, '${URLS.FRONT_END_WEB}');\n          window.close();\n        </script>\n      `);\n    }\n  }\n\n  // For MOBILE: Verify Google ID Token\n  @Post('google/mobile')\n  @HttpCode(HttpStatus.OK)\n  async googleMobileAuth(@Body() googleLoginDto: GoogleLoginDto) {\n    return this.authService.verifyGoogleToken(googleLoginDto.idToken);\n  }\n\n  // Forgot Password\n  @Post('forgot-password')\n  @HttpCode(HttpStatus.OK)\n  async forgotPassword(@Body() forgotPasswordDto: ForgotPasswordDto) {\n    await this.authService.forgotPassword(forgotPasswordDto.email);\n    return {\n      success: true,\n      message: 'If the email exists, a password reset link has been sent.',\n    };\n  }\n\n  // Reset Password\n  @Post('reset-password')\n  @HttpCode(HttpStatus.OK)\n  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {\n    await this.authService.resetPassword(\n      resetPasswordDto.token,\n      resetPasswordDto.newPassword,\n      resetPasswordDto.confirmPassword,\n    );\n    return {\n      success: true,\n      message: 'Password has been reset successfully.',\n    };\n  }\n\n  // Admin: Cleanup expired tokens\n  @Post('admin/cleanup-tokens')\n  @HttpCode(HttpStatus.OK)\n  @UseGuards(JwtAuthGuard)\n  async cleanupExpiredTokens(@CurrentUser('role') userRole: string) {\n    // Only admin can cleanup tokens\n    if (userRole !== 'ADMIN') {\n      throw new UnauthorizedException('Admin access required');\n    }\n\n    const result = await this.authService.cleanupExpiredTokens();\n    return {\n      success: true,\n      message: `Cleaned up ${result.count} expired/revoked tokens`,\n      deletedCount: result.count,\n    };\n  }\n\n  // Get user's active sessions\n  @UseGuards(JwtAuthGuard)\n  @Get('sessions')\n  @HttpCode(HttpStatus.OK)\n  async getUserSessions(@CurrentUser('id') userId: string) {\n    const sessions = await this.authService.getUserSessions(userId);\n    return {\n      success: true,\n      data: sessions,\n      message: `Found ${sessions.total} active sessions`,\n    };\n  }\n\n  // Cleanup zombie sessions (inactive for specified days)\n  @UseGuards(JwtAuthGuard)\n  @Post('cleanup-zombie-sessions')\n  @HttpCode(HttpStatus.OK)\n  async cleanupZombieSessions(\n    @CurrentUser('id') userId: string,\n    @Body() body: { inactiveDays?: number } = {},\n  ) {\n    const inactiveDays = body.inactiveDays || 30; // Default 30 days\n    const result = await this.authService.cleanupZombieSessions(userId);\n\n    return {\n      success: true,\n      message: `Cleaned up ${result.cleaned} zombie sessions (inactive for ${inactiveDays}+ days)`,\n      deletedCount: result.cleaned,\n    };\n  }\n\n  // Admin: Cleanup all zombie sessions globally\n  @Post('admin/cleanup-all-zombie-sessions')\n  @HttpCode(HttpStatus.OK)\n  // @UseGuards(JwtAuthGuard)\n  async adminCleanupZombieSessions(\n    @CurrentUser('role') userRole: string,\n    @Body() body: { inactiveDays?: number } = {},\n  ) {\n    // if (userRole !== 'ADMIN') {\n    //   throw new UnauthorizedException('Admin access required');\n    // }\n\n    const inactiveDays = body.inactiveDays || 7;\n    const result =\n      await this.authService.cleanupAllZombieSessions(inactiveDays);\n\n    return {\n      success: true,\n      message: `Globally cleaned up ${result.cleaned} zombie sessions across all users`,\n      deletedCount: result.cleaned,\n    };\n  }\n\n  // Revoke specific sessions by session IDs\n  @UseGuards(JwtAuthGuard)\n  @Post('revoke-sessions')\n  @HttpCode(HttpStatus.OK)\n  async revokeSessions(\n    @CurrentUser('id') userId: string,\n    @Body() body: { sessionIds: string[] },\n  ) {\n    if (!body.sessionIds || body.sessionIds.length === 0) {\n      throw new BadRequestException('Session IDs are required');\n    }\n\n    const result = await this.authService.revokeUserSessions(\n      userId,\n      body.sessionIds,\n    );\n    return {\n      success: true,\n      message: `Revoked ${result.revokedCount} sessions`,\n      revokedCount: result.revokedCount,\n    };\n  }\n\n  // Revoke ALL user sessions (force logout from all devices)\n  @UseGuards(JwtAuthGuard)\n  @Post('revoke-all-sessions')\n  @HttpCode(HttpStatus.OK)\n  async revokeAllSessions(@CurrentUser('id') userId: string) {\n    const result = await this.authService.revokeAllUserSessions(userId);\n    return {\n      success: true,\n      message: result.message,\n      revokedCount: result.revokedCount,\n      sessionIds: result.sessionIds,\n    };\n  }\n}\n\n// Helper: convert expiry like '24h' or '7d' or seconds string to milliseconds for cookie maxAge\nfunction parseExpiryToMs(expiry: string | undefined): number {\n  if (!expiry) return 0;\n  const s = expiry.trim().toLowerCase();\n  const num = parseInt(s, 10);\n  if (s.endsWith('ms')) return num;\n  if (s.endsWith('s')) return num * 1000;\n  if (s.endsWith('m')) return num * 60 * 1000;\n  if (s.endsWith('h')) return num * 60 * 60 * 1000;\n  if (s.endsWith('d')) return num * 24 * 60 * 60 * 1000;\n  // Fallback: if it's a number string, assume seconds\n  if (!isNaN(num)) return num * 1000;\n  return 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\auth.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConflictException' is defined but never used.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BadRequestException' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotFoundException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bcrypt' is defined but never used.","line":19,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":19},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":77,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":80,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[2362,2362],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[2362,2362],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getUserSessions' has no 'await' expression.","line":117,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":117,"endColumn":24,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3388,3394],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":117,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":31},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'cleanupZombieSessions' has no 'await' expression.","line":122,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":122,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3543,3549],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":122,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":37},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'cleanupAllZombieSessions' has no 'await' expression.","line":127,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":127,"endColumn":33,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3731,3737],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'inactiveDays' is defined but never used.","line":127,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":46},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'cleanupExpiredTokens' has no 'await' expression.","line":174,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":174,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4975,4981],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'verifyGoogleToken' has no 'await' expression.","line":179,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":179,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5156,5162],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'idToken' is defined but never used.","line":179,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":34},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":199,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":202,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[5742,5742],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[5742,5742],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":237,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":240,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6828,6828],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6828,6828],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":315,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":19}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  UnauthorizedException,\n  ConflictException,\n  BadRequestException,\n  NotFoundException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../../database/prisma.service';\nimport { RegisterDto } from './dto/register.dto';\nimport { LoginDto } from './dto/login.dto';\nimport { GoogleUserDto } from './dto/google-auth.dto';\nimport { UserManagementService } from './repositories/user-management.repository';\nimport { AuthenticationService } from './repositories/authentication.repository';\nimport { SessionService } from './repositories/session.repository';\nimport { TokenService } from './repositories/token.repository';\nimport { RedisCacheService } from '../cache/cache.service';\nimport { NotificationGateway } from '../notification';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService,\n    private userManagementService: UserManagementService,\n    private authenticationService: AuthenticationService,\n    private sessionService: SessionService,\n    private tokenService: TokenService,\n    private cacheService: RedisCacheService,\n    private notificationGateway: NotificationGateway,\n  ) {}\n\n  // ===== USER REGISTRATION & EMAIL VERIFICATION =====\n\n  async register(registerDto: RegisterDto) {\n    return this.userManagementService.registerUser(registerDto);\n  }\n\n  async verifyEmail(token: string, password?: string) {\n    return this.userManagementService.verifyEmail(token, password);\n  }\n\n  async resendVerificationEmail(email: string) {\n    return this.userManagementService.resendVerificationEmail(email);\n  }\n\n  // ===== PASSWORD MANAGEMENT =====\n\n  async forgotPassword(email: string) {\n    return this.userManagementService.forgotPassword(email);\n  }\n\n  async resetPassword(\n    token: string,\n    newPassword: string,\n    confirmPassword: string,\n  ) {\n    return this.userManagementService.resetPassword(\n      token,\n      newPassword,\n      confirmPassword,\n    );\n  }\n\n  // ===== AUTHENTICATION =====\n\n  async login(loginDto: LoginDto, ipAddress?: string, userAgent?: string) {\n    const result = await this.authenticationService.login(\n      loginDto,\n      ipAddress,\n      userAgent,\n    );\n\n    // Send notification\n    if (result.success && result.user) {\n      this.notificationGateway.broadcast({\n        userId: result.user.id,\n        message: 'User logged in',\n      });\n    }\n\n    return result;\n  }\n\n  async logout(sessionId: string, userId: string) {\n    return this.authenticationService.logout(sessionId, userId);\n  }\n\n  async logoutAllDevices(userId: string, currentSessionId?: string) {\n    return this.authenticationService.logoutAllDevices(\n      userId,\n      currentSessionId,\n    );\n  }\n\n  // ===== TOKEN MANAGEMENT =====\n\n  async refreshAccessToken(refreshToken: string) {\n    return this.tokenService.refreshAccessToken(refreshToken);\n  }\n\n  async revokeRefreshToken(refreshToken: string) {\n    return this.tokenService.revokeRefreshToken(refreshToken);\n  }\n\n  async validateAccessToken(token: string) {\n    return this.authenticationService.validateAccessToken(token);\n  }\n\n  async revokeToken(token: string, tokenType: 'access' | 'refresh' = 'access') {\n    return this.authenticationService.revokeToken(token, tokenType);\n  }\n\n  // ===== SESSION MANAGEMENT =====\n\n  async getUserSessions(userId: string) {\n    // Mock implementation - should be implemented in SessionService\n    return { sessions: [], total: 0 };\n  }\n\n  async cleanupZombieSessions(userId: string) {\n    // Mock implementation - should be implemented in SessionService\n    return { message: 'Zombie sessions cleaned up', cleaned: 0 };\n  }\n\n  async cleanupAllZombieSessions(inactiveDays?: number) {\n    // Mock implementation - should be implemented in SessionService\n    return { message: 'All zombie sessions cleaned up', cleaned: 0 };\n  }\n\n  async revokeUserSessions(userId: string, sessionIds: string[]) {\n    return this.sessionService.deleteSessions(userId, sessionIds);\n  }\n\n  async revokeAllUserSessions(userId: string) {\n    // Get all user sessions first\n    const userSessions = await this.prisma.session.findMany({\n      where: {\n        userId,\n        isRevoked: false,\n      },\n      select: {\n        id: true,\n        sessionId: true,\n      },\n    });\n\n    if (userSessions.length === 0) {\n      return {\n        message: 'No active sessions found to revoke',\n        revokedCount: 0,\n      };\n    }\n\n    // Delete all sessions for the user\n    const deleteResult = await this.prisma.session.deleteMany({\n      where: {\n        userId,\n        isRevoked: false,\n      },\n    });\n\n    // Also revoke all user tokens\n    await this.tokenService.revokeAllUserTokens(userId);\n\n    return {\n      message: `Successfully revoked all ${deleteResult.count} sessions`,\n      revokedCount: deleteResult.count,\n      sessionIds: userSessions.map((s) => s.sessionId),\n    };\n  }\n\n  async cleanupExpiredTokens() {\n    // Mock implementation - should be implemented in TokenService\n    return { message: 'Expired tokens cleaned up successfully', count: 0 };\n  }\n\n  async verifyGoogleToken(idToken: string) {\n    // Mock implementation - should be implemented for Google OAuth\n    throw new Error('Google token verification not implemented yet');\n  }\n\n  // ===== GOOGLE AUTHENTICATION =====\n\n  async googleLogin(googleUser: GoogleUserDto) {\n    // Check if user exists\n    let user = await this.prisma.user.findUnique({\n      where: { email: googleUser.email },\n    });\n\n    if (user) {\n      // User exists, create tokens and login\n      const tokens = await this.tokenService.createTokensForUser(\n        user.id,\n        user.email,\n      );\n\n      this.notificationGateway.broadcast({\n        userId: user.id,\n        message: 'User logged in via Google',\n      });\n\n      return {\n        success: true,\n        message: 'Google login successful',\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        user: {\n          id: user.id,\n          email: user.email,\n          userName: user.username,\n          fullName: user.fullName,\n          avatar: user.avatar,\n          role: user.role,\n        },\n      };\n    } else {\n      // User doesn't exist, create new user\n      user = await this.prisma.user.create({\n        data: {\n          email: googleUser.email,\n          fullName: googleUser.fullName,\n          avatar: googleUser.profilePicture,\n          isEmailVerified: true, // Google accounts are pre-verified\n          emailVerifiedAt: new Date(),\n          // Generate a username from email\n          username: googleUser.email.split('@')[0],\n        },\n      });\n\n      const tokens = await this.tokenService.createTokensForUser(\n        user.id,\n        user.email,\n      );\n\n      this.notificationGateway.broadcast({\n        userId: user.id,\n        message: 'New user registered via Google',\n      });\n\n      return {\n        success: true,\n        message: 'Google registration and login successful',\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        user: {\n          id: user.id,\n          email: user.email,\n          userName: user.username,\n          fullName: user.fullName,\n          avatar: user.avatar,\n          role: user.role,\n        },\n      };\n    }\n  }\n\n  // ===== VALIDATE USER (used by strategies) =====\n\n  /**\n   * Validate user by id for authentication strategies (JWT)\n   * Returns user object (minimal public fields) or null if not found / not verified\n   */\n  async validateUserById(userId: string) {\n    if (!userId) return null;\n\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        username: true,\n        role: true,\n        fullName: true,\n        avatar: true,\n        isEmailVerified: true,\n      },\n    });\n\n    // Reject users who haven't verified email\n    if (!user || !user.isEmailVerified) return null;\n\n    return user;\n  }\n\n  // ===== UTILITY METHODS =====\n\n  async verifyRefreshToken(\n    refreshToken: string,\n  ): Promise<{ userId: string; email: string }> {\n    if (!refreshToken) {\n      throw new UnauthorizedException('Refresh token is required');\n    }\n\n    try {\n      // Use SessionService to get session info from refresh token\n      const sessionInfo =\n        await this.sessionService.getSessionFromRefreshToken(refreshToken);\n\n      // Get user info from session\n      const session = await this.prisma.session.findUnique({\n        where: { id: sessionInfo.id },\n        include: { user: true },\n      });\n\n      if (!session || session.isRevoked) {\n        throw new UnauthorizedException('Invalid refresh token');\n      }\n\n      return {\n        userId: session.userId,\n        email: session.user.email,\n      };\n    } catch (error) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\entities\\auth-result.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuthToken' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AuthUser } from './user.entity';\nimport { AuthToken } from './token.entity';\n\nexport interface AuthResult {\n  success: boolean;\n  message: string;\n  user?: Partial<AuthUser>;\n  accessToken?: string;\n  refreshToken?: string;\n  sessionId?: string;\n}\n\nexport interface LoginResult extends AuthResult {\n  user: {\n    id: string;\n    email: string;\n    userName: string;\n    fullName: string;\n    avatar?: string;\n    role: string;\n  };\n  accessToken: string;\n  refreshToken: string;\n  sessionId: string;\n}\n\nexport interface RegisterResult {\n  success: boolean;\n  message: string;\n  user?: {\n    id: string;\n    email: string;\n    userName: string;\n    fullName: string;\n  };\n}\n\nexport interface TokenRefreshResult {\n  success: boolean;\n  message: string;\n  accessToken?: string;\n  refreshToken?: string;\n}\n\nexport interface PasswordResetResult {\n  success: boolean;\n  message: string;\n}\n\nexport interface EmailVerificationResult {\n  success: boolean;\n  message: string;\n  user?: Partial<AuthUser>;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\entities\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\entities\\session.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\entities\\token.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\entities\\user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\repositories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\repositories\\session.repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\repositories\\token.repository.interface.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RefreshTokenData' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AuthToken,\n  TokenPayload,\n  AccessTokenData,\n  RefreshTokenData,\n} from '../entities';\n\nexport interface ITokenRepository {\n  // Token generation\n  generateAccessToken(payload: AccessTokenData): Promise<string>;\n  generateRefreshToken(): Promise<string>;\n  createTokensForUser(\n    userId: string,\n    email: string,\n    role: string,\n  ): Promise<AuthToken>;\n\n  // Token validation\n  validateAccessToken(token: string): Promise<TokenPayload | null>;\n  validateRefreshToken(refreshToken: string): Promise<TokenPayload | null>;\n\n  // Token refresh\n  refreshAccessToken(\n    refreshToken: string,\n  ): Promise<{ accessToken: string; refreshToken: string }>;\n\n  // Token revocation\n  revokeToken(token: string, tokenType: 'access' | 'refresh'): Promise<void>;\n  revokeAllUserTokens(userId: string): Promise<void>;\n\n  // Token cleanup\n  cleanupExpiredTokens(): Promise<number>;\n\n  // Token verification utilities\n  decodeToken(token: string): Promise<TokenPayload | null>;\n  isTokenExpired(token: string): Promise<boolean>;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\repositories\\user.repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\auth.dtos.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\base.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\forgot-password.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\google-auth.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConflictException' is defined but never used.","line":1,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, ConflictException } from '@nestjs/common';\nimport { BaseUseCase } from './base.use-case';\nimport { GoogleAuthRequest } from './auth.dtos';\nimport { LoginResult } from '../entities';\nimport { IUserRepository, ITokenRepository } from '../repositories';\nimport { ROLES } from '../../../../shared/constants/roles.constant';\n\n@Injectable()\nexport class GoogleAuthUseCase extends BaseUseCase<\n  GoogleAuthRequest,\n  LoginResult\n> {\n  constructor(\n    private userRepository: IUserRepository,\n    private tokenRepository: ITokenRepository,\n  ) {\n    super();\n  }\n\n  async execute(request: GoogleAuthRequest): Promise<LoginResult> {\n    const { email, fullName, profilePicture } = request;\n\n    // Check if user exists\n    let user = await this.userRepository.findUserByEmail(email);\n\n    if (user) {\n      // User exists, generate tokens and return\n      const tokens = await this.tokenRepository.createTokensForUser(\n        user.id,\n        user.email,\n        user.role,\n      );\n\n      return {\n        success: true,\n        message: 'Google login successful',\n        user: {\n          id: user.id,\n          email: user.email,\n          userName: user.userName,\n          fullName: user.fullName,\n          avatar: user.avatar,\n          role: user.role,\n        },\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        sessionId: `google_session_${Date.now()}`, // Temporary session ID\n      };\n    } else {\n      // User doesn't exist, create new user\n      let userName = email.split('@')[0]; // Generate username from email\n\n      // Check if username already exists\n      const existingUserByUsername =\n        await this.userRepository.findUserByUsername(userName);\n      if (existingUserByUsername) {\n        // Use email prefix with random number if username taken\n        const randomSuffix = Math.floor(Math.random() * 1000);\n        userName = `${email.split('@')[0]}${randomSuffix}`;\n      }\n\n      user = await this.userRepository.createUser({\n        email,\n        fullName,\n        userName,\n        avatar: profilePicture,\n        isEmailVerified: true, // Google accounts are pre-verified\n        role: ROLES.USER,\n      });\n\n      const tokens = await this.tokenRepository.createTokensForUser(\n        user.id,\n        user.email,\n        user.role,\n      );\n\n      return {\n        success: true,\n        message: 'Google registration and login successful',\n        user: {\n          id: user.id,\n          email: user.email,\n          userName: user.userName,\n          fullName: user.fullName,\n          avatar: user.avatar,\n          role: user.role,\n        },\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        sessionId: `google_session_${Date.now()}`, // Temporary session ID\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\login.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\logout.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\refresh-token.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\register-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\reset-password.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\domain\\use-cases\\verify-email.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\forgotPassword.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\google-auth.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\login.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\register.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsDateString' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":27,"column":5,"nodeType":"ConditionalExpression","messageId":"unsafeReturn","endLine":27,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":44,"column":17,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":44,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":59,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":59,"endColumn":18}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BadRequestException } from '@nestjs/common';\nimport { Transform } from 'class-transformer';\nimport {\n  IsEmail,\n  IsString,\n  IsOptional,\n  MinLength,\n  MaxLength,\n  IsUrl,\n  IsDateString,\n  Matches,\n  IsNotEmpty,\n  IsDate,\n} from 'class-validator';\nimport { isValid, parse } from 'date-fns';\n\nexport class RegisterDto {\n  @IsOptional()\n  @IsString()\n  @MinLength(3, { message: 'Username must be at least 3 characters long' })\n  @MaxLength(30, { message: 'Username must not exceed 30 characters' })\n  @Matches(/^[a-z0-9._]+$/, {\n    message:\n      'Username can only contain lowercase letters, numbers, dot and underscore',\n  })\n  @Transform(({ value }) =>\n    typeof value === 'string' ? value.trim().toLowerCase() : value,\n  )\n  userName?: string;\n\n  @IsString()\n  @IsNotEmpty({ message: 'Full name is required' })\n  @MinLength(2, { message: 'Full name must be at least 2 characters long' })\n  @MaxLength(50, { message: 'Full name must not exceed 50 characters' })\n  fullName: string;\n\n  @IsEmail({}, { message: 'Please provide a valid email address' })\n  @IsNotEmpty({ message: 'Email is required' })\n  email: string;\n\n  @IsNotEmpty({ message: 'Date of birth is required' })\n  @IsDate({ message: 'Date of birth must be a valid date' })\n  @Transform(({ value }) => {\n    if (!value) return value;\n    if (typeof value === 'string') {\n      // try ISO first\n      const iso = new Date(value);\n      if (!isNaN(iso.getTime())) return iso;\n\n      // fallback to dd/MM/yyyy\n      const parsedDate = parse(value, 'dd/MM/yyyy', new Date());\n      if (!isValid(parsedDate)) {\n        throw new BadRequestException(\n          'Invalid date format. Use ISO (YYYY-MM-DD) or DD/MM/YYYY.',\n        );\n      }\n      return parsedDate;\n    }\n    return value;\n  })\n  dateOfBirth: Date;\n\n  @IsString()\n  @IsOptional()\n  @MaxLength(10, { message: 'Gender must not exceed 10 characters' })\n  gender?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(15, { message: 'Phone number must not exceed 15 characters' })\n  phoneNumber?: string;\n\n  @IsOptional()\n  @IsUrl({}, { message: 'Avatar must be a valid URL' })\n  avatar?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(500, { message: 'Bio must not exceed 500 characters' })\n  bio?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(100, { message: 'Location must not exceed 100 characters' })\n  location?: string;\n\n  @IsOptional()\n  @IsUrl({}, { message: 'Website URL must be a valid URL' })\n  @MaxLength(200, { message: 'Website URL must not exceed 200 characters' })\n  websiteUrl?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\resetPassword.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\dto\\verifyEmail.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUUID' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsEmail,\n  IsString,\n  IsNotEmpty,\n  IsOptional,\n  IsUUID,\n  MinLength,\n  MaxLength,\n  Matches,\n} from 'class-validator';\n\nexport class VerifyEmailDto {\n  @IsString()\n  @IsNotEmpty({ message: 'Verification token is required' })\n  token: string;\n\n  @IsOptional()\n  @IsString()\n  @MinLength(8, { message: 'Password must be at least 8 characters long' })\n  @MaxLength(100, { message: 'Password must not exceed 100 characters' })\n  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&]).{8,}$/, {\n    message:\n      'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',\n  })\n  password?: string;\n}\n\nexport class ResendVerificationDto {\n  @IsEmail({}, { message: 'Please provide a valid email address' })\n  @IsNotEmpty({ message: 'Email is required' })\n  email: string;\n}\n\nexport class EmailVerificationStatusDto {\n  @IsEmail({}, { message: 'Please provide a valid email address' })\n  email: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\infrastructure\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\infrastructure\\session.repository.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'findSessionByRefreshToken' has no 'await' expression.","line":47,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":47,"endColumn":34,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1377,1468],"text":"findSessionByRefreshToken(\n    refreshToken: string,\n  ): AuthSession | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'isRefreshTokenValid' has no 'await' expression.","line":180,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":180,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4603,4668],"text":"isRefreshTokenValid(refreshToken: string): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":194,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":194,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":194,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":194,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":195,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":195,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sessionId on an `any` value.","line":195,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":195,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":196,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":196,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":196,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":196,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":198,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":198,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ipAddress on an `any` value.","line":198,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":198,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":199,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":199,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userAgent on an `any` value.","line":199,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":199,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":200,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":200,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRevoked on an `any` value.","line":200,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":200,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":201,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":201,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":201,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":201,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":202,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":202,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .expiresAt on an `any` value.","line":202,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":202,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":203,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":203,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRevoked on an `any` value.","line":203,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":203,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":203,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":203,"endColumn":55}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport { ISessionRepository } from '../domain/repositories';\nimport {\n  AuthSession,\n  AuthSessionCreationData,\n  AuthSessionUpdateData,\n} from '../domain/entities';\n\n@Injectable()\nexport class SessionRepository implements ISessionRepository {\n  constructor(private prisma: PrismaService) {}\n\n  async createSession(\n    sessionData: AuthSessionCreationData,\n  ): Promise<AuthSession> {\n    const session = await this.prisma.session.create({\n      data: {\n        sessionId: sessionData.sessionId,\n        userId: sessionData.userId,\n        ipAddress: sessionData.ipAddress,\n        userAgent: sessionData.userAgent,\n        expiresAt: sessionData.expiresAt,\n        isRevoked: false,\n      },\n    });\n\n    return this.mapPrismaSessionToEntity(session, sessionData.refreshToken);\n  }\n\n  async findSessionById(id: string): Promise<AuthSession | null> {\n    const session = await this.prisma.session.findUnique({\n      where: { id },\n    });\n\n    return session ? this.mapPrismaSessionToEntity(session) : null;\n  }\n\n  async findSessionBySessionId(sessionId: string): Promise<AuthSession | null> {\n    const session = await this.prisma.session.findUnique({\n      where: { sessionId },\n    });\n\n    return session ? this.mapPrismaSessionToEntity(session) : null;\n  }\n\n  async findSessionByRefreshToken(\n    refreshToken: string,\n  ): Promise<AuthSession | null> {\n    // Note: refreshToken not in schema - would need alternative storage (Redis/separate table)\n    // For now, return null as we can't query by refreshToken\n    console.log(\n      `Finding session by refresh token: ${refreshToken} - not implemented due to schema limitations`,\n    );\n    return null;\n  }\n\n  async findUserSessions(userId: string): Promise<AuthSession[]> {\n    const sessions = await this.prisma.session.findMany({\n      where: { userId },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return sessions.map((session) => this.mapPrismaSessionToEntity(session));\n  }\n\n  async findActiveUserSessions(userId: string): Promise<AuthSession[]> {\n    const sessions = await this.prisma.session.findMany({\n      where: {\n        userId,\n        isRevoked: false,\n        expiresAt: {\n          gt: new Date(),\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return sessions.map((session) => this.mapPrismaSessionToEntity(session));\n  }\n\n  async updateSession(\n    id: string,\n    sessionData: AuthSessionUpdateData,\n  ): Promise<AuthSession> {\n    const session = await this.prisma.session.update({\n      where: { id },\n      data: {\n        isRevoked: sessionData.isRevoked,\n        // Note: revokedAt not in schema\n      },\n    });\n\n    return this.mapPrismaSessionToEntity(session);\n  }\n\n  async revokeSession(sessionId: string): Promise<void> {\n    await this.prisma.session.update({\n      where: { sessionId },\n      data: {\n        isRevoked: true,\n        // Note: revokedAt not in schema\n      },\n    });\n  }\n\n  async revokeUserSessions(\n    userId: string,\n    sessionIds: string[],\n  ): Promise<number> {\n    const result = await this.prisma.session.updateMany({\n      where: {\n        userId,\n        sessionId: { in: sessionIds },\n      },\n      data: {\n        isRevoked: true,\n        // Note: revokedAt not in schema\n      },\n    });\n\n    return result.count;\n  }\n\n  async revokeAllUserSessions(userId: string): Promise<number> {\n    const result = await this.prisma.session.updateMany({\n      where: {\n        userId,\n        isRevoked: false,\n      },\n      data: {\n        isRevoked: true,\n        // Note: revokedAt not in schema\n      },\n    });\n\n    return result.count;\n  }\n\n  async deleteExpiredSessions(): Promise<number> {\n    const result = await this.prisma.session.deleteMany({\n      where: {\n        OR: [{ expiresAt: { lt: new Date() } }, { isRevoked: true }],\n      },\n    });\n\n    return result.count;\n  }\n\n  async deleteUserSessions(\n    userId: string,\n    sessionIds: string[],\n  ): Promise<number> {\n    const result = await this.prisma.session.deleteMany({\n      where: {\n        userId,\n        sessionId: { in: sessionIds },\n      },\n    });\n\n    return result.count;\n  }\n\n  async isSessionValid(sessionId: string): Promise<boolean> {\n    const session = await this.prisma.session.findUnique({\n      where: { sessionId },\n      select: {\n        isRevoked: true,\n        expiresAt: true,\n      },\n    });\n\n    if (!session) return false;\n    if (session.isRevoked) return false;\n    if (session.expiresAt < new Date()) return false;\n\n    return true;\n  }\n\n  async isRefreshTokenValid(refreshToken: string): Promise<boolean> {\n    // Note: refreshToken not in schema - would need alternative storage\n    // For now, always return false as we can't validate refresh tokens\n    console.log(\n      `Validating refresh token: ${refreshToken} - not implemented due to schema limitations`,\n    );\n    return false;\n  }\n\n  private mapPrismaSessionToEntity(\n    session: any,\n    refreshToken?: string,\n  ): AuthSession {\n    return {\n      id: session.id,\n      sessionId: session.sessionId,\n      userId: session.userId,\n      refreshToken: refreshToken || '', // Use provided refreshToken or empty string\n      ipAddress: session.ipAddress,\n      userAgent: session.userAgent,\n      isRevoked: session.isRevoked,\n      createdAt: session.createdAt,\n      expiresAt: session.expiresAt,\n      revokedAt: session.isRevoked ? session.createdAt : undefined, // Fallback for revokedAt\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\infrastructure\\token.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RefreshTokenData' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":19},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'generateRefreshToken' has no 'await' expression.","line":30,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":30,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[737,782],"text":"generateRefreshToken(): string"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":60,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":60,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":62,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":19},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validateRefreshToken' has no 'await' expression.","line":67,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":67,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1610,1697],"text":"validateRefreshToken(\n    refreshToken: string,\n  ): TokenPayload | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'refreshToken' is defined but never used.","line":68,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":17},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'refreshAccessToken' has no 'await' expression.","line":76,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":76,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1930,2041],"text":"refreshAccessToken(\n    refreshToken: string,\n  ): { accessToken: string; refreshToken: string }"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'refreshToken' is defined but never used.","line":77,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":17},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'revokeToken' has no 'await' expression.","line":89,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":89,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2408,2501],"text":"revokeToken(\n    token: string,\n    tokenType: 'access' | 'refresh',\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'revokeAllUserTokens' has no 'await' expression.","line":98,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":98,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2713,2769],"text":"revokeAllUserTokens(userId: string): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'cleanupExpiredTokens' has no 'await' expression.","line":103,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":103,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2900,2945],"text":"cleanupExpiredTokens(): number"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'decodeToken' has no 'await' expression.","line":108,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":108,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3049,3111],"text":"decodeToken(token: string): TokenPayload | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":110,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":110,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":112,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":121,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":19}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ITokenRepository } from '../domain/repositories';\nimport {\n  AuthToken,\n  TokenPayload,\n  AccessTokenData,\n  RefreshTokenData,\n} from '../domain/entities';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class TokenRepository implements ITokenRepository {\n  constructor(private jwtService: JwtService) {}\n\n  async generateAccessToken(payload: AccessTokenData): Promise<string> {\n    return this.jwtService.signAsync(\n      {\n        userId: payload.userId,\n        email: payload.email,\n        role: payload.role,\n        sessionId: payload.sessionId,\n      },\n      {\n        expiresIn: '15m', // 15 minutes\n      },\n    );\n  }\n\n  async generateRefreshToken(): Promise<string> {\n    return crypto.randomBytes(64).toString('hex');\n  }\n\n  async createTokensForUser(\n    userId: string,\n    email: string,\n    role: string,\n  ): Promise<AuthToken> {\n    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const accessToken = await this.generateAccessToken({\n      userId,\n      email,\n      role,\n      sessionId,\n    });\n\n    const refreshToken = await this.generateRefreshToken();\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: 15 * 60, // 15 minutes in seconds\n      tokenType: 'Bearer',\n    };\n  }\n\n  async validateAccessToken(token: string): Promise<TokenPayload | null> {\n    try {\n      const payload = await this.jwtService.verifyAsync(token);\n      return payload as TokenPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async validateRefreshToken(\n    refreshToken: string,\n  ): Promise<TokenPayload | null> {\n    // For refresh tokens, we need to validate against stored sessions\n    // This would typically involve checking against the session repository\n    // For now, return null as we need session integration\n    return null;\n  }\n\n  async refreshAccessToken(\n    refreshToken: string,\n  ): Promise<{ accessToken: string; refreshToken: string }> {\n    // This would typically:\n    // 1. Validate the refresh token against session storage\n    // 2. Get user info from session\n    // 3. Generate new access token\n    // 4. Optionally rotate refresh token\n\n    // For now, throw error as this needs session repository integration\n    throw new Error('Token refresh requires session repository integration');\n  }\n\n  async revokeToken(\n    token: string,\n    tokenType: 'access' | 'refresh',\n  ): Promise<void> {\n    // For JWT access tokens, we can't really revoke them without a blacklist\n    // For refresh tokens, we would revoke the associated session\n    console.log(`Revoking ${tokenType} token: ${token}`);\n  }\n\n  async revokeAllUserTokens(userId: string): Promise<void> {\n    // This would typically revoke all sessions for the user\n    console.log(`Revoking all tokens for user: ${userId}`);\n  }\n\n  async cleanupExpiredTokens(): Promise<number> {\n    // JWT tokens expire automatically, refresh tokens are cleaned via sessions\n    return 0;\n  }\n\n  async decodeToken(token: string): Promise<TokenPayload | null> {\n    try {\n      const decoded = this.jwtService.decode(token);\n      return decoded as TokenPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async isTokenExpired(token: string): Promise<boolean> {\n    try {\n      await this.jwtService.verifyAsync(token);\n      return false;\n    } catch (error) {\n      return true;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\repositories\\authentication.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":168,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":168,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":178,"column":18,"nodeType":"Property","messageId":"anyAssignment","endLine":178,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":178,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":178,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":197,"column":22,"nodeType":"Property","messageId":"anyAssignment","endLine":197,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":199,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":199,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":202,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":202,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":229,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":229,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .exp on an `any` value.","line":230,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":230,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .exp on an `any` value.","line":231,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":231,"endColumn":32}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  BadRequestException,\n  UnauthorizedException,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport { JwtService } from '@nestjs/jwt';\nimport { LoginDto } from '../dto/login.dto';\nimport { SessionService } from './session.repository';\nimport { TokenService } from './token.repository';\nimport { RedisCacheService } from '../../cache/cache.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class AuthenticationService {\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService,\n    private sessionService: SessionService,\n    private tokenService: TokenService,\n    private cacheService: RedisCacheService,\n  ) {}\n\n  // ===== LOGIN =====\n\n  async login(loginDto: LoginDto, ipAddress?: string, userAgent?: string) {\n    const { email, userName, password } = loginDto;\n\n    // Find user by email or username\n    const user = await this.prisma.user.findFirst({\n      where: {\n        OR: [{ email }, ...(userName ? [{ username: userName }] : [])],\n      },\n      select: {\n        id: true,\n        email: true,\n        username: true,\n        fullName: true,\n        avatar: true,\n        role: true,\n        status: true,\n        isEmailVerified: true,\n        passwordHash: true, // Include password for authentication\n        dateOfBirth: true,\n        emailVerifiedAt: true,\n      },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if email is verified\n    if (!user.isEmailVerified) {\n      throw new ForbiddenException(\n        'Please verify your email before logging in. Check your email for verification instructions.',\n      );\n    }\n\n    // Check if user has a password set\n    if (!user.passwordHash) {\n      throw new BadRequestException(\n        'Password not set. Please complete email verification to set your password.',\n      );\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Create tokens\n    const tokens = await this.createTokensForUser(\n      user.id,\n      user.email,\n      userAgent,\n      ipAddress,\n    );\n\n    return {\n      success: true,\n      message: 'Login successful',\n      accessToken: tokens.accessToken,\n      refreshToken: tokens.refreshToken,\n      user: {\n        id: user.id,\n        email: user.email,\n        userName: user.username,\n        fullName: user.fullName,\n        avatar: user.avatar,\n        role: user.role,\n        dateOfBirth: user.dateOfBirth,\n        isEmailVerified: user.isEmailVerified,\n        emailVerifiedAt: user.emailVerifiedAt,\n      },\n    };\n  }\n\n  private async createTokensForUser(\n    userId: string,\n    email: string,\n    userAgent?: string,\n    ipAddress?: string,\n  ): Promise<{ accessToken: string; refreshToken: string }> {\n    const payload = { sub: userId, email };\n    const accessToken = this.jwtService.sign(payload);\n    const refreshToken = await this.sessionService.createSession(\n      userId,\n      userAgent,\n      ipAddress,\n    );\n\n    return { accessToken, refreshToken };\n  }\n\n  // ===== LOGOUT =====\n\n  async logout(sessionId: string, userId: string) {\n    // Verify session belongs to user\n    const session = await this.prisma.session.findFirst({\n      where: {\n        id: sessionId,\n        userId,\n        isRevoked: false,\n      },\n    });\n\n    if (!session) {\n      throw new NotFoundException('Session not found');\n    }\n\n    // Delete the session\n    await this.sessionService.deleteSession(sessionId);\n\n    return { message: 'Logged out successfully' };\n  }\n\n  // ===== LOGOUT ALL DEVICES =====\n\n  async logoutAllDevices(userId: string, currentSessionId?: string) {\n    const sessions = await this.prisma.session.findMany({\n      where: {\n        userId,\n        isRevoked: false,\n        ...(currentSessionId && { id: { not: currentSessionId } }),\n      },\n    });\n\n    // Delete all sessions\n    const sessionIds = sessions.map((session) => session.id);\n    await this.sessionService.deleteSessions(userId, sessionIds);\n\n    return {\n      message: currentSessionId\n        ? 'Logged out from all other devices successfully'\n        : 'Logged out from all devices successfully',\n      sessionsRevoked: sessions.length,\n    };\n  }\n\n  // ===== VALIDATE TOKEN =====\n\n  async validateAccessToken(token: string) {\n    try {\n      const payload = this.jwtService.verify(token);\n\n      // Check if token is blacklisted\n      const isBlacklisted = await this.cacheService.get(`blacklist:${token}`);\n      if (isBlacklisted) {\n        throw new UnauthorizedException('Token has been revoked');\n      }\n\n      // Get user\n      const user = await this.prisma.user.findUnique({\n        where: { id: payload.sub },\n        select: {\n          id: true,\n          email: true,\n          username: true,\n          fullName: true,\n          role: true,\n          isEmailVerified: true,\n        },\n      });\n\n      if (!user) {\n        throw new UnauthorizedException('User not found');\n      }\n\n      if (!user.isEmailVerified) {\n        throw new UnauthorizedException('Email not verified');\n      }\n\n      return { user, payload };\n    } catch (error) {\n      if (error.name === 'TokenExpiredError') {\n        throw new UnauthorizedException('Access token expired');\n      }\n      if (error.name === 'JsonWebTokenError') {\n        throw new UnauthorizedException('Invalid access token');\n      }\n      throw error;\n    }\n  }\n\n  // ===== HELPER METHODS =====\n\n  private generateDeviceFingerprint(\n    ipAddress?: string,\n    userAgent?: string,\n  ): string {\n    const components = [\n      ipAddress || 'unknown-ip',\n      userAgent || 'unknown-agent',\n      Date.now().toString(),\n    ];\n\n    return Buffer.from(components.join('|')).toString('base64');\n  }\n\n  // ===== REVOKE TOKEN =====\n\n  async revokeToken(token: string, tokenType: 'access' | 'refresh' = 'access') {\n    if (tokenType === 'access') {\n      // Add to blacklist cache\n      const payload = this.jwtService.decode(token);\n      if (payload && payload.exp) {\n        const ttl = payload.exp - Math.floor(Date.now() / 1000);\n        if (ttl > 0) {\n          await this.cacheService.set(`blacklist:${token}`, true, ttl);\n        }\n      }\n    } else {\n      // Revoke refresh token\n      await this.tokenService.revokeRefreshToken(token);\n    }\n\n    return { message: 'Token revoked successfully' };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\repositories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\repositories\\session.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":59,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":61,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":62,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":62,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":69,"column":18,"nodeType":"Property","messageId":"anyAssignment","endLine":69,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":78,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":91,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":93,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":94,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":94,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":101,"column":18,"nodeType":"Property","messageId":"anyAssignment","endLine":101,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":174,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":176,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":177,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":177,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":181,"column":20,"nodeType":"Property","messageId":"anyAssignment","endLine":181,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":184,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":184,"endColumn":19}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport { JWT } from 'src/config/jwt.config';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class SessionService {\n  constructor(private prisma: PrismaService) {}\n\n  // ===== SESSION GENERATION =====\n\n  generateSessionId(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  generateRefreshToken(sessionId: string): string {\n    const payload = { sessionId, timestamp: Date.now() };\n    return Buffer.from(JSON.stringify(payload)).toString('base64');\n  }\n\n  // ===== SESSION CRUD =====\n\n  async createSession(\n    userId: string,\n    userAgent?: string,\n    ipAddress?: string,\n  ): Promise<string> {\n    const sessionId = this.generateSessionId();\n\n    // Calculate expiry date from JWT config\n    const expiresAt = new Date();\n    const expiryTime = JWT.REFRESH_EXPIRES_IN;\n\n    if (expiryTime.endsWith('d')) {\n      expiresAt.setDate(expiresAt.getDate() + parseInt(expiryTime));\n    } else if (expiryTime.endsWith('h')) {\n      expiresAt.setHours(expiresAt.getHours() + parseInt(expiryTime));\n    } else {\n      expiresAt.setDate(expiresAt.getDate() + 7);\n    }\n\n    await this.prisma.session.create({\n      data: {\n        sessionId,\n        userId,\n        expiresAt,\n        userAgent,\n        ipAddress,\n      },\n    });\n\n    return this.generateRefreshToken(sessionId);\n  }\n\n  async getSessionFromRefreshToken(\n    refreshToken: string,\n  ): Promise<{ sessionId: string; id: string }> {\n    try {\n      const tokenPayload = JSON.parse(\n        Buffer.from(refreshToken, 'base64').toString(),\n      );\n      const { sessionId } = tokenPayload;\n\n      if (!sessionId) {\n        throw new UnauthorizedException('Invalid refresh token format');\n      }\n\n      const session = await this.prisma.session.findUnique({\n        where: { sessionId },\n        select: { id: true, sessionId: true },\n      });\n\n      if (!session) {\n        throw new UnauthorizedException('Session not found');\n      }\n\n      return session;\n    } catch (error) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n\n  async verifyAndUpdateSession(\n    refreshToken: string,\n  ): Promise<{ userId: string; email: string }> {\n    if (!refreshToken) {\n      throw new UnauthorizedException('Refresh token is required');\n    }\n\n    try {\n      const tokenPayload = JSON.parse(\n        Buffer.from(refreshToken, 'base64').toString(),\n      );\n      const { sessionId } = tokenPayload;\n\n      if (!sessionId) {\n        throw new UnauthorizedException('Invalid refresh token format');\n      }\n\n      const session = await this.prisma.session.findUnique({\n        where: { sessionId },\n        include: { user: true },\n      });\n\n      if (!session) {\n        throw new UnauthorizedException(\n          'Session not found. Please log in again.',\n        );\n      }\n\n      if (session.isRevoked) {\n        throw new UnauthorizedException(\n          'Session has been revoked. Please log in again.',\n        );\n      }\n\n      if (session.expiresAt < new Date()) {\n        await this.deleteSession(session.sessionId);\n        throw new UnauthorizedException(\n          'Session has expired. Please log in again.',\n        );\n      }\n\n      // Update last used timestamp\n      await this.prisma.session.update({\n        where: { id: session.id },\n        data: { lastUsedAt: new Date() },\n      });\n\n      return {\n        userId: session.userId,\n        email: session.user.email,\n      };\n    } catch (error) {\n      if (error instanceof UnauthorizedException) {\n        throw error;\n      }\n      throw new UnauthorizedException(\n        'Invalid refresh token. Please log in again.',\n      );\n    }\n  }\n\n  async rotateRefreshToken(sessionId: string): Promise<string> {\n    const newRefreshToken = this.generateRefreshToken(sessionId);\n\n    const expiresAt = new Date();\n    const expiryTime = JWT.REFRESH_EXPIRES_IN;\n\n    if (expiryTime.endsWith('d')) {\n      expiresAt.setDate(expiresAt.getDate() + parseInt(expiryTime));\n    } else if (expiryTime.endsWith('h')) {\n      expiresAt.setHours(expiresAt.getHours() + parseInt(expiryTime));\n    } else {\n      expiresAt.setDate(expiresAt.getDate() + 7);\n    }\n\n    await this.prisma.session.update({\n      where: { sessionId },\n      data: {\n        lastUsedAt: new Date(),\n        expiresAt: expiresAt,\n      },\n    });\n\n    return newRefreshToken;\n  }\n\n  // ===== SESSION DELETION =====\n\n  async deleteSession(refreshTokenOrSessionId: string): Promise<void> {\n    try {\n      // Try to parse as refresh token first\n      const tokenPayload = JSON.parse(\n        Buffer.from(refreshTokenOrSessionId, 'base64').toString(),\n      );\n      const { sessionId } = tokenPayload;\n\n      if (sessionId) {\n        await this.prisma.session.deleteMany({\n          where: { sessionId, isRevoked: false },\n        });\n      }\n    } catch (error) {\n      // If parsing fails, treat as sessionId directly\n      await this.prisma.session.deleteMany({\n        where: { sessionId: refreshTokenOrSessionId, isRevoked: false },\n      });\n    }\n  }\n\n  async deleteAllUserSessions(userId: string): Promise<void> {\n    await this.prisma.session.deleteMany({\n      where: { userId, isRevoked: false },\n    });\n  }\n\n  async deleteSessions(userId: string, sessionIds: string[]) {\n    const deleteResult = await this.prisma.session.deleteMany({\n      where: {\n        userId,\n        sessionId: { in: sessionIds },\n        isRevoked: false,\n      },\n    });\n\n    return { revokedCount: deleteResult.count };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\repositories\\token.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BadRequestException' is defined but never used.","line":3,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedException' is defined but never used.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":24}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  BadRequestException,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { SessionService } from './session.repository';\n\n@Injectable()\nexport class TokenService {\n  constructor(\n    private jwtService: JwtService,\n    private sessionService: SessionService,\n  ) {}\n\n  // ===== ACCESS TOKEN =====\n\n  generateAccessToken(userId: string, email: string): string {\n    const payload = { sub: userId, email };\n    return this.jwtService.sign(payload);\n  }\n\n  // ===== TOKEN PAIR GENERATION =====\n\n  async createTokensForUser(\n    userId: string,\n    email: string,\n    userAgent?: string,\n    ipAddress?: string,\n  ): Promise<{ accessToken: string; refreshToken: string }> {\n    const accessToken = this.generateAccessToken(userId, email);\n    const refreshToken = await this.sessionService.createSession(\n      userId,\n      userAgent,\n      ipAddress,\n    );\n\n    return { accessToken, refreshToken };\n  }\n\n  // ===== TOKEN REFRESH (RTR) =====\n\n  async refreshAccessToken(refreshToken: string) {\n    // Verify current session and get user data\n    const tokenData =\n      await this.sessionService.verifyAndUpdateSession(refreshToken);\n\n    // Get current session info\n    const currentSession =\n      await this.sessionService.getSessionFromRefreshToken(refreshToken);\n\n    // Generate new access token\n    const accessToken = this.generateAccessToken(\n      tokenData.userId,\n      tokenData.email,\n    );\n\n    // Rotate refresh token within same session\n    const newRefreshToken = await this.sessionService.rotateRefreshToken(\n      currentSession.sessionId,\n    );\n\n    return {\n      accessToken,\n      refreshToken: newRefreshToken,\n      userId: tokenData.userId,\n      email: tokenData.email,\n    };\n  }\n\n  // ===== TOKEN REVOCATION =====\n\n  async revokeRefreshToken(refreshToken: string): Promise<void> {\n    await this.sessionService.deleteSession(refreshToken);\n  }\n\n  async revokeAllUserTokens(userId: string): Promise<void> {\n    await this.sessionService.deleteAllUserSessions(userId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\repositories\\user-management.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'crypto' is defined but never used.","line":8,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationException' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":70,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":70,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":121,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":121,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":123,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":130,"column":18,"nodeType":"Property","messageId":"anyAssignment","endLine":130,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":130,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":134,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":134,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":134,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":134,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .password on an `any` value.","line":151,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":151,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":156,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":156,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":170,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":170,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":176,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":262,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":262,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":264,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":264,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":271,"column":18,"nodeType":"Property","messageId":"anyAssignment","endLine":271,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":271,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":271,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":275,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":275,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":275,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":275,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":290,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":290,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":296,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":296,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":315,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":315,"endColumn":47},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'setEmailVerificationToken' has no 'await' expression.","line":377,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":377,"endColumn":34,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10681,10771],"text":"setEmailVerificationToken(\n    userId: string,\n    token: string,\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'setPasswordResetToken' has no 'await' expression.","line":401,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":401,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[11359,11466],"text":"setPasswordResetToken(\n    userId: string,\n    token: string,\n    expiresAt: Date,\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"Date\" of template literal expression.","line":408,"column":78,"nodeType":"Identifier","messageId":"invalidType","endLine":408,"endColumn":87},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'findUserByPasswordResetToken' has no 'await' expression.","line":412,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":412,"endColumn":37,"suggestions":[{"messageId":"removeAsync","fix":{"range":[11658,11733],"text":"findUserByPasswordResetToken(token: string): AuthUser | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'clearPasswordResetToken' has no 'await' expression.","line":418,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":418,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[11869,11929],"text":"clearPasswordResetToken(userId: string): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":435,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":435,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":435,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":435,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":436,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":436,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .email on an `any` value.","line":436,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":436,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":437,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":437,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .username on an `any` value.","line":437,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":437,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":438,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":438,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fullName on an `any` value.","line":438,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":438,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":439,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":439,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .passwordHash on an `any` value.","line":439,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":439,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":440,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":440,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .avatar on an `any` value.","line":440,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":440,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":441,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":441,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .role on an `any` value.","line":441,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":441,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":442,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":442,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isEmailVerified on an `any` value.","line":442,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":442,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":443,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":443,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .emailVerifiedAt on an `any` value.","line":443,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":443,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":444,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":444,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":444,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":444,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":445,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":445,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":445,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":445,"endColumn":32}],"suppressedMessages":[],"errorCount":47,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport { MailerService } from '../../mailer/mailer.service';\nimport { JwtService } from '@nestjs/jwt';\nimport { RegisterDto } from '../dto/register.dto';\nimport { mailQueue } from 'src/queues/mail.queue';\nimport * as bcrypt from 'bcrypt';\nimport * as crypto from 'crypto';\nimport { IUserRepository } from '../domain/repositories';\nimport {\n  AuthUser,\n  AuthUserCreationData,\n  AuthUserUpdateData,\n} from '../domain/entities';\nimport {\n  ErrorFactory,\n  DomainErrors,\n  ErrorUtils,\n  ValidationException,\n} from '../../../shared';\n\n@Injectable()\nexport class UserManagementService implements IUserRepository {\n  constructor(\n    private prisma: PrismaService,\n    private mailerService: MailerService,\n    private jwtService: JwtService,\n  ) {}\n\n  // ===== USER REGISTRATION =====\n\n  async registerUser(registerDto: RegisterDto) {\n    const { userName, email, fullName } = registerDto;\n\n    // Check existing user\n    const existingUser = await this.prisma.user.findFirst({\n      where: {\n        OR: [{ email }, ...(userName ? [{ username: userName }] : [])],\n      },\n    });\n\n    if (existingUser) {\n      if (existingUser.email === email) {\n        // If the email exists but is not verified, instruct user to verify\n        if (!existingUser.isEmailVerified) {\n          throw ErrorFactory.businessRule(\n            'Email already registered but not verified. Please verify your email or request a new verification email.',\n            'EMAIL_NOT_VERIFIED',\n          );\n        }\n        throw DomainErrors.userAlreadyExists(email);\n      }\n      if (userName && existingUser.username === userName) {\n        throw ErrorFactory.entityAlreadyExists('Username', userName);\n      }\n    }\n\n    // Create user WITHOUT password (will be set during email verification)\n    const newUser = await this.prisma.user.create({\n      data: {\n        fullName: fullName?.trim(),\n        username: userName as string,\n        email,\n        passwordHash: null, // No password initially\n        dateOfBirth: registerDto.dateOfBirth,\n        phoneNumber: registerDto.phoneNumber,\n        avatar: registerDto.avatar,\n        bio: registerDto.bio,\n        location: registerDto.location,\n        role: 'USER' as any,\n      },\n      select: {\n        id: true,\n        username: true,\n        email: true,\n        fullName: true,\n        avatar: true,\n        role: true,\n        dateOfBirth: true,\n        isEmailVerified: true,\n        emailVerifiedAt: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n\n    // Generate email verification token\n    const verificationToken = this.generateEmailToken(\n      newUser.id,\n      newUser.email,\n    );\n\n    // Send verification email (using queue)\n    await mailQueue.add('send-verification-email', {\n      email: newUser.email,\n      userName: newUser.username,\n      verificationLink: `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`,\n    });\n\n    return {\n      message:\n        'Registration successful. Please check your email for verification.',\n      user: newUser,\n    };\n  }\n\n  // ===== EMAIL VERIFICATION =====\n\n  generateEmailToken(userId: string, email: string): string {\n    const payload = {\n      sub: userId,\n      email,\n      type: 'email-verification',\n      timestamp: Date.now(),\n    };\n    return this.jwtService.sign(payload, { expiresIn: '24h' });\n  }\n\n  async verifyEmail(token: string, password?: string) {\n    try {\n      const payload = this.jwtService.verify(token);\n\n      if (payload.type !== 'email-verification') {\n        throw ErrorFactory.validation('Invalid token type', {\n          token: ['Token is not a valid email verification token'],\n        });\n      }\n\n      const user = await this.prisma.user.findUnique({\n        where: { id: payload.sub },\n      });\n\n      if (!user) {\n        throw DomainErrors.userNotFound(payload.sub);\n      }\n\n      if (user.isEmailVerified) {\n        return {\n          message: 'Email has already been verified. You can now log in.',\n        };\n      }\n\n      // Update verification status\n      const updateData: any = {\n        isEmailVerified: true,\n        emailVerifiedAt: new Date(),\n      };\n\n      // If password provided during verification, hash and update it\n      if (password) {\n        updateData.password = await bcrypt.hash(password, 10);\n      }\n\n      await this.prisma.user.update({\n        where: { id: user.id },\n        data: updateData,\n      });\n\n      return {\n        message: 'Email verified successfully. You can now log in.',\n        user: {\n          id: user.id,\n          email: user.email,\n          userName: user.username,\n          fullName: user.fullName,\n          isEmailVerified: true,\n        },\n      };\n    } catch (error) {\n      if (error.name === 'TokenExpiredError') {\n        throw ErrorFactory.validation(\n          'Verification token has expired. Please request a new one.',\n          { token: ['Token has expired'] },\n        );\n      }\n      if (error.name === 'JsonWebTokenError') {\n        throw ErrorFactory.validation('Invalid verification token', {\n          token: ['Token is invalid'],\n        });\n      }\n      throw error;\n    }\n  }\n\n  async resendVerificationEmail(email: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      // Don't reveal if user exists for security\n      return {\n        message: 'If the email exists, a verification email has been sent.',\n      };\n    }\n\n    if (user.isEmailVerified) {\n      throw ErrorFactory.businessRule(\n        'Email is already verified',\n        'EMAIL_ALREADY_VERIFIED',\n      );\n    }\n\n    const verificationToken = this.generateEmailToken(user.id, user.email);\n\n    await mailQueue.add('send-verification-email', {\n      email: user.email,\n      userName: user.username,\n      verificationLink: `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`,\n    });\n\n    return { message: 'Verification email sent successfully' };\n  }\n\n  // ===== PASSWORD RESET =====\n\n  async forgotPassword(email: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      // Don't reveal if user exists\n      return {\n        message: 'If the email exists, a password reset link has been sent.',\n      };\n    }\n\n    const resetToken = this.jwtService.sign(\n      {\n        sub: user.id,\n        email: user.email,\n        type: 'password-reset',\n        timestamp: Date.now(),\n      },\n      { expiresIn: '1h' },\n    );\n\n    await mailQueue.add('send-password-reset-email', {\n      email: user.email,\n      userName: user.username,\n      resetLink: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`,\n    });\n\n    return { message: 'Password reset link sent successfully' };\n  }\n\n  async resetPassword(\n    token: string,\n    newPassword: string,\n    confirmPassword: string,\n  ) {\n    if (newPassword !== confirmPassword) {\n      throw ErrorFactory.validation('Passwords do not match', {\n        confirmPassword: ['Must match new password'],\n      });\n    }\n\n    ErrorUtils.validateStringLength(newPassword, 6, 255, 'password');\n\n    try {\n      const payload = this.jwtService.verify(token);\n\n      if (payload.type !== 'password-reset') {\n        throw ErrorFactory.validation('Invalid token type', {\n          token: ['Token is not a valid password reset token'],\n        });\n      }\n\n      const user = await this.prisma.user.findUnique({\n        where: { id: payload.sub },\n      });\n\n      if (!user) {\n        throw DomainErrors.userNotFound(payload.sub);\n      }\n\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n      await this.prisma.user.update({\n        where: { id: user.id },\n        data: { passwordHash: hashedPassword },\n      });\n\n      return {\n        message:\n          'Password has been reset successfully. Please log in with your new password.',\n      };\n    } catch (error) {\n      if (error.name === 'TokenExpiredError') {\n        throw ErrorFactory.validation(\n          'Reset token has expired. Please request a new one.',\n          { token: ['Token has expired'] },\n        );\n      }\n      if (error.name === 'JsonWebTokenError') {\n        throw ErrorFactory.validation('Invalid reset token', {\n          token: ['Token is invalid'],\n        });\n      }\n      throw error;\n    }\n  }\n\n  // ===== IMPLEMENT IUserRepository INTERFACE =====\n\n  async createUser(userData: AuthUserCreationData): Promise<AuthUser> {\n    const user = await this.prisma.user.create({\n      data: {\n        username: userData.userName,\n        email: userData.email,\n        fullName: userData.fullName,\n        passwordHash: userData.password,\n        avatar: userData.avatar,\n        role: (userData.role as any) || 'USER',\n        isEmailVerified: userData.isEmailVerified || false,\n        dateOfBirth: new Date(), // Default for now\n      },\n    });\n\n    return this.mapPrismaUserToAuthUser(user);\n  }\n\n  async findUserById(id: string): Promise<AuthUser | null> {\n    const user = await this.prisma.user.findUnique({ where: { id } });\n    return user ? this.mapPrismaUserToAuthUser(user) : null;\n  }\n\n  async findUserByEmail(email: string): Promise<AuthUser | null> {\n    const user = await this.prisma.user.findUnique({ where: { email } });\n    return user ? this.mapPrismaUserToAuthUser(user) : null;\n  }\n\n  async findUserByUsername(username: string): Promise<AuthUser | null> {\n    const user = await this.prisma.user.findUnique({ where: { username } });\n    return user ? this.mapPrismaUserToAuthUser(user) : null;\n  }\n\n  async findUserByEmailOrUsername(\n    identifier: string,\n  ): Promise<AuthUser | null> {\n    const user = await this.prisma.user.findFirst({\n      where: {\n        OR: [{ email: identifier }, { username: identifier }],\n      },\n    });\n    return user ? this.mapPrismaUserToAuthUser(user) : null;\n  }\n\n  async updateUser(\n    id: string,\n    userData: AuthUserUpdateData,\n  ): Promise<AuthUser> {\n    const user = await this.prisma.user.update({\n      where: { id },\n      data: {\n        username: userData.userName,\n        email: userData.email,\n        fullName: userData.fullName,\n        passwordHash: userData.password,\n        avatar: userData.avatar,\n        isEmailVerified: userData.isEmailVerified,\n        emailVerifiedAt: userData.emailVerifiedAt,\n      },\n    });\n\n    return this.mapPrismaUserToAuthUser(user);\n  }\n\n  async updateUserPassword(id: string, hashedPassword: string): Promise<void> {\n    await this.prisma.user.update({\n      where: { id },\n      data: { passwordHash: hashedPassword },\n    });\n  }\n\n  async setEmailVerificationToken(\n    userId: string,\n    token: string,\n  ): Promise<void> {\n    // TODO: Add emailVerificationToken field to schema or use Redis\n    console.log(\n      `Setting email verification token for user ${userId}: ${token}`,\n    );\n  }\n\n  async verifyEmailByToken(token: string): Promise<AuthUser | null> {\n    // This delegates to existing verifyEmail method\n    try {\n      const result = await this.verifyEmail(token);\n      if (result.user) {\n        const user = await this.findUserById(result.user.id);\n        return user;\n      }\n    } catch (error) {\n      console.error('Error verifying email by token:', error);\n    }\n    return null;\n  }\n\n  async setPasswordResetToken(\n    userId: string,\n    token: string,\n    expiresAt: Date,\n  ): Promise<void> {\n    // TODO: Add password reset token fields to schema or use Redis\n    console.log(\n      `Setting password reset token for user ${userId}: ${token}, expires: ${expiresAt}`,\n    );\n  }\n\n  async findUserByPasswordResetToken(token: string): Promise<AuthUser | null> {\n    // TODO: Implement with token storage\n    console.log(`Finding user by password reset token: ${token}`);\n    return null;\n  }\n\n  async clearPasswordResetToken(userId: string): Promise<void> {\n    // TODO: Implement with token storage\n    console.log(`Clearing password reset token for user: ${userId}`);\n  }\n\n  async existsByEmail(email: string): Promise<boolean> {\n    const count = await this.prisma.user.count({ where: { email } });\n    return count > 0;\n  }\n\n  async existsByUsername(username: string): Promise<boolean> {\n    const count = await this.prisma.user.count({ where: { username } });\n    return count > 0;\n  }\n\n  private mapPrismaUserToAuthUser(user: any): AuthUser {\n    return {\n      id: user.id,\n      email: user.email,\n      userName: user.username, // Map from Prisma username to entity userName\n      fullName: user.fullName,\n      password: user.passwordHash, // Map from Prisma passwordHash to entity password\n      avatar: user.avatar,\n      role: user.role,\n      isEmailVerified: user.isEmailVerified,\n      emailVerifiedAt: user.emailVerifiedAt,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\strategies\\Jwt.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'request.headers['x-client-type'] ||\n            request.query.client ||\n            ''' may use Object's default stringification format ('[object Object]') when stringified.","line":18,"column":13,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":20,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":26,"column":13,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":26,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ['access_token'] on an `any` value.","line":26,"column":36,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":26,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":38,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":38,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":38,"column":66,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":38,"endColumn":69}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from '../auth.service';\nimport { JWT } from 'src/config/jwt.config';\nimport { Request } from 'express';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super({\n      jwtFromRequest: ExtractJwt.fromExtractors([\n        // First try Bearer token from header (for mobile clients)\n        ExtractJwt.fromAuthHeaderAsBearerToken(),\n        // Then try cookie (for web clients)\n        (request: Request) => {\n          const clientType = (\n            request.headers['x-client-type'] ||\n            request.query.client ||\n            ''\n          ).toString();\n          const isWeb = clientType.toLowerCase() === 'web';\n\n          // Only extract from cookie for web clients\n          if (isWeb && request.cookies) {\n            return request.cookies['access_token'];\n          }\n          return null;\n        },\n      ]),\n      ignoreExpiration: false,\n      secretOrKey: JWT.SECRET as string,\n      passReqToCallback: false,\n    });\n  }\n\n  async validate(payload: any) {\n    const user = await this.authService.validateUserById(payload.sub);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return {\n      id: user.id,\n      email: user.email,\n      userName: user.username,\n      role: user.role,\n      fullName: user.fullName,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\strategies\\google.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":36,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":36,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":38,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":38,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":39,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":39,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on an `any` value.","line":39,"column":23,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":39,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .givenName on an `any` value.","line":40,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .familyName on an `any` value.","line":40,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":41,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":41,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .givenName on an `any` value.","line":41,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":41,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":42,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":42,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .familyName on an `any` value.","line":42,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":42,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":43,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":43,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on an `any` value.","line":43,"column":32,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":43,"endColumn":33}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Strategy, VerifyCallback } from 'passport-google-oauth20';\nimport { AuthService } from '../auth.service';\nimport { GOOGLE_CONFIG } from 'src/config/google.config';\nimport { URLS } from '../../../shared/constants/urls.constant';\n\n@Injectable()\nexport class GoogleStrategy extends PassportStrategy(Strategy, 'google') {\n  constructor(private authService: AuthService) {\n    const clientID = GOOGLE_CONFIG.clientID;\n    const clientSecret = GOOGLE_CONFIG.clientSecret;\n    const callbackURL = URLS.GOOGLE_CALLBACK;\n\n    if (!clientID || !clientSecret) {\n      console.warn(\n        'Google OAuth not configured. Please set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET environment variables.',\n      );\n    }\n\n    super({\n      clientID: clientID || 'dummy-client-id',\n      clientSecret: clientSecret || 'dummy-client-secret',\n      callbackURL: callbackURL || 'http://localhost:3107/auth/google/callback',\n      scope: ['email', 'profile'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<any> {\n    try {\n      const { id, name, emails, photos } = profile;\n      const user = {\n        googleId: id,\n        email: emails[0].value,\n        fullName: `${name.givenName} ${name.familyName}`,\n        firstName: name.givenName,\n        lastName: name.familyName,\n        profilePicture: photos[0].value,\n        accessToken,\n      };\n\n      const result = await this.authService.googleLogin(user);\n      done(null, result);\n    } catch (error) {\n      done(error, false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.decorators.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object`.","line":89,"column":42,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":89,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":91,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":91,"endColumn":44},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":93,"column":24,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":93,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2604,2610],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":95,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":95,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":95,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":95,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .apply on an `any` value.","line":95,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object`.","line":124,"column":44,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":124,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":126,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":126,"endColumn":44},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":128,"column":24,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":128,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3485,3491],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":130,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":130,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":130,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":130,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .apply on an `any` value.","line":130,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object`.","line":159,"column":45,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":159,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":161,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":161,"endColumn":44},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":163,"column":24,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":163,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4365,4371],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":165,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":165,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":165,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":165,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .apply on an `any` value.","line":165,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":165,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object`.","line":191,"column":43,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":191,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":193,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":193,"endColumn":44},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":195,"column":24,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":195,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5113,5119],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":197,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":197,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":197,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":197,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .apply on an `any` value.","line":197,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":197,"endColumn":34}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SetMetadata } from '@nestjs/common';\nimport { CacheConfig, CacheConfigName } from './cache.interfaces';\n\n// Metadata keys for decorators\nexport const CACHEABLE_KEY = 'cacheable';\nexport const CACHE_EVICT_KEY = 'cache_evict';\nexport const CACHE_UPDATE_KEY = 'cache_update';\nexport const CACHE_WARM_KEY = 'cache_warm';\n\n// Decorator metadata interfaces\nexport interface CacheableMetadata {\n  keyTemplate: string;\n  config: CacheConfig | CacheConfigName;\n  condition?: string; // Optional condition function\n}\n\nexport interface CacheEvictMetadata {\n  keys: string[]; // Array of key patterns to evict\n  allEntries?: boolean; // If true, clear all cache\n  beforeInvocation?: boolean; // If true, evict before method execution\n}\n\nexport interface CacheUpdateMetadata {\n  keyTemplate: string;\n  evictPatterns?: string[]; // Patterns to evict after update\n  config: CacheConfig | CacheConfigName;\n}\n\nexport interface CacheWarmMetadata {\n  keyTemplate: string;\n  config: CacheConfig | CacheConfigName;\n}\n\n// Cache key template interpolation utility\nexport function interpolateTemplate(\n  template: string,\n  args: any[],\n  paramNames: string[],\n): string {\n  let result = template;\n\n  // Replace parameter placeholders like {{id}}, {{userId}}\n  paramNames.forEach((paramName, index) => {\n    const placeholder = `{{${paramName}}}`;\n    if (result.includes(placeholder) && args[index] !== undefined) {\n      result = result.replace(\n        new RegExp(placeholder.replace(/[{}]/g, '\\\\$&'), 'g'),\n        String(args[index]),\n      );\n    }\n  });\n\n  // Replace numeric placeholders like {{0}}, {{1}}\n  args.forEach((arg, index) => {\n    const placeholder = `{{${index}}}`;\n    if (result.includes(placeholder)) {\n      result = result.replace(\n        new RegExp(placeholder.replace(/[{}]/g, '\\\\$&'), 'g'),\n        String(arg),\n      );\n    }\n  });\n\n  return result;\n}\n\n/**\n * Cacheable decorator - automatically caches method results\n * @param keyTemplate Template for cache key (e.g., \"user:{{id}}\" or \"post:{{0}}\")\n * @param config Cache configuration name or object\n * @param condition Optional condition to check before caching\n */\nexport function Cacheable(\n  keyTemplate: string,\n  config: CacheConfig | CacheConfigName,\n  condition?: string,\n) {\n  return function (\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const metadata: CacheableMetadata = {\n      keyTemplate,\n      config,\n      condition,\n    };\n\n    SetMetadata(CACHEABLE_KEY, metadata)(target, propertyName, descriptor);\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      // This will be handled by the interceptor\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * CacheEvict decorator - automatically removes cache entries\n * @param keys Array of key patterns to evict\n * @param allEntries If true, clear all cache entries\n * @param beforeInvocation If true, evict before method execution\n */\nexport function CacheEvict(\n  keys: string[],\n  allEntries: boolean = false,\n  beforeInvocation: boolean = false,\n) {\n  return function (\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const metadata: CacheEvictMetadata = {\n      keys,\n      allEntries,\n      beforeInvocation,\n    };\n\n    SetMetadata(CACHE_EVICT_KEY, metadata)(target, propertyName, descriptor);\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      // This will be handled by the interceptor\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * CacheUpdate decorator - caches result and evicts related entries\n * @param keyTemplate Template for cache key\n * @param evictPatterns Array of patterns to evict after update\n * @param config Cache configuration\n */\nexport function CacheUpdate(\n  keyTemplate: string,\n  evictPatterns: string[] = [],\n  config: CacheConfig | CacheConfigName,\n) {\n  return function (\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const metadata: CacheUpdateMetadata = {\n      keyTemplate,\n      evictPatterns,\n      config,\n    };\n\n    SetMetadata(CACHE_UPDATE_KEY, metadata)(target, propertyName, descriptor);\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      // This will be handled by the interceptor\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * CacheWarm decorator - preloads cache with method result\n * @param keyTemplate Template for cache key\n * @param config Cache configuration\n */\nexport function CacheWarm(\n  keyTemplate: string,\n  config: CacheConfig | CacheConfigName,\n) {\n  return function (\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const metadata: CacheWarmMetadata = {\n      keyTemplate,\n      config,\n    };\n\n    SetMetadata(CACHE_WARM_KEY, metadata)(target, propertyName, descriptor);\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      // This will be handled by the interceptor\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.interceptor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'target' is assigned a value but never used.","line":38,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":17},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":76,"column":11,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":103,"endColumn":8},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":135,"column":13,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":140,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":236,"column":35,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":236,"endColumn":43}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NestInterceptor,\n  ExecutionContext,\n  CallHandler,\n  Logger,\n} from '@nestjs/common';\nimport { Observable, of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport { Reflector } from '@nestjs/core';\nimport { RedisCacheService } from './cache.service';\nimport {\n  CACHEABLE_KEY,\n  CACHE_EVICT_KEY,\n  CACHE_UPDATE_KEY,\n  CACHE_WARM_KEY,\n  CacheableMetadata,\n  CacheEvictMetadata,\n  CacheUpdateMetadata,\n  CacheWarmMetadata,\n  interpolateTemplate,\n} from './cache.decorators';\n\n@Injectable()\nexport class CacheInterceptor implements NestInterceptor {\n  private readonly logger = new Logger(CacheInterceptor.name);\n\n  constructor(\n    private readonly reflector: Reflector,\n    private readonly cacheService: RedisCacheService,\n  ) {}\n\n  async intercept(\n    context: ExecutionContext,\n    next: CallHandler,\n  ): Promise<Observable<any>> {\n    const handler = context.getHandler();\n    const target = context.getClass();\n\n    // Get method parameter names for template interpolation\n    const paramNames = this.getParameterNames(handler);\n    const args = context.getArgs();\n\n    // Check for cache decorators\n    const cacheableMetadata = this.reflector.get<CacheableMetadata>(\n      CACHEABLE_KEY,\n      handler,\n    );\n    const cacheEvictMetadata = this.reflector.get<CacheEvictMetadata>(\n      CACHE_EVICT_KEY,\n      handler,\n    );\n    const cacheUpdateMetadata = this.reflector.get<CacheUpdateMetadata>(\n      CACHE_UPDATE_KEY,\n      handler,\n    );\n    const cacheWarmMetadata = this.reflector.get<CacheWarmMetadata>(\n      CACHE_WARM_KEY,\n      handler,\n    );\n\n    // Handle cache eviction before method execution\n    if (cacheEvictMetadata?.beforeInvocation) {\n      await this.handleCacheEviction(cacheEvictMetadata, args, paramNames);\n    }\n\n    // Handle cacheable operations\n    if (cacheableMetadata) {\n      return this.handleCacheable(cacheableMetadata, args, paramNames, next);\n    }\n\n    // Execute the method\n    const result = next.handle();\n\n    return result.pipe(\n      tap(async (methodResult) => {\n        // Handle cache operations after method execution\n\n        // Cache eviction after execution\n        if (cacheEvictMetadata && !cacheEvictMetadata.beforeInvocation) {\n          await this.handleCacheEviction(cacheEvictMetadata, args, paramNames);\n        }\n\n        // Cache update operations\n        if (cacheUpdateMetadata) {\n          await this.handleCacheUpdate(\n            cacheUpdateMetadata,\n            args,\n            paramNames,\n            methodResult,\n          );\n        }\n\n        // Cache warm operations\n        if (cacheWarmMetadata) {\n          await this.handleCacheWarm(\n            cacheWarmMetadata,\n            args,\n            paramNames,\n            methodResult,\n          );\n        }\n      }),\n    );\n  }\n\n  private async handleCacheable(\n    metadata: CacheableMetadata,\n    args: any[],\n    paramNames: string[],\n    next: CallHandler,\n  ): Promise<Observable<any>> {\n    try {\n      const cacheKey = interpolateTemplate(\n        metadata.keyTemplate,\n        args,\n        paramNames,\n      );\n\n      // Try to get from cache first\n      const cachedResult = await this.cacheService.get(\n        cacheKey,\n        metadata.config,\n      );\n\n      if (cachedResult !== null) {\n        this.logger.debug(`Cache hit for key: ${cacheKey}`);\n        return of(cachedResult);\n      }\n\n      // Cache miss - execute method and cache result\n      this.logger.debug(`Cache miss for key: ${cacheKey}`);\n\n      return next.handle().pipe(\n        tap(async (result) => {\n          if (result !== null && result !== undefined) {\n            await this.cacheService.set(cacheKey, result, metadata.config);\n            this.logger.debug(`Cached result for key: ${cacheKey}`);\n          }\n        }),\n      );\n    } catch (error) {\n      this.logger.error('Error in cacheable operation', error);\n      return next.handle();\n    }\n  }\n\n  private async handleCacheEviction(\n    metadata: CacheEvictMetadata,\n    args: any[],\n    paramNames: string[],\n  ): Promise<void> {\n    try {\n      if (metadata.allEntries) {\n        await this.cacheService.clear();\n        this.logger.debug('Cleared all cache entries');\n        return;\n      }\n\n      for (const keyPattern of metadata.keys) {\n        const resolvedPattern = interpolateTemplate(\n          keyPattern,\n          args,\n          paramNames,\n        );\n\n        if (resolvedPattern.includes('*')) {\n          // Pattern-based eviction\n          await this.cacheService.invalidateByPattern(resolvedPattern);\n          this.logger.debug(`Evicted cache pattern: ${resolvedPattern}`);\n        } else {\n          // Single key eviction\n          await this.cacheService.del(resolvedPattern);\n          this.logger.debug(`Evicted cache key: ${resolvedPattern}`);\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error in cache eviction', error);\n    }\n  }\n\n  private async handleCacheUpdate(\n    metadata: CacheUpdateMetadata,\n    args: any[],\n    paramNames: string[],\n    result: any,\n  ): Promise<void> {\n    try {\n      // Cache the updated result\n      const cacheKey = interpolateTemplate(\n        metadata.keyTemplate,\n        args,\n        paramNames,\n      );\n      await this.cacheService.set(cacheKey, result, metadata.config);\n      this.logger.debug(`Updated cache for key: ${cacheKey}`);\n\n      // Evict related cache entries\n      if (metadata.evictPatterns) {\n        for (const pattern of metadata.evictPatterns) {\n          const resolvedPattern = interpolateTemplate(\n            pattern,\n            args,\n            paramNames,\n          );\n          await this.cacheService.invalidateByPattern(resolvedPattern);\n          this.logger.debug(\n            `Evicted related cache pattern: ${resolvedPattern}`,\n          );\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error in cache update', error);\n    }\n  }\n\n  private async handleCacheWarm(\n    metadata: CacheWarmMetadata,\n    args: any[],\n    paramNames: string[],\n    result: any,\n  ): Promise<void> {\n    try {\n      const cacheKey = interpolateTemplate(\n        metadata.keyTemplate,\n        args,\n        paramNames,\n      );\n      await this.cacheService.set(cacheKey, result, metadata.config);\n      this.logger.debug(`Warmed cache for key: ${cacheKey}`);\n    } catch (error) {\n      this.logger.error('Error in cache warming', error);\n    }\n  }\n\n  private getParameterNames(func: Function): string[] {\n    // Extract parameter names from function signature\n    const funcStr = func.toString();\n    const match = funcStr.match(/\\(([^)]*)\\)/);\n\n    if (!match || !match[1].trim()) {\n      return [];\n    }\n\n    return match[1]\n      .split(',')\n      .map((param) => param.trim().split(/[\\s=]/)[0])\n      .filter((name) => name && !name.startsWith('...'));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.interfaces.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Injectable' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\n\n// Cache configuration interfaces\nexport interface CacheConfig {\n  ttl?: number; // Time to live in seconds\n  prefix?: string; // Key prefix\n  tags?: string[]; // Tags for invalidation\n  serialize?: boolean; // Whether to serialize data\n  compress?: boolean; // Whether to compress data\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  hitRate: number;\n  totalOperations: number;\n  lastReset: Date;\n}\n\nexport enum CacheEvent {\n  USER_CREATED = 'user.created',\n  USER_UPDATED = 'user.updated',\n  USER_DELETED = 'user.deleted',\n  POST_CREATED = 'post.created',\n  POST_UPDATED = 'post.updated',\n  POST_DELETED = 'post.deleted',\n  FOLLOW_CREATED = 'follow.created',\n  FOLLOW_DELETED = 'follow.deleted',\n}\n\n// Predefined cache configurations for common use cases\nexport const DEFAULT_CACHE_CONFIGS = {\n  USER_PROFILE: {\n    ttl: 1800, // 30 minutes\n    prefix: 'user:profile',\n    tags: ['user'],\n    serialize: true,\n  } as CacheConfig,\n\n  POST: {\n    ttl: 600, // 10 minutes\n    prefix: 'post',\n    tags: ['post'],\n    serialize: true,\n  } as CacheConfig,\n\n  USER_FEED: {\n    ttl: 300, // 5 minutes\n    prefix: 'user:feed',\n    tags: ['user', 'feed'],\n    serialize: true,\n    compress: true, // Feeds can be large\n  } as CacheConfig,\n\n  POST_LIST: {\n    ttl: 600, // 10 minutes\n    prefix: 'post:list',\n    tags: ['post', 'list'],\n    serialize: true,\n    compress: true,\n  } as CacheConfig,\n\n  USER_LIST: {\n    ttl: 900, // 15 minutes\n    prefix: 'user:list',\n    tags: ['user', 'list'],\n    serialize: true,\n  } as CacheConfig,\n\n  SEARCH_RESULTS: {\n    ttl: 600, // 10 minutes\n    prefix: 'search',\n    tags: ['search'],\n    serialize: true,\n    compress: true,\n  } as CacheConfig,\n\n  AUTH_STATE: {\n    ttl: 300, // 5 minutes\n    prefix: 'auth:state',\n    tags: ['auth'],\n    serialize: true,\n  } as CacheConfig,\n\n  NOTIFICATION_LIST: {\n    ttl: 180, // 3 minutes\n    prefix: 'notifications',\n    tags: ['notification'],\n    serialize: true,\n  } as CacheConfig,\n} as const;\n\nexport type CacheConfigName = keyof typeof DEFAULT_CACHE_CONFIGS;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.module.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'useFactory' has no 'await' expression.","line":16,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":16,"endColumn":25,"suggestions":[{"messageId":"removeAsync","fix":{"range":[552,558],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CacheModule } from '@nestjs/cache-manager';\nimport { Module } from '@nestjs/common';\nimport { APP_INTERCEPTOR } from '@nestjs/core';\nimport { RedisCacheService } from './cache.service';\nimport { CacheUtils } from './cache.utils';\nimport { CacheInterceptor } from './cache.interceptor';\nimport Keyv from 'keyv';\nimport { CacheableMemory } from 'cacheable';\nimport { createKeyv } from '@keyv/redis';\nimport { REDIS } from 'src/config/redis.config';\n\n@Module({\n  imports: [\n    CacheModule.registerAsync({\n      isGlobal: true,\n      useFactory: async () => {\n        return {\n          stores: [\n            new Keyv({\n              store: new CacheableMemory({ ttl: 60000, lruSize: 5000 }),\n            }),\n            createKeyv(REDIS.URL),\n          ],\n        };\n      },\n    }),\n  ],\n  providers: [\n    RedisCacheService,\n    CacheUtils,\n    {\n      provide: APP_INTERCEPTOR,\n      useClass: CacheInterceptor,\n    },\n  ],\n  exports: [RedisCacheService, CacheUtils],\n})\nexport class RedisCacheModule {}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":32,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":32,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stores on an `any` value.","line":32,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":32,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":33,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":34,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":34,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":34,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on an `any` value.","line":34,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":34,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [1] on an `any` value.","line":34,"column":74,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":34,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":35,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":35,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":35,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":35,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getClient on an `any` value.","line":35,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":35,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [name] on an `any` value.","line":45,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":52,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":52,"endColumn":21},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'testRedisConnection' has no 'await' expression.","line":62,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":62,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1708,1750],"text":"testRedisConnection(): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":64,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":64,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .constructor on an `any` value.","line":66,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":66,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [name] on an `any` value.","line":73,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":47},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"\"USER_PROFILE\" | \"POST\" | \"USER_FEED\" | \"POST_LIST\" | \"USER_LIST\" | \"SEARCH_RESULTS\" | \"AUTH_STATE\" | \"NOTIFICATION_LIST\" is overridden by string in this union type.","line":83,"column":25,"nodeType":"TSTypeReference","messageId":"literalOverridden","endLine":83,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":98,"column":28,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":98,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":127,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":127,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":257,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":257,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":268,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":274,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":268,"column":30,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":268,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scan on an `any` value.","line":268,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":268,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":275,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":275,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on an `any` value.","line":275,"column":25,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":275,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe spread of an `any` type.","line":276,"column":19,"nodeType":"SpreadElement","messageId":"unsafeSpread","endLine":276,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [1] on an `any` value.","line":276,"column":29,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":276,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":280,"column":15,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":280,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .del on an `any` value.","line":280,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":280,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":385,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":385,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zadd on an `any` value.","line":389,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":389,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":390,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":390,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":390,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":390,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zadd on an `any` value.","line":390,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":390,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zAdd on an `any` value.","line":391,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":391,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":392,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":392,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":392,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":392,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zAdd on an `any` value.","line":392,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":392,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZADD on an `any` value.","line":393,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":393,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":394,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":394,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":394,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":394,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZADD on an `any` value.","line":394,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":394,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":411,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":411,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrevrangebyscore on an `any` value.","line":417,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":417,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":418,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":426,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":418,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":418,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrevrangebyscore on an `any` value.","line":418,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":418,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRevRangeWithScores on an `any` value.","line":427,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":427,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":428,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":428,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":428,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":428,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRevRangeWithScores on an `any` value.","line":428,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":428,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREVRANGE on an `any` value.","line":429,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":429,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":430,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":430,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":430,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":430,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREVRANGE on an `any` value.","line":430,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":430,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrevrange on an `any` value.","line":431,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":431,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":432,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":432,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":432,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":432,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrevrange on an `any` value.","line":432,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":432,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":449,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":449,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .value on an `any` value.","line":449,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":449,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":450,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":450,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .score on an `any` value.","line":450,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":450,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":457,"column":15,"nodeType":"Property","messageId":"anyAssignment","endLine":457,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":458,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":458,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":474,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":474,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zcard on an `any` value.","line":478,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":478,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":479,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":479,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":479,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":479,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zcard on an `any` value.","line":479,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":479,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zCard on an `any` value.","line":480,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":480,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":481,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":481,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":481,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":481,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zCard on an `any` value.","line":481,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":481,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZCARD on an `any` value.","line":482,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":482,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":483,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":483,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":483,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":483,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZCARD on an `any` value.","line":483,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":483,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":500,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":500,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zremrangebyrank on an `any` value.","line":504,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":504,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":505,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":505,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":505,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":505,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zremrangebyrank on an `any` value.","line":505,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":505,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRemRangeByRank on an `any` value.","line":506,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":506,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":507,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":507,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":507,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":507,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRemRangeByRank on an `any` value.","line":507,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":507,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREMRANGEBYRANK on an `any` value.","line":508,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":508,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":509,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":509,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":509,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":509,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREMRANGEBYRANK on an `any` value.","line":509,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":509,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":524,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":524,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrem on an `any` value.","line":528,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":528,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":529,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":529,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":529,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":529,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zrem on an `any` value.","line":529,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":529,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRem on an `any` value.","line":530,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":530,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":531,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":531,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":531,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":531,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zRem on an `any` value.","line":531,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":531,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREM on an `any` value.","line":532,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":532,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":533,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":533,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":533,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":533,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZREM on an `any` value.","line":533,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":533,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":546,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":546,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zscore on an `any` value.","line":550,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":550,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":551,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":551,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":551,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":551,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zscore on an `any` value.","line":551,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":551,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zScore on an `any` value.","line":552,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":552,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":553,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":553,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":553,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":553,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .zScore on an `any` value.","line":553,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":553,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZSCORE on an `any` value.","line":554,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":554,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":555,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":555,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":555,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":555,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ZSCORE on an `any` value.","line":555,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":555,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":570,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":570,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .expire on an `any` value.","line":574,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":574,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":575,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":575,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":575,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":575,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .expire on an `any` value.","line":575,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":575,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .EXPIRE on an `any` value.","line":576,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":576,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":577,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":577,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":577,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":577,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .EXPIRE on an `any` value.","line":577,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":577,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .pexpire on an `any` value.","line":578,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":578,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":579,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":579,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":579,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":579,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .pexpire on an `any` value.","line":579,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":579,"endColumn":36}],"suppressedMessages":[],"errorCount":128,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Inject, Injectable, Logger } from '@nestjs/common';\nimport { Cache } from 'cache-manager';\nimport * as zlib from 'zlib';\nimport { promisify } from 'util';\nimport {\n  CacheConfig,\n  CacheStats,\n  CacheEvent,\n  DEFAULT_CACHE_CONFIGS,\n  CacheConfigName,\n} from './cache.interfaces';\n\nconst gzip = promisify(zlib.gzip);\nconst gunzip = promisify(zlib.gunzip);\n\n@Injectable()\nexport class RedisCacheService {\n  private readonly logger = new Logger(RedisCacheService.name);\n  private stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    hitRate: 0,\n    totalOperations: 0,\n    lastReset: new Date(),\n  };\n\n  constructor(@Inject(CACHE_MANAGER) private readonly cacheManager: Cache) {}\n\n  private getRedisClient() {\n    try {\n      const stores = (this.cacheManager as any).stores;\n      const redisStore =\n        stores?.find((store: any) => store.name === 'redis') || stores?.[1];\n      const client = redisStore?.getClient?.() || redisStore;\n\n      // Debug: log available methods (only once)\n      if (client && !this.loggedMethods) {\n        this.loggedMethods = true;\n        const methods = Object.getOwnPropertyNames(\n          Object.getPrototypeOf(client),\n        )\n          .filter(\n            (name) =>\n              typeof client[name] === 'function' &&\n              name.toLowerCase().includes('z'),\n          )\n          .sort();\n        this.logger.debug('Available Redis ZSET methods:', methods);\n      }\n\n      return client;\n    } catch (err) {\n      this.logger.error('Error accessing Redis client', err);\n      return null;\n    }\n  }\n\n  private loggedMethods = false;\n\n  // Test method to check Redis connection and methods\n  async testRedisConnection(): Promise<void> {\n    try {\n      const client = this.getRedisClient();\n      this.logger.log('Redis client type:', typeof client);\n      this.logger.log('Redis client constructor:', client?.constructor?.name);\n\n      if (client) {\n        // List all methods available on the client\n        const allMethods = Object.getOwnPropertyNames(\n          Object.getPrototypeOf(client),\n        )\n          .filter((name) => typeof client[name] === 'function')\n          .sort();\n        this.logger.log('All available methods:', allMethods);\n      }\n    } catch (err) {\n      this.logger.error('Error testing Redis connection:', err);\n    }\n  }\n\n  // Helper methods for configuration and serialization\n  getConfig(configName: CacheConfigName | string): CacheConfig {\n    if (typeof configName === 'string' && configName in DEFAULT_CACHE_CONFIGS) {\n      return DEFAULT_CACHE_CONFIGS[configName as CacheConfigName];\n    }\n    return { ttl: 300, serialize: true }; // Default config\n  }\n\n  private generateCacheKey(key: string, config: CacheConfig): string {\n    return config.prefix ? `${config.prefix}:${key}` : key;\n  }\n\n  private async serializeData(\n    data: any,\n    config: CacheConfig,\n  ): Promise<string | Buffer> {\n    if (!config.serialize) return data;\n\n    const serialized = JSON.stringify(data);\n\n    if (config.compress) {\n      try {\n        return await gzip(serialized);\n      } catch (error) {\n        this.logger.warn('Compression failed, using uncompressed data', error);\n        return serialized;\n      }\n    }\n\n    return serialized;\n  }\n\n  private async deserializeData<T>(data: any, config: CacheConfig): Promise<T> {\n    if (!config.serialize) return data as T;\n\n    try {\n      let stringData: string;\n\n      if (config.compress && Buffer.isBuffer(data)) {\n        const decompressed = await gunzip(data);\n        stringData = decompressed.toString();\n      } else {\n        stringData = typeof data === 'string' ? data : JSON.stringify(data);\n      }\n\n      return JSON.parse(stringData);\n    } catch (error) {\n      this.logger.error('Failed to deserialize cache data', error);\n      return data as T;\n    }\n  }\n\n  private updateStats(isHit: boolean): void {\n    if (isHit) {\n      this.stats.hits++;\n    } else {\n      this.stats.misses++;\n    }\n    this.stats.totalOperations++;\n    this.stats.hitRate = (this.stats.hits / this.stats.totalOperations) * 100;\n  }\n\n  // Enhanced get method with config support\n  async get<T>(\n    key: string,\n    config?: CacheConfig | CacheConfigName,\n  ): Promise<T | null> {\n    try {\n      const cacheConfig =\n        typeof config === 'string'\n          ? this.getConfig(config)\n          : config || { ttl: 300 };\n      const fullKey = this.generateCacheKey(key, cacheConfig);\n\n      const value = await this.cacheManager.get(fullKey);\n\n      if (value !== null && value !== undefined) {\n        this.updateStats(true);\n        return await this.deserializeData<T>(value, cacheConfig);\n      }\n\n      this.updateStats(false);\n      return null;\n    } catch (err) {\n      this.logger.error(`Error reading cache key=${key}`, err);\n      this.updateStats(false);\n      return null;\n    }\n  }\n\n  // Enhanced set method with config support\n  async set<T>(\n    key: string,\n    value: T,\n    config?: CacheConfig | CacheConfigName | number,\n  ): Promise<void> {\n    try {\n      let cacheConfig: CacheConfig;\n\n      // Handle backward compatibility with old ttlSeconds parameter\n      if (typeof config === 'number') {\n        cacheConfig = { ttl: config, serialize: true };\n      } else if (typeof config === 'string') {\n        cacheConfig = this.getConfig(config);\n      } else {\n        cacheConfig = config || { ttl: 300, serialize: true };\n      }\n\n      const fullKey = this.generateCacheKey(key, cacheConfig);\n      const serializedValue = await this.serializeData(value, cacheConfig);\n\n      await this.cacheManager.set(\n        fullKey,\n        serializedValue,\n        cacheConfig.ttl ?? 300,\n      );\n\n      // Store tags for invalidation\n      if (cacheConfig.tags && cacheConfig.tags.length > 0) {\n        await this.addToTagIndex(cacheConfig.tags, fullKey);\n      }\n    } catch (err) {\n      this.logger.error(`Error setting cache key=${key}`, err);\n    }\n  }\n\n  // Helper methods for tag indexing\n  private async addToTagIndex(tags: string[], key: string): Promise<void> {\n    try {\n      for (const tag of tags) {\n        const tagKey = `tag:${tag}`;\n        await this.cacheManager.set(`${tagKey}:${key}`, '1', 3600); // 1 hour for tag index\n      }\n    } catch (err) {\n      this.logger.warn('Failed to update tag index', err);\n    }\n  }\n\n  private async removeFromTagIndex(tags: string[], key: string): Promise<void> {\n    try {\n      for (const tag of tags) {\n        const tagKey = `tag:${tag}:${key}`;\n        await this.cacheManager.del(tagKey);\n      }\n    } catch (err) {\n      this.logger.warn('Failed to remove from tag index', err);\n    }\n  }\n\n  // Enhanced delete method\n  async del(\n    key: string,\n    config?: CacheConfig | CacheConfigName,\n  ): Promise<void> {\n    try {\n      const cacheConfig =\n        typeof config === 'string' ? this.getConfig(config) : config;\n      const fullKey = cacheConfig\n        ? this.generateCacheKey(key, cacheConfig)\n        : key;\n\n      await this.cacheManager.del(fullKey);\n\n      // Remove from tag index if tags exist\n      if (cacheConfig?.tags) {\n        await this.removeFromTagIndex(cacheConfig.tags, fullKey);\n      }\n    } catch (err) {\n      this.logger.error(`Error deleting cache key=${key}`, err);\n    }\n  }\n\n  // Pattern-based invalidation\n  async invalidateByPattern(pattern: string): Promise<void> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) {\n        this.logger.warn('Redis client not available for pattern invalidation');\n        return;\n      }\n\n      // Use SCAN to find keys matching pattern\n      const keys: string[] = [];\n      let cursor = '0';\n\n      do {\n        const result = await client.scan(\n          cursor,\n          'MATCH',\n          pattern,\n          'COUNT',\n          1000,\n        );\n        cursor = result[0];\n        keys.push(...result[1]);\n      } while (cursor !== '0');\n\n      if (keys.length > 0) {\n        await client.del(...keys);\n        this.logger.debug(\n          `Invalidated ${keys.length} keys matching pattern: ${pattern}`,\n        );\n      }\n    } catch (err) {\n      this.logger.error(`Error invalidating pattern=${pattern}`, err);\n    }\n  }\n\n  // Tag-based invalidation\n  async invalidateByTag(tag: string): Promise<void> {\n    try {\n      await this.invalidateByPattern(`tag:${tag}:*`);\n    } catch (err) {\n      this.logger.error(`Error invalidating tag=${tag}`, err);\n    }\n  }\n\n  // Event-based invalidation\n  async invalidateByEvent(\n    event: CacheEvent,\n    data: Record<string, any>,\n  ): Promise<void> {\n    try {\n      switch (event) {\n        case CacheEvent.USER_UPDATED:\n          await this.invalidateByPattern(`user:profile:${data.userId}`);\n          await this.invalidateByPattern(`user:feed:${data.userId}:*`);\n          break;\n        case CacheEvent.POST_CREATED:\n        case CacheEvent.POST_UPDATED:\n          await this.invalidateByPattern(`user:feed:*`);\n          await this.invalidateByPattern(`post:list:*`);\n          break;\n        case CacheEvent.USER_DELETED:\n          await this.invalidateByPattern(`user:*:${data.userId}:*`);\n          await this.invalidateByPattern(`*:${data.userId}:*`);\n          break;\n        default:\n          this.logger.warn(`Unknown cache event: ${event}`);\n      }\n    } catch (err) {\n      this.logger.error(`Error handling cache event=${event}`, err);\n    }\n  }\n\n  // Multiple key operations\n  async mget<T>(\n    keys: string[],\n    config?: CacheConfig | CacheConfigName,\n  ): Promise<(T | null)[]> {\n    const promises = keys.map((key) => this.get<T>(key, config));\n    return Promise.all(promises);\n  }\n\n  async mset<T>(\n    keyValuePairs: Array<[string, T]>,\n    config?: CacheConfig | CacheConfigName,\n  ): Promise<void> {\n    const promises = keyValuePairs.map(([key, value]) =>\n      this.set(key, value, config),\n    );\n    await Promise.all(promises);\n  }\n\n  // Statistics and monitoring\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      totalOperations: 0,\n      lastReset: new Date(),\n    };\n  }\n\n  async ping(): Promise<boolean> {\n    try {\n      await this.cacheManager.set('ping', 'pong', 1);\n      const result = await this.cacheManager.get('ping');\n      await this.cacheManager.del('ping');\n      return result === 'pong';\n    } catch (err) {\n      this.logger.error('Cache ping failed', err);\n      return false;\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      await this.cacheManager.clear();\n      this.resetStats();\n    } catch (err) {\n      this.logger.error('Error clearing cache', err);\n    }\n  }\n\n  // ZSET operations for Redis\n  async zAdd(key: string, score: number, member: string): Promise<number> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return 0;\n\n      // Try different method names based on Redis client version\n      if (typeof client.zadd === 'function') {\n        return await client.zadd(key, score, member);\n      } else if (typeof client.zAdd === 'function') {\n        return await client.zAdd(key, [{ score, value: member }]);\n      } else if (typeof client.ZADD === 'function') {\n        return await client.ZADD(key, score, member);\n      }\n\n      this.logger.warn(`zAdd method not found on Redis client for key=${key}`);\n      return 0;\n    } catch (err) {\n      this.logger.error(`Error adding to sorted set key=${key}`, err);\n      return 0;\n    }\n  }\n\n  async zRevRangeWithScores(\n    key: string,\n    start: number,\n    stop: number,\n  ): Promise<{ value: string; score: number }[]> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return [];\n\n      let result: any;\n\n      // Try different method names\n      if (typeof client.zrevrangebyscore === 'function') {\n        result = await client.zrevrangebyscore(\n          key,\n          '+inf',\n          '-inf',\n          'WITHSCORES',\n          'LIMIT',\n          start,\n          stop - start + 1,\n        );\n      } else if (typeof client.zRevRangeWithScores === 'function') {\n        result = await client.zRevRangeWithScores(key, start, stop);\n      } else if (typeof client.ZREVRANGE === 'function') {\n        result = await client.ZREVRANGE(key, start, stop, 'WITHSCORES');\n      } else if (typeof client.zrevrange === 'function') {\n        result = await client.zrevrange(key, start, stop, 'WITHSCORES');\n      } else {\n        this.logger.warn(\n          `zRevRangeWithScores method not found on Redis client for key=${key}`,\n        );\n        return [];\n      }\n\n      // Handle different result formats\n      if (Array.isArray(result)) {\n        if (\n          result.length > 0 &&\n          typeof result[0] === 'object' &&\n          'value' in result[0]\n        ) {\n          // Already in correct format\n          return result.map((item: any) => ({\n            value: item.value,\n            score: item.score,\n          }));\n        } else {\n          // Format: [member1, score1, member2, score2, ...]\n          const formatted: { value: string; score: number }[] = [];\n          for (let i = 0; i < result.length; i += 2) {\n            formatted.push({\n              value: result[i],\n              score: parseFloat(result[i + 1]),\n            });\n          }\n          return formatted;\n        }\n      }\n\n      return [];\n    } catch (err) {\n      this.logger.error(`Error getting sorted set range key=${key}`, err);\n      return [];\n    }\n  }\n\n  async zCard(key: string): Promise<number> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return 0;\n\n      // Try different method names\n      if (typeof client.zcard === 'function') {\n        return await client.zcard(key);\n      } else if (typeof client.zCard === 'function') {\n        return await client.zCard(key);\n      } else if (typeof client.ZCARD === 'function') {\n        return await client.ZCARD(key);\n      }\n\n      this.logger.warn(`zCard method not found on Redis client for key=${key}`);\n      return 0;\n    } catch (err) {\n      this.logger.error(`Error getting sorted set count key=${key}`, err);\n      return 0;\n    }\n  }\n\n  async zRemRangeByRank(\n    key: string,\n    start: number,\n    stop: number,\n  ): Promise<number> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return 0;\n\n      // Try different method names\n      if (typeof client.zremrangebyrank === 'function') {\n        return await client.zremrangebyrank(key, start, stop);\n      } else if (typeof client.zRemRangeByRank === 'function') {\n        return await client.zRemRangeByRank(key, start, stop);\n      } else if (typeof client.ZREMRANGEBYRANK === 'function') {\n        return await client.ZREMRANGEBYRANK(key, start, stop);\n      }\n\n      this.logger.warn(\n        `zRemRangeByRank method not found on Redis client for key=${key}`,\n      );\n      return 0;\n    } catch (err) {\n      this.logger.error(`Error removing sorted set range key=${key}`, err);\n      return 0;\n    }\n  }\n\n  async zRem(key: string, member: string): Promise<number> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return 0;\n\n      // Try different method names\n      if (typeof client.zrem === 'function') {\n        return await client.zrem(key, member);\n      } else if (typeof client.zRem === 'function') {\n        return await client.zRem(key, member);\n      } else if (typeof client.ZREM === 'function') {\n        return await client.ZREM(key, member);\n      }\n\n      this.logger.warn(`zRem method not found on Redis client for key=${key}`);\n      return 0;\n    } catch (err) {\n      this.logger.error(`Error removing from sorted set key=${key}`, err);\n      return 0;\n    }\n  }\n\n  async zScore(key: string, member: string): Promise<number | null> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return null;\n\n      // Try different method names\n      if (typeof client.zscore === 'function') {\n        return await client.zscore(key, member);\n      } else if (typeof client.zScore === 'function') {\n        return await client.zScore(key, member);\n      } else if (typeof client.ZSCORE === 'function') {\n        return await client.ZSCORE(key, member);\n      }\n\n      this.logger.warn(\n        `zScore method not found on Redis client for key=${key}`,\n      );\n      return null;\n    } catch (err) {\n      this.logger.error(`Error getting sorted set score key=${key}`, err);\n      return null;\n    }\n  }\n\n  async expire(key: string, seconds: number): Promise<boolean> {\n    try {\n      const client = this.getRedisClient();\n      if (!client) return false;\n\n      // Try different method names\n      if (typeof client.expire === 'function') {\n        return await client.expire(key, seconds);\n      } else if (typeof client.EXPIRE === 'function') {\n        return await client.EXPIRE(key, seconds);\n      } else if (typeof client.pexpire === 'function') {\n        return await client.pexpire(key, seconds * 1000); // Convert to milliseconds\n      }\n\n      this.logger.warn(\n        `expire method not found on Redis client for key=${key}`,\n      );\n      return false;\n    } catch (err) {\n      this.logger.error(`Error setting expiry for key=${key}`, err);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\cache.utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CacheConfigName' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_CACHE_CONFIGS' is defined but never used.","line":3,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":48},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":17,"column":55,"nodeType":"TSAnyKeyword","messageId":"overrides","endLine":17,"endColumn":58},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":32,"column":48,"nodeType":"TSAnyKeyword","messageId":"overrides","endLine":32,"endColumn":51},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":96,"column":14,"nodeType":"TSAnyKeyword","messageId":"overrides","endLine":96,"endColumn":17},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":125,"column":55,"nodeType":"TSAnyKeyword","messageId":"overrides","endLine":125,"endColumn":58},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":292,"column":20,"nodeType":"TSAnyKeyword","messageId":"overrides","endLine":292,"endColumn":23},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'warmPopularContent' has no 'await' expression.","line":326,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":326,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9938,9979],"text":"warmPopularContent(): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":384,"column":48,"nodeType":"Identifier","messageId":"invalidType","endLine":384,"endColumn":52}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { RedisCacheService } from './cache.service';\nimport { CacheConfigName, DEFAULT_CACHE_CONFIGS } from './cache.interfaces';\n\n@Injectable()\nexport class CacheUtils {\n  private readonly logger = new Logger(CacheUtils.name);\n\n  constructor(private readonly cacheService: RedisCacheService) {}\n\n  // User-related caching utilities\n  async cacheUserProfile(userId: string, userData: any): Promise<void> {\n    const key = `user:profile:${userId}`;\n    await this.cacheService.set(key, userData, 'USER_PROFILE');\n  }\n\n  async getCachedUserProfile(userId: string): Promise<any | null> {\n    const key = `user:profile:${userId}`;\n    return this.cacheService.get(key, 'USER_PROFILE');\n  }\n\n  async invalidateUserProfile(userId: string): Promise<void> {\n    await this.cacheService.del(`user:profile:${userId}`, 'USER_PROFILE');\n  }\n\n  // Post-related caching utilities\n  async cachePost(postId: string, postData: any): Promise<void> {\n    const key = `post:${postId}`;\n    await this.cacheService.set(key, postData, 'POST');\n  }\n\n  async getCachedPost(postId: string): Promise<any | null> {\n    const key = `post:${postId}`;\n    return this.cacheService.get(key, 'POST');\n  }\n\n  async cacheUserPosts(\n    userId: string,\n    posts: any[],\n    page: number = 1,\n    limit: number = 20,\n  ): Promise<void> {\n    const key = `post:list:user:${userId}:${page}:${limit}`;\n    await this.cacheService.set(key, posts, 'POST_LIST');\n  }\n\n  async getCachedUserPosts(\n    userId: string,\n    page: number = 1,\n    limit: number = 20,\n  ): Promise<any[] | null> {\n    const key = `post:list:user:${userId}:${page}:${limit}`;\n    return this.cacheService.get(key, 'POST_LIST');\n  }\n\n  // Feed-related caching utilities\n  async cacheUserFeed(\n    userId: string,\n    feedData: any[],\n    page: number = 1,\n    limit: number = 20,\n  ): Promise<void> {\n    const key = `user:feed:${userId}:${page}:${limit}`;\n    await this.cacheService.set(key, feedData, 'USER_FEED');\n  }\n\n  async getCachedUserFeed(\n    userId: string,\n    page: number = 1,\n    limit: number = 20,\n  ): Promise<any[] | null> {\n    const key = `user:feed:${userId}:${page}:${limit}`;\n    return this.cacheService.get(key, 'USER_FEED');\n  }\n\n  async invalidateUserFeed(userId: string): Promise<void> {\n    await this.cacheService.invalidateByPattern(`user:feed:${userId}:*`);\n  }\n\n  // Search-related caching utilities\n  async cacheSearchResults(\n    query: string,\n    results: any,\n    type: string = 'all',\n    page: number = 1,\n  ): Promise<void> {\n    const normalizedQuery = this.normalizeSearchQuery(query);\n    const key = `search:${normalizedQuery}:${type}:${page}`;\n    await this.cacheService.set(key, results, 'SEARCH_RESULTS');\n  }\n\n  async getCachedSearchResults(\n    query: string,\n    type: string = 'all',\n    page: number = 1,\n  ): Promise<any | null> {\n    const normalizedQuery = this.normalizeSearchQuery(query);\n    const key = `search:${normalizedQuery}:${type}:${page}`;\n    return this.cacheService.get(key, 'SEARCH_RESULTS');\n  }\n\n  async cachePopularSearches(searches: any[]): Promise<void> {\n    const key = 'search:popular';\n    await this.cacheService.set(key, searches, 'SEARCH_RESULTS');\n  }\n\n  async getCachedPopularSearches(): Promise<any[] | null> {\n    const key = 'search:popular';\n    return this.cacheService.get(key, 'SEARCH_RESULTS');\n  }\n\n  // Authentication-related caching utilities\n  async cacheUserSession(\n    userId: string,\n    sessionData: any,\n    expiresIn: number = 3600,\n  ): Promise<void> {\n    const key = `auth:session:${userId}`;\n    await this.cacheService.set(key, sessionData, {\n      ttl: expiresIn,\n      serialize: true,\n    });\n  }\n\n  async getCachedUserSession(userId: string): Promise<any | null> {\n    const key = `auth:session:${userId}`;\n    return this.cacheService.get(key, 'AUTH_STATE');\n  }\n\n  async invalidateUserSession(userId: string): Promise<void> {\n    await this.cacheService.del(`auth:session:${userId}`, 'AUTH_STATE');\n  }\n\n  async cacheUserPermissions(\n    userId: string,\n    permissions: string[],\n  ): Promise<void> {\n    const key = `auth:permissions:${userId}`;\n    await this.cacheService.set(key, permissions, 'AUTH_STATE');\n  }\n\n  async getCachedUserPermissions(userId: string): Promise<string[] | null> {\n    const key = `auth:permissions:${userId}`;\n    return this.cacheService.get(key, 'AUTH_STATE');\n  }\n\n  // Notification-related caching utilities\n  async cacheUserNotifications(\n    userId: string,\n    notifications: any[],\n    page: number = 1,\n  ): Promise<void> {\n    const key = `notifications:${userId}:${page}`;\n    await this.cacheService.set(key, notifications, 'NOTIFICATION_LIST');\n  }\n\n  async getCachedUserNotifications(\n    userId: string,\n    page: number = 1,\n  ): Promise<any[] | null> {\n    const key = `notifications:${userId}:${page}`;\n    return this.cacheService.get(key, 'NOTIFICATION_LIST');\n  }\n\n  async cacheUnreadNotificationCount(\n    userId: string,\n    count: number,\n  ): Promise<void> {\n    const key = `notifications:unread:${userId}`;\n    await this.cacheService.set(key, count, { ttl: 300 }); // 5 minutes\n  }\n\n  async getCachedUnreadNotificationCount(\n    userId: string,\n  ): Promise<number | null> {\n    const key = `notifications:unread:${userId}`;\n    return this.cacheService.get(key, { ttl: 300 });\n  }\n\n  // Follow-related caching utilities\n  async cacheUserFollowers(\n    userId: string,\n    followers: any[],\n    page: number = 1,\n  ): Promise<void> {\n    const key = `user:followers:${userId}:${page}`;\n    await this.cacheService.set(key, followers, 'USER_LIST');\n  }\n\n  async getCachedUserFollowers(\n    userId: string,\n    page: number = 1,\n  ): Promise<any[] | null> {\n    const key = `user:followers:${userId}:${page}`;\n    return this.cacheService.get(key, 'USER_LIST');\n  }\n\n  async cacheUserFollowing(\n    userId: string,\n    following: any[],\n    page: number = 1,\n  ): Promise<void> {\n    const key = `user:following:${userId}:${page}`;\n    await this.cacheService.set(key, following, 'USER_LIST');\n  }\n\n  async getCachedUserFollowing(\n    userId: string,\n    page: number = 1,\n  ): Promise<any[] | null> {\n    const key = `user:following:${userId}:${page}`;\n    return this.cacheService.get(key, 'USER_LIST');\n  }\n\n  // Reaction/Like caching utilities\n  async cachePostLikeCount(postId: string, count: number): Promise<void> {\n    const key = `post:likes:${postId}`;\n    await this.cacheService.set(key, count, { ttl: 300 }); // 5 minutes\n  }\n\n  async getCachedPostLikeCount(postId: string): Promise<number | null> {\n    const key = `post:likes:${postId}`;\n    return this.cacheService.get(key, { ttl: 300 });\n  }\n\n  async cachePostCommentCount(postId: string, count: number): Promise<void> {\n    const key = `post:comments:${postId}`;\n    await this.cacheService.set(key, count, { ttl: 300 }); // 5 minutes\n  }\n\n  async getCachedPostCommentCount(postId: string): Promise<number | null> {\n    const key = `post:comments:${postId}`;\n    return this.cacheService.get(key, { ttl: 300 });\n  }\n\n  // Comment caching utilities\n  async cachePostComments(\n    postId: string,\n    comments: any[],\n    page: number = 1,\n  ): Promise<void> {\n    const key = `post:comments:${postId}:${page}`;\n    await this.cacheService.set(key, comments, 'POST_LIST');\n  }\n\n  async getCachedPostComments(\n    postId: string,\n    page: number = 1,\n  ): Promise<any[] | null> {\n    const key = `post:comments:${postId}:${page}`;\n    return this.cacheService.get(key, 'POST_LIST');\n  }\n\n  // Trending/Popular content caching\n  async cacheTrendingPosts(\n    posts: any[],\n    timeframe: string = 'day',\n  ): Promise<void> {\n    const key = `trending:posts:${timeframe}`;\n    await this.cacheService.set(key, posts, 'POST_LIST');\n  }\n\n  async getCachedTrendingPosts(\n    timeframe: string = 'day',\n  ): Promise<any[] | null> {\n    const key = `trending:posts:${timeframe}`;\n    return this.cacheService.get(key, 'POST_LIST');\n  }\n\n  async cachePopularUsers(users: any[]): Promise<void> {\n    const key = 'users:popular';\n    await this.cacheService.set(key, users, 'USER_LIST');\n  }\n\n  async getCachedPopularUsers(): Promise<any[] | null> {\n    const key = 'users:popular';\n    return this.cacheService.get(key, 'USER_LIST');\n  }\n\n  // Batch operations\n  async cacheBatchUserProfiles(\n    userProfiles: Array<[string, any]>,\n  ): Promise<void> {\n    const promises = userProfiles.map(([userId, profile]) =>\n      this.cacheUserProfile(userId, profile),\n    );\n    await Promise.all(promises);\n  }\n\n  async getCachedBatchUserProfiles(\n    userIds: string[],\n  ): Promise<Array<any | null>> {\n    const promises = userIds.map((userId) => this.getCachedUserProfile(userId));\n    return Promise.all(promises);\n  }\n\n  // Cache invalidation utilities\n  async invalidateAllUserRelatedCache(userId: string): Promise<void> {\n    await Promise.all([\n      this.cacheService.invalidateByPattern(`user:profile:${userId}`),\n      this.cacheService.invalidateByPattern(`user:feed:${userId}:*`),\n      this.cacheService.invalidateByPattern(`user:followers:${userId}:*`),\n      this.cacheService.invalidateByPattern(`user:following:${userId}:*`),\n      this.cacheService.invalidateByPattern(`auth:*:${userId}`),\n      this.cacheService.invalidateByPattern(`notifications:${userId}:*`),\n    ]);\n  }\n\n  async invalidateAllPostRelatedCache(postId: string): Promise<void> {\n    await Promise.all([\n      this.cacheService.invalidateByPattern(`post:${postId}`),\n      this.cacheService.invalidateByPattern(`post:likes:${postId}`),\n      this.cacheService.invalidateByPattern(`post:comments:${postId}:*`),\n      this.cacheService.invalidateByPattern(`user:feed:*`), // Invalidate all feeds\n    ]);\n  }\n\n  // Cache warming utilities\n  async warmUserCache(userId: string, userData: any): Promise<void> {\n    await Promise.all([\n      this.cacheUserProfile(userId, userData),\n      // Pre-warm related caches if needed\n    ]);\n  }\n\n  async warmPopularContent(): Promise<void> {\n    try {\n      // This would typically fetch and cache popular content\n      // Implementation depends on your business logic\n      this.logger.log('Warming popular content cache...');\n\n      // Example: Cache popular searches, trending posts, etc.\n      // await this.cachePopularSearches(await this.getPopularSearches());\n      // await this.cacheTrendingPosts(await this.getTrendingPosts());\n    } catch (error) {\n      this.logger.error('Error warming popular content cache', error);\n    }\n  }\n\n  // Helper methods\n  private normalizeSearchQuery(query: string): string {\n    return query.toLowerCase().trim().replace(/\\s+/g, '_');\n  }\n\n  // Cache statistics for monitoring\n  async getCacheStatistics(): Promise<any> {\n    const stats = this.cacheService.getStats();\n    const isHealthy = await this.cacheService.ping();\n\n    return {\n      ...stats,\n      healthy: isHealthy,\n      timestamp: new Date(),\n    };\n  }\n\n  // Clear cache by type/pattern\n  async clearCacheByType(\n    type: 'user' | 'post' | 'feed' | 'search' | 'auth' | 'notification' | 'all',\n  ): Promise<void> {\n    switch (type) {\n      case 'user':\n        await this.cacheService.invalidateByTag('user');\n        break;\n      case 'post':\n        await this.cacheService.invalidateByTag('post');\n        break;\n      case 'feed':\n        await this.cacheService.invalidateByTag('feed');\n        break;\n      case 'search':\n        await this.cacheService.invalidateByTag('search');\n        break;\n      case 'auth':\n        await this.cacheService.invalidateByTag('auth');\n        break;\n      case 'notification':\n        await this.cacheService.invalidateByTag('notification');\n        break;\n      case 'all':\n        await this.cacheService.clear();\n        break;\n      default:\n        throw new Error(`Unknown cache type: ${type}`);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cache\\examples\\integration-examples.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getUserById' has no 'await' expression.","line":25,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":25,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[809,815],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'updateUser' has no 'await' expression.","line":43,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":43,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1286,1292],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":46,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":46,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":49,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":49,"endColumn":24},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'deleteUser' has no 'await' expression.","line":60,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":60,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1798,1804],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":75,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":75,"endColumn":30},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'fetchFollowersFromDB' has no 'await' expression.","line":88,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":88,"endColumn":37,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2702,2708],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getPostById' has no 'await' expression.","line":115,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":115,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3408,3414],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":137,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":142,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":147,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":147,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":147,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":149,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":149,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":161,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":161,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":179,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":179,"endColumn":29},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'fetchUserPostsFromDB' has no 'await' expression.","line":191,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":191,"endColumn":37,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5470,5476],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'calculateTrendingPosts' has no 'await' expression.","line":205,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":205,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5855,5861],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'timeframe' is defined but never used.","line":205,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":205,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":234,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":234,"endColumn":25},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'followUser' has no 'await' expression.","line":248,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":248,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7063,7069],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'generateUserFeed' has no 'await' expression.","line":254,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":254,"endColumn":33,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7302,7308],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":283,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":287,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":289,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":289,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":305,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":305,"endColumn":21},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'performSearch' has no 'await' expression.","line":314,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":314,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8836,8842],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'calculatePopularSearches' has no 'await' expression.","line":328,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":328,"endColumn":41,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9183,9189],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":359,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":359,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `Promise<any>`.","line":364,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":364,"endColumn":57},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'logout' has no 'await' expression.","line":373,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":373,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10432,10438],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getUserPermissions' has no 'await' expression.","line":378,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":378,"endColumn":35,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10580,10639],"text":"getUserPermissions(userId: string): string[]"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":378,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":378,"endColumn":42}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration examples showing how to use the enhanced caching system\n * in your existing services. These examples demonstrate both decorator-based\n * and manual caching approaches.\n */\n\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cacheable, CacheEvict, CacheUpdate } from '../cache.decorators';\nimport { RedisCacheService } from '../cache.service';\nimport { CacheUtils } from '../cache.utils';\n\n// ==================== USER SERVICE INTEGRATION ====================\n\n@Injectable()\nexport class EnhancedUserService {\n  private readonly logger = new Logger(EnhancedUserService.name);\n\n  constructor(\n    private readonly cacheService: RedisCacheService,\n    private readonly cacheUtils: CacheUtils,\n  ) {}\n\n  // Example 1: Decorator-based caching\n  @Cacheable('{{id}}', 'USER_PROFILE')\n  async getUserById(id: string) {\n    this.logger.debug(`Fetching user from database: ${id}`);\n    // Your existing user fetching logic here\n    return {\n      id,\n      username: `user_${id}`,\n      email: `user${id}@example.com`,\n      avatar: 'https://example.com/avatar.jpg',\n      createdAt: new Date(),\n    };\n  }\n\n  // Example 2: Cache update with invalidation\n  @CacheUpdate(\n    '{{id}}',\n    ['user:feed:{{id}}:*', 'user:followers:{{id}}:*'],\n    'USER_PROFILE',\n  )\n  async updateUser(id: string, updateData: any) {\n    this.logger.debug(`Updating user: ${id}`);\n    // Your existing update logic here\n    const updatedUser = { id, ...updateData, updatedAt: new Date() };\n\n    // The decorator will automatically cache this result and invalidate related caches\n    return updatedUser;\n  }\n\n  // Example 3: Cache eviction\n  @CacheEvict([\n    'user:profile:{{id}}',\n    'user:feed:{{id}}:*',\n    'user:followers:{{id}}:*',\n    'user:following:{{id}}:*',\n    'auth:*:{{id}}',\n  ])\n  async deleteUser(id: string) {\n    this.logger.debug(`Deleting user: ${id}`);\n    // Your existing deletion logic here\n    return { success: true, deletedAt: new Date() };\n  }\n\n  // Example 4: Manual caching for complex scenarios\n  async getUserFollowers(userId: string, page: number = 1, limit: number = 20) {\n    // Try cache first using utility\n    const cachedFollowers = await this.cacheUtils.getCachedUserFollowers(\n      userId,\n      page,\n    );\n    if (cachedFollowers) {\n      this.logger.debug(`Cache hit for user followers: ${userId}`);\n      return cachedFollowers;\n    }\n\n    // Cache miss - fetch from database\n    this.logger.debug(`Cache miss for user followers: ${userId}`);\n    const followers = await this.fetchFollowersFromDB(userId, page, limit);\n\n    // Cache the result\n    await this.cacheUtils.cacheUserFollowers(userId, followers, page);\n\n    return followers;\n  }\n\n  private async fetchFollowersFromDB(\n    userId: string,\n    page: number,\n    limit: number,\n  ) {\n    // Simulate database fetch\n    return Array.from({ length: Math.min(limit, 10) }, (_, i) => ({\n      id: `follower_${userId}_${page}_${i}`,\n      username: `follower_${i}`,\n      avatar: 'https://example.com/avatar.jpg',\n    }));\n  }\n}\n\n// ==================== POST SERVICE INTEGRATION ====================\n\n@Injectable()\nexport class EnhancedPostService {\n  private readonly logger = new Logger(EnhancedPostService.name);\n\n  constructor(\n    private readonly cacheService: RedisCacheService,\n    private readonly cacheUtils: CacheUtils,\n  ) {}\n\n  // Cache individual posts\n  @Cacheable('{{postId}}', 'POST')\n  async getPostById(postId: string) {\n    this.logger.debug(`Fetching post from database: ${postId}`);\n    // Your existing post fetching logic\n    return {\n      id: postId,\n      content: 'Sample post content',\n      authorId: 'user123',\n      likesCount: 42,\n      commentsCount: 15,\n      createdAt: new Date(),\n    };\n  }\n\n  // Create post with cache invalidation\n  @CacheEvict([\n    'user:feed:*', // Invalidate all user feeds\n    'post:list:{{authorId}}:*', // Invalidate author's post lists\n    'trending:posts:*', // Invalidate trending posts\n  ])\n  async createPost(authorId: string, postData: any) {\n    this.logger.debug(`Creating post for user: ${authorId}`);\n\n    const newPost = {\n      id: `post_${Date.now()}`,\n      ...postData,\n      authorId,\n      createdAt: new Date(),\n    };\n\n    // Your existing post creation logic here\n\n    // Immediately cache the new post\n    await this.cacheUtils.cachePost(newPost.id, newPost);\n\n    return newPost;\n  }\n\n  // Cache user posts with pagination\n  async getUserPosts(userId: string, page: number = 1, limit: number = 20) {\n    // Check cache first\n    const cachedPosts = await this.cacheUtils.getCachedUserPosts(\n      userId,\n      page,\n      limit,\n    );\n    if (cachedPosts) {\n      return cachedPosts;\n    }\n\n    // Fetch from database\n    const posts = await this.fetchUserPostsFromDB(userId, page, limit);\n\n    // Cache the result\n    await this.cacheUtils.cacheUserPosts(userId, posts, page, limit);\n\n    return posts;\n  }\n\n  // Cache trending posts\n  async getTrendingPosts(timeframe: 'day' | 'week' | 'month' = 'day') {\n    // Check cache first\n    const cachedTrending =\n      await this.cacheUtils.getCachedTrendingPosts(timeframe);\n    if (cachedTrending) {\n      return cachedTrending;\n    }\n\n    // Calculate trending posts (expensive operation)\n    const trendingPosts = await this.calculateTrendingPosts(timeframe);\n\n    // Cache with appropriate TTL based on timeframe\n    await this.cacheUtils.cacheTrendingPosts(trendingPosts, timeframe);\n\n    return trendingPosts;\n  }\n\n  private async fetchUserPostsFromDB(\n    userId: string,\n    page: number,\n    limit: number,\n  ) {\n    // Simulate database fetch\n    return Array.from({ length: Math.min(limit, 10) }, (_, i) => ({\n      id: `post_${userId}_${page}_${i}`,\n      content: `Post ${i + 1} content`,\n      authorId: userId,\n      createdAt: new Date(Date.now() - i * 86400000), // Days ago\n    }));\n  }\n\n  private async calculateTrendingPosts(timeframe: string) {\n    // Simulate expensive trending calculation\n    return [\n      { id: 'trending1', content: 'Viral post 1', score: 1000 },\n      { id: 'trending2', content: 'Viral post 2', score: 850 },\n    ];\n  }\n}\n\n// ==================== FEED SERVICE INTEGRATION ====================\n\n@Injectable()\nexport class EnhancedFeedService {\n  private readonly logger = new Logger(EnhancedFeedService.name);\n\n  constructor(\n    private readonly cacheService: RedisCacheService,\n    private readonly cacheUtils: CacheUtils,\n  ) {}\n\n  // Cache user feeds with compression (feeds can be large)\n  async getUserFeed(userId: string, page: number = 1, limit: number = 20) {\n    // Check cache first\n    const cachedFeed = await this.cacheUtils.getCachedUserFeed(\n      userId,\n      page,\n      limit,\n    );\n    if (cachedFeed) {\n      return cachedFeed;\n    }\n\n    // Generate feed (complex operation)\n    const feed = await this.generateUserFeed(userId, page, limit);\n\n    // Cache with compression\n    await this.cacheUtils.cacheUserFeed(userId, feed, page, limit);\n\n    return feed;\n  }\n\n  // Invalidate feed when user follows someone\n  @CacheEvict(['user:feed:{{userId}}:*'])\n  async followUser(userId: string, targetUserId: string) {\n    this.logger.debug(`User ${userId} following user ${targetUserId}`);\n    // Your existing follow logic\n    return { userId, targetUserId, followedAt: new Date() };\n  }\n\n  private async generateUserFeed(userId: string, page: number, limit: number) {\n    // Simulate complex feed generation\n    return Array.from({ length: limit }, (_, i) => ({\n      id: `feed_item_${userId}_${page}_${i}`,\n      type: 'post',\n      content: `Feed item ${i + 1}`,\n      timestamp: new Date(Date.now() - i * 3600000), // Hours ago\n    }));\n  }\n}\n\n// ==================== SEARCH SERVICE INTEGRATION ====================\n\n@Injectable()\nexport class EnhancedSearchService {\n  private readonly logger = new Logger(EnhancedSearchService.name);\n\n  constructor(\n    private readonly cacheService: RedisCacheService,\n    private readonly cacheUtils: CacheUtils,\n  ) {}\n\n  // Cache search results\n  async search(\n    query: string,\n    type: 'users' | 'posts' | 'all' = 'all',\n    page: number = 1,\n  ) {\n    // Check cache first\n    const cachedResults = await this.cacheUtils.getCachedSearchResults(\n      query,\n      type,\n      page,\n    );\n    if (cachedResults) {\n      return cachedResults;\n    }\n\n    // Perform search\n    const results = await this.performSearch(query, type, page);\n\n    // Cache results\n    await this.cacheUtils.cacheSearchResults(query, results, type, page);\n\n    return results;\n  }\n\n  // Cache popular searches\n  async getPopularSearches() {\n    const cached = await this.cacheUtils.getCachedPopularSearches();\n    if (cached) {\n      return cached;\n    }\n\n    const popular = await this.calculatePopularSearches();\n    await this.cacheUtils.cachePopularSearches(popular);\n\n    return popular;\n  }\n\n  private async performSearch(query: string, type: string, page: number) {\n    // Simulate search logic\n    return {\n      query,\n      type,\n      results: [\n        { id: '1', title: `Result for ${query}`, type: 'post' },\n        { id: '2', title: `Another result for ${query}`, type: 'user' },\n      ],\n      total: 25,\n      page,\n    };\n  }\n\n  private async calculatePopularSearches() {\n    return [\n      { query: 'javascript', count: 1500 },\n      { query: 'react', count: 1200 },\n      { query: 'nodejs', count: 980 },\n    ];\n  }\n}\n\n// ==================== AUTH SERVICE INTEGRATION ====================\n\n@Injectable()\nexport class EnhancedAuthService {\n  private readonly logger = new Logger(EnhancedAuthService.name);\n\n  constructor(\n    private readonly cacheService: RedisCacheService,\n    private readonly cacheUtils: CacheUtils,\n  ) {}\n\n  // Cache user session\n  async createSession(userId: string, sessionData: any) {\n    const expiresIn = 3600; // 1 hour\n\n    // Cache session\n    await this.cacheUtils.cacheUserSession(userId, sessionData, expiresIn);\n\n    // Cache user permissions for quick access\n    const permissions = await this.getUserPermissions(userId);\n    await this.cacheUtils.cacheUserPermissions(userId, permissions);\n\n    return sessionData;\n  }\n\n  // Get cached session\n  async getSession(userId: string) {\n    return this.cacheUtils.getCachedUserSession(userId);\n  }\n\n  // Invalidate session and related auth data\n  @CacheEvict([\n    'auth:session:{{userId}}',\n    'auth:permissions:{{userId}}',\n    'user:profile:{{userId}}', // Also clear profile to force re-auth\n  ])\n  async logout(userId: string) {\n    this.logger.debug(`Logging out user: ${userId}`);\n    return { userId, loggedOutAt: new Date() };\n  }\n\n  private async getUserPermissions(userId: string): Promise<string[]> {\n    // Your permission logic here\n    return ['read', 'write', 'delete'];\n  }\n}\n\n// ==================== USAGE IN CONTROLLERS ====================\n\n/**\n * Example Controller Integration:\n *\n * @Controller('users')\n * export class UsersController {\n *   constructor(private readonly enhancedUserService: EnhancedUserService) {}\n *\n *   @Get(':id')\n *   async getUser(@Param('id') id: string) {\n *     return this.enhancedUserService.getUserById(id);\n *   }\n *\n *   @Put(':id')\n *   async updateUser(@Param('id') id: string, @Body() updateData: any) {\n *     return this.enhancedUserService.updateUser(id, updateData);\n *   }\n *\n *   @Get(':id/followers')\n *   async getUserFollowers(\n *     @Param('id') id: string,\n *     @Query('page') page: number = 1,\n *     @Query('limit') limit: number = 20,\n *   ) {\n *     return this.enhancedUserService.getUserFollowers(id, page, limit);\n *   }\n * }\n */\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cloudinary\\cloudinary.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":195,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":195,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":199,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":199,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Post,\n  Delete,\n  Param,\n  UploadedFile,\n  UploadedFiles,\n  UseInterceptors,\n  BadRequestException,\n  Body,\n  UseGuards,\n} from '@nestjs/common';\nimport { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';\nimport { CloudinaryService } from './cloudinary.service';\nimport { JwtAuthGuard } from '../../shared/guards/jwt.guard';\n\n@Controller('cloudinary')\n@UseGuards(JwtAuthGuard)\nexport class CloudinaryController {\n  constructor(private readonly cloudinaryService: CloudinaryService) {}\n\n  @Post('upload/single')\n  @UseInterceptors(\n    FileInterceptor('file', {\n      fileFilter: (req, file, callback) => {\n        if (\n          file.mimetype.startsWith('image/') ||\n          file.mimetype.startsWith('video/')\n        ) {\n          callback(null, true);\n        } else {\n          callback(\n            new BadRequestException('Only images and videos are allowed'),\n            false,\n          );\n        }\n      },\n      limits: {\n        fileSize: 50 * 1024 * 1024,\n      },\n    }),\n  )\n  async uploadSingle(\n    @UploadedFile() file: Express.Multer.File,\n    @Body('folder') folder?: string,\n  ) {\n    if (!file) {\n      throw new BadRequestException('File is required');\n    }\n\n    const result = await this.cloudinaryService.uploadFile(file, folder);\n\n    return {\n      message: 'File uploaded successfully',\n      data: {\n        publicId: result.public_id,\n        url: result.secure_url,\n        format: result.format,\n        resourceType: result.resource_type,\n        bytes: result.bytes,\n        width: result.width,\n        height: result.height,\n        thumbnail: this.cloudinaryService.getThumbnail(result.public_id),\n      },\n    };\n  }\n\n  @Post('upload/multiple')\n  @UseInterceptors(\n    FilesInterceptor('files', 10, {\n      fileFilter: (req, file, callback) => {\n        if (\n          file.mimetype.startsWith('image/') ||\n          file.mimetype.startsWith('video/')\n        ) {\n          callback(null, true);\n        } else {\n          callback(\n            new BadRequestException('Only images and videos are allowed'),\n            false,\n          );\n        }\n      },\n      limits: {\n        fileSize: 50 * 1024 * 1024, // 50MB per file\n      },\n    }),\n  )\n  async uploadMultiple(\n    @UploadedFiles() files: Express.Multer.File[],\n    @Body('folder') folder?: string,\n  ) {\n    if (!files || files.length === 0) {\n      throw new BadRequestException('At least one file is required');\n    }\n    const results = await this.cloudinaryService.uploadMultipleFiles(\n      files,\n      folder,\n    );\n\n    return {\n      message: 'Files uploaded successfully',\n      data: results.map((result) => ({\n        publicId: result.public_id,\n        url: result.secure_url,\n        format: result.format,\n        resourceType: result.resource_type,\n        bytes: result.bytes,\n        width: result.width,\n        height: result.height,\n        thumbnail: this.cloudinaryService.getThumbnail(result.public_id),\n      })),\n    };\n  }\n\n  @Post('upload/image')\n  @UseInterceptors(\n    FileInterceptor('image', {\n      fileFilter: (req, file, callback) => {\n        if (file.mimetype.startsWith('image/')) {\n          callback(null, true);\n        } else {\n          callback(new BadRequestException('Only images are allowed'), false);\n        }\n      },\n      limits: {\n        fileSize: 10 * 1024 * 1024, // 10MB for images\n      },\n    }),\n  )\n  async uploadImage(\n    @UploadedFile() file: Express.Multer.File,\n    @Body('folder') folder?: string,\n  ) {\n    if (!file) {\n      throw new BadRequestException('Image file is required');\n    }\n\n    const result = await this.cloudinaryService.uploadImage(file, folder);\n\n    return {\n      message: 'Image uploaded successfully',\n      data: {\n        publicId: result.public_id,\n        url: result.secure_url,\n        format: result.format,\n        bytes: result.bytes,\n        width: result.width,\n        height: result.height,\n        thumbnail: this.cloudinaryService.getThumbnail(result.public_id),\n      },\n    };\n  }\n\n  @Post('upload/video')\n  @UseInterceptors(\n    FileInterceptor('video', {\n      fileFilter: (req, file, callback) => {\n        if (file.mimetype.startsWith('video/')) {\n          callback(null, true);\n        } else {\n          callback(new BadRequestException('Only videos are allowed'), false);\n        }\n      },\n      limits: {\n        fileSize: 100 * 1024 * 1024, // 100MB for videos\n      },\n    }),\n  )\n  async uploadVideo(\n    @UploadedFile() file: Express.Multer.File,\n    @Body('folder') folder?: string,\n  ) {\n    if (!file) {\n      throw new BadRequestException('Video file is required');\n    }\n\n    const result = await this.cloudinaryService.uploadVideo(file, folder);\n\n    return {\n      message: 'Video uploaded successfully',\n      data: {\n        publicId: result.public_id,\n        url: result.secure_url,\n        format: result.format,\n        bytes: result.bytes,\n        width: result.width,\n        height: result.height,\n      },\n    };\n  }\n\n  @Delete(':publicId')\n  async deleteFile(@Param('publicId') publicId: string) {\n    const result = await this.cloudinaryService.deleteFile(publicId);\n\n    return {\n      message: 'File deleted successfully',\n      data: result,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cloudinary\\cloudinary.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cloudinary\\cloudinary.service.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'generateSignature' has no 'await' expression.","line":14,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":14,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[465,540],"text":"generateSignature(paramsToSign: Record<string, any>): string"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":20,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":54,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":88,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":121,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":129,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":19}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, BadRequestException } from '@nestjs/common';\nimport { v2 as cloudinary } from 'cloudinary';\nimport { Readable } from 'stream';\nimport { CloudinaryResponse } from './dto/cloudinary.response';\nimport { CLOUDINARY } from 'src/config/cloudinary.constant';\nimport { CloudinaryConfig } from 'src/config/cloudinary.config';\n\n@Injectable()\nexport class CloudinaryService {\n  constructor() {\n    cloudinary.config(CloudinaryConfig.useFactory());\n  }\n\n  async generateSignature(paramsToSign: Record<string, any>): Promise<string> {\n    try {\n      return cloudinary.utils.api_sign_request(\n        paramsToSign,\n        CLOUDINARY.API_SECRET || '',\n      );\n    } catch (error) {\n      throw new BadRequestException('Failed to generate signature');\n    }\n  }\n\n  async uploadImage(\n    file: Express.Multer.File,\n    folder: string = CLOUDINARY.FOLDER,\n  ): Promise<CloudinaryResponse> {\n    try {\n      return new Promise((resolve, reject) => {\n        const uploadStream = cloudinary.uploader.upload_stream(\n          {\n            folder: folder,\n            resource_type: 'image',\n            transformation: [\n              { width: 1000, height: 1000, crop: 'limit', quality: 'auto' },\n            ],\n            format: 'webp',\n          },\n          (error, result) => {\n            if (error) {\n              reject(new BadRequestException('Image upload failed'));\n            } else {\n              resolve(result as unknown as CloudinaryResponse);\n            }\n          },\n        );\n\n        const bufferStream = new Readable();\n        bufferStream.push(file.buffer);\n        bufferStream.push(null);\n        bufferStream.pipe(uploadStream);\n      });\n    } catch (error) {\n      throw new BadRequestException('Image upload failed');\n    }\n  }\n\n  async uploadVideo(\n    file: Express.Multer.File,\n    folder: string = 'social-media/videos',\n  ): Promise<CloudinaryResponse> {\n    try {\n      return new Promise((resolve, reject) => {\n        const uploadStream = cloudinary.uploader.upload_stream(\n          {\n            folder: folder,\n            resource_type: 'video',\n            transformation: [\n              { width: 1280, height: 720, crop: 'limit', quality: 'auto' },\n            ],\n            format: 'mp4',\n          },\n          (error, result) => {\n            if (error) {\n              reject(new BadRequestException('Video upload failed'));\n            } else {\n              resolve(result as unknown as CloudinaryResponse);\n            }\n          },\n        );\n\n        const bufferStream = new Readable();\n        bufferStream.push(file.buffer);\n        bufferStream.push(null);\n        bufferStream.pipe(uploadStream);\n      });\n    } catch (error) {\n      throw new BadRequestException('Video upload failed');\n    }\n  }\n\n  async uploadFile(\n    file: Express.Multer.File,\n    folder: string = CLOUDINARY.FOLDER,\n  ): Promise<CloudinaryResponse> {\n    const isImage = file.mimetype.startsWith('image/');\n    const isVideo = file.mimetype.startsWith('video/');\n\n    if (isImage) {\n      return this.uploadImage(file, `${folder}/images`);\n    } else if (isVideo) {\n      return this.uploadVideo(file, `${folder}/videos`);\n    } else {\n      throw new BadRequestException('Only images and videos are allowed');\n    }\n  }\n\n  async uploadMultipleFiles(\n    files: Express.Multer.File[],\n    folder: string = CLOUDINARY.FOLDER,\n  ): Promise<CloudinaryResponse[]> {\n    console.log('Service received files:', files.length);\n    const uploadPromises = files.map((file) => this.uploadFile(file, folder));\n    return Promise.all(uploadPromises);\n  }\n\n  async deleteFile(publicId: string): Promise<any> {\n    try {\n      return await cloudinary.uploader.destroy(publicId);\n    } catch (error) {\n      throw new BadRequestException('Failed to delete file');\n    }\n  }\n\n  async deleteMultipleFiles(publicIds: string[]): Promise<any> {\n    try {\n      return await cloudinary.api.delete_resources(publicIds);\n    } catch (error) {\n      throw new BadRequestException('Failed to delete files');\n    }\n  }\n\n  // Get optimized URL for different sizes\n  getOptimizedUrl(\n    publicId: string,\n    options: {\n      width?: number;\n      height?: number;\n      quality?: string;\n      format?: string;\n    } = {},\n  ): string {\n    return cloudinary.url(publicId, {\n      width: options.width || 'auto',\n      height: options.height || 'auto',\n      crop: 'fill',\n      quality: options.quality || 'auto',\n      format: options.format || 'auto',\n    });\n  }\n\n  getThumbnail(publicId: string, size: number = 150): string {\n    return cloudinary.url(publicId, {\n      width: size,\n      height: size,\n      crop: 'fill',\n      quality: 'auto',\n      format: 'webp',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\cloudinary\\dto\\cloudinary.response.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\comment-application.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":63,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":83,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":83,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":98,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":116,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":11},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getCommentsByAuthor' has no 'await' expression.","line":192,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":192,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5329,5458],"text":"getCommentsByAuthor(\n    authorId: string,\n    dto: GetCommentsDto,\n    userId?: string,\n  ): CommentPaginationDto"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'authorId' is defined but never used.","line":193,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":193,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dto' is defined but never used.","line":194,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":195,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":195,"endColumn":11}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport {\n  CommentApplicationService,\n  CommentMapper,\n} from './interfaces/comment-application.interface';\nimport {\n  CreateCommentDto,\n  UpdateCommentDto,\n  AddCommentReactionDto,\n  GetCommentsDto,\n  GetRepliesDto,\n  CommentResponseDto,\n  CommentWithRepliesDto,\n  CommentPaginationDto,\n  ReactionToggleResponseDto,\n} from './dto/comment.dto';\nimport { CommentEntity } from '../domain/comment.entity';\n\n// Use Cases\nimport { CreateCommentUseCase } from './use-cases/create-comment.use-case';\nimport { GetCommentsByPostUseCase } from './use-cases/get-comments-by-post.use-case';\nimport { GetCommentByIdUseCase } from './use-cases/get-comment-by-id.use-case';\nimport { UpdateCommentUseCase } from './use-cases/update-comment.use-case';\nimport { DeleteCommentUseCase } from './use-cases/delete-comment.use-case';\nimport { AddReactionUseCase } from './use-cases/add-reaction.use-case';\nimport { RemoveReactionUseCase } from './use-cases/remove-reaction.use-case';\nimport { GetRepliesUseCase } from './use-cases/get-replies.use-case';\n\n@Injectable()\nexport class CommentApplicationServiceImpl\n  implements CommentApplicationService\n{\n  constructor(\n    private readonly createCommentUseCase: CreateCommentUseCase,\n    private readonly getCommentsByPostUseCase: GetCommentsByPostUseCase,\n    private readonly getCommentByIdUseCase: GetCommentByIdUseCase,\n    private readonly updateCommentUseCase: UpdateCommentUseCase,\n    private readonly deleteCommentUseCase: DeleteCommentUseCase,\n    private readonly addReactionUseCase: AddReactionUseCase,\n    private readonly removeReactionUseCase: RemoveReactionUseCase,\n    private readonly getRepliesUseCase: GetRepliesUseCase,\n    @Inject('CommentMapper')\n    private readonly commentMapper: CommentMapper,\n  ) {}\n\n  async createComment(\n    dto: CreateCommentDto,\n    authorId: string,\n  ): Promise<CommentResponseDto> {\n    const comment = await this.createCommentUseCase.execute({\n      content: dto.content,\n      postId: dto.postId,\n      parentId: dto.parentId,\n      authorId,\n    });\n\n    return this.commentMapper.toDto(comment);\n  }\n\n  async getCommentsByPost(\n    postId: string,\n    dto: GetCommentsDto,\n    userId?: string,\n  ): Promise<CommentPaginationDto> {\n    const result = await this.getCommentsByPostUseCase.execute({\n      postId,\n      page: dto.page || 1,\n      limit: dto.limit || 10,\n      sortBy: dto.sortBy,\n    });\n\n    return this.commentMapper.toPaginationDto(\n      result.items,\n      result.total,\n      result.page,\n      result.limit,\n    );\n  }\n\n  async getCommentWithReplies(\n    commentId: string,\n    dto: GetRepliesDto,\n    userId?: string,\n  ): Promise<CommentWithRepliesDto> {\n    const comment = await this.getCommentByIdUseCase.execute({ commentId });\n    const replies = await this.getRepliesUseCase.execute({\n      commentId,\n      page: dto.page || 1,\n      limit: dto.limit || 10,\n    });\n\n    return this.commentMapper.toCommentWithRepliesDto(comment, replies);\n  }\n\n  async getRepliesForComment(\n    commentId: string,\n    dto: GetRepliesDto,\n    userId?: string,\n  ): Promise<CommentPaginationDto> {\n    const result = await this.getRepliesUseCase.execute({\n      commentId,\n      page: dto.page || 1,\n      limit: dto.limit || 10,\n    });\n\n    return this.commentMapper.toPaginationDto(\n      result.items,\n      result.total,\n      result.page,\n      result.limit,\n    );\n  }\n\n  async getCommentById(\n    commentId: string,\n    userId?: string,\n  ): Promise<CommentResponseDto> {\n    const comment = await this.getCommentByIdUseCase.execute({ commentId });\n    return this.commentMapper.toDto(comment);\n  }\n\n  async updateComment(\n    commentId: string,\n    dto: UpdateCommentDto,\n    userId: string,\n  ): Promise<CommentResponseDto> {\n    const comment = await this.updateCommentUseCase.execute({\n      commentId,\n      userId,\n      content: dto.content,\n    });\n\n    return this.commentMapper.toDto(comment);\n  }\n\n  async deleteComment(commentId: string, userId: string): Promise<void> {\n    await this.deleteCommentUseCase.execute({\n      commentId,\n      userId,\n    });\n  }\n\n  async addReaction(\n    commentId: string,\n    dto: AddCommentReactionDto,\n    userId: string,\n  ): Promise<ReactionToggleResponseDto> {\n    await this.addReactionUseCase.execute({\n      commentId,\n      userId,\n      reactionType: dto.reactionType,\n    });\n\n    // Get updated reaction counts (this would be implemented in repository)\n    return {\n      commentId,\n      reactionType: dto.reactionType,\n      added: true,\n      newCount: 1, // This should be fetched from repository\n    };\n  }\n\n  async removeReaction(\n    commentId: string,\n    reactionType: string,\n    userId: string,\n  ): Promise<ReactionToggleResponseDto> {\n    await this.removeReactionUseCase.execute({\n      commentId,\n      userId,\n      reactionType,\n    });\n\n    return {\n      commentId,\n      reactionType,\n      added: false,\n      newCount: 0, // This should be fetched from repository\n    };\n  }\n\n  async toggleReaction(\n    commentId: string,\n    dto: AddCommentReactionDto,\n    userId: string,\n  ): Promise<ReactionToggleResponseDto> {\n    // Implementation would check if reaction exists, then add or remove\n    // For now, just delegate to addReaction\n    return this.addReaction(commentId, dto, userId);\n  }\n\n  async getCommentsByAuthor(\n    authorId: string,\n    dto: GetCommentsDto,\n    userId?: string,\n  ): Promise<CommentPaginationDto> {\n    // This would require a new use case for getting comments by author\n    throw new Error('Not implemented yet');\n  }\n}\n\n@Injectable()\nexport class CommentMapperImpl implements CommentMapper {\n  toDto(\n    entity: CommentEntity,\n    options?: {\n      includeAuthor?: boolean;\n      includeReactions?: boolean;\n      includeReplyCount?: boolean;\n      userReaction?: string | null;\n    },\n  ): CommentResponseDto {\n    return {\n      id: entity.id,\n      content: entity.content,\n      authorId: entity.authorId,\n      postId: entity.postId,\n      parentId: entity.parentId,\n      isReply: !!entity.parentId,\n      createdAt: entity.createdAt,\n      updatedAt: entity.updatedAt,\n      ...(options?.includeAuthor && { author: undefined }), // Would be populated with user data\n      ...(options?.includeReactions && { reactions: {} }), // Would be populated with reaction counts\n      ...(options?.includeReplyCount && { replyCount: 0 }), // Would be populated with reply count\n      ...(options?.userReaction !== undefined && {\n        userReaction: options.userReaction,\n      }),\n    };\n  }\n\n  toDtoArray(\n    entities: CommentEntity[],\n    options?: {\n      includeAuthor?: boolean;\n      includeReactions?: boolean;\n      includeReplyCount?: boolean;\n      userReactions?: Map<string, string | null>;\n    },\n  ): CommentResponseDto[] {\n    return entities.map((entity) =>\n      this.toDto(entity, {\n        ...options,\n        userReaction: options?.userReactions?.get(entity.id),\n      }),\n    );\n  }\n\n  toPaginationDto(\n    entities: CommentEntity[],\n    total: number,\n    page: number,\n    limit: number,\n    options?: {\n      includeAuthor?: boolean;\n      includeReactions?: boolean;\n      includeReplyCount?: boolean;\n      userReactions?: Map<string, string | null>;\n    },\n  ): CommentPaginationDto {\n    const totalPages = Math.ceil(total / limit);\n    const items = this.toDtoArray(entities, options);\n\n    return {\n      items,\n      pagination: {\n        page,\n        limit,\n        totalCount: total,\n        totalPages,\n        hasNext: page < totalPages,\n        hasPrev: page > 1,\n      },\n    };\n  }\n\n  toCommentWithRepliesDto(\n    comment: CommentEntity,\n    replies: {\n      items: CommentEntity[];\n      total: number;\n      page: number;\n      limit: number;\n      totalPages: number;\n    },\n    options?: {\n      includeAuthor?: boolean;\n      includeReactions?: boolean;\n      userReaction?: string | null;\n      userRepliesReactions?: Map<string, string | null>;\n    },\n  ): CommentWithRepliesDto {\n    const commentDto = this.toDto(comment, options);\n    const repliesDto = this.toDtoArray(replies.items, {\n      ...options,\n      userReactions: options?.userRepliesReactions,\n    });\n\n    return {\n      ...commentDto,\n      replies: {\n        items: repliesDto,\n        total: replies.total,\n        page: replies.page,\n        limit: replies.limit,\n        totalPages: replies.totalPages,\n        hasNext: replies.page < replies.totalPages,\n        hasPrev: replies.page > 1,\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\dto\\comment.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\interfaces\\comment-application.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\add-reaction.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\create-comment.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Inject' is defined but never used.","line":1,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { CommentDomainService } from '../../domain/services/comment-domain.service';\nimport { CommentEntity } from '../../domain/comment.entity';\n\nexport interface CreateCommentCommand {\n  content: string;\n  authorId: string;\n  postId: string;\n  parentId?: string;\n}\n\n@Injectable()\nexport class CreateCommentUseCase {\n  constructor(private readonly commentDomainService: CommentDomainService) {}\n\n  async execute(command: CreateCommentCommand): Promise<CommentEntity> {\n    return await this.commentDomainService.createComment(\n      command.content,\n      command.authorId,\n      command.postId,\n      command.parentId,\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\delete-comment.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\get-comment-by-id.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\get-comments-by-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\get-replies.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\remove-reaction.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\application\\use-cases\\update-comment.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\comments.module.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CommentApplicationService' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Module } from '@nestjs/common';\nimport { PrismaModule } from '../../database/prisma.module';\n\n// Domain Services\nimport { CommentDomainService } from './domain/services/comment-domain.service';\n\n// Application Layer\nimport { CommentApplicationService } from './application/interfaces/comment-application.interface';\nimport {\n  CommentApplicationServiceImpl,\n  CommentMapperImpl,\n} from './application/comment-application.service';\n\n// Use Cases\nimport { CreateCommentUseCase } from './application/use-cases/create-comment.use-case';\nimport { GetCommentsByPostUseCase } from './application/use-cases/get-comments-by-post.use-case';\nimport { GetCommentByIdUseCase } from './application/use-cases/get-comment-by-id.use-case';\nimport { UpdateCommentUseCase } from './application/use-cases/update-comment.use-case';\nimport { DeleteCommentUseCase } from './application/use-cases/delete-comment.use-case';\nimport { AddReactionUseCase } from './application/use-cases/add-reaction.use-case';\nimport { RemoveReactionUseCase } from './application/use-cases/remove-reaction.use-case';\nimport { GetRepliesUseCase } from './application/use-cases/get-replies.use-case';\n\n// Infrastructure\nimport { PrismaCommentRepository } from './infrastructure/repositories/prisma-comment.repository';\n\n// Presentation\nimport { CommentsController } from './presentation/comments.controller';\n\n@Module({\n  imports: [PrismaModule],\n  controllers: [CommentsController],\n  providers: [\n    // Domain Services\n    CommentDomainService,\n\n    // Application Services\n    {\n      provide: 'CommentApplicationService',\n      useClass: CommentApplicationServiceImpl,\n    },\n    {\n      provide: 'CommentMapper',\n      useClass: CommentMapperImpl,\n    },\n\n    // Use Cases\n    CreateCommentUseCase,\n    GetCommentsByPostUseCase,\n    GetCommentByIdUseCase,\n    UpdateCommentUseCase,\n    DeleteCommentUseCase,\n    AddReactionUseCase,\n    RemoveReactionUseCase,\n    GetRepliesUseCase,\n\n    // Repository\n    {\n      provide: 'COMMENT_REPOSITORY',\n      useClass: PrismaCommentRepository,\n    },\n  ],\n  exports: ['CommentApplicationService'],\n})\nexport class CommentsModule {}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\comment.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CommentDepthLimitException' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'maxDepth' is assigned a value but never used.","line":187,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":187,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":230,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":230,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._content on an `any` value.","line":232,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":232,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._authorId on an `any` value.","line":233,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":233,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._postId on an `any` value.","line":234,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":234,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._parentId on an `any` value.","line":235,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":235,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._createdAt on an `any` value.","line":236,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":236,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._updatedAt on an `any` value.","line":237,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":237,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._isDeleted on an `any` value.","line":238,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":238,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":239,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":239,"endColumn":19}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Entity } from '../../../shared/domain/entity.base';\nimport { randomUUID } from 'crypto';\nimport {\n  CommentCreatedEvent,\n  CommentUpdatedEvent,\n  CommentDeletedEvent,\n  CommentReactionAddedEvent,\n  CommentReactionRemovedEvent,\n} from './comment.events';\nimport {\n  InvalidCommentException,\n  CommentContentException,\n  CommentDepthLimitException,\n} from './comment.exceptions';\n\nexport enum ReactionType {\n  LIKE = 'like',\n  LOVE = 'love',\n  LAUGH = 'laugh',\n  ANGRY = 'angry',\n  SAD = 'sad',\n}\n\nexport interface CommentProps {\n  id?: string;\n  content: string;\n  authorId: string;\n  postId: string;\n  parentId?: string;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport class CommentEntity extends Entity<string> {\n  private _content: string;\n  private _authorId: string;\n  private _postId: string;\n  private _parentId?: string;\n  private _createdAt: Date;\n  private _updatedAt: Date;\n  private _isDeleted: boolean = false;\n\n  constructor(props: CommentProps) {\n    super(props.id || randomUUID());\n    this._content = props.content;\n    this._authorId = props.authorId;\n    this._postId = props.postId;\n    this._parentId = props.parentId;\n    this._createdAt = props.createdAt || new Date();\n    this._updatedAt = props.updatedAt || new Date();\n\n    this.validate();\n    this.addDomainEvent(\n      new CommentCreatedEvent({\n        id: this.id,\n        content: this._content,\n        authorId: this._authorId,\n        postId: this._postId,\n        parentId: this._parentId,\n        createdAt: this._createdAt,\n        updatedAt: this._updatedAt,\n      }),\n    );\n  }\n\n  // Getters\n  get content(): string {\n    return this._content;\n  }\n\n  get authorId(): string {\n    return this._authorId;\n  }\n\n  get postId(): string {\n    return this._postId;\n  }\n\n  get parentId(): string | undefined {\n    return this._parentId;\n  }\n\n  get createdAt(): Date {\n    return this._createdAt;\n  }\n\n  get updatedAt(): Date {\n    return this._updatedAt;\n  }\n\n  get isDeleted(): boolean {\n    return this._isDeleted;\n  }\n\n  get isReply(): boolean {\n    return !!this._parentId;\n  }\n\n  // Business methods\n  public updateContent(newContent: string, userId: string): void {\n    if (this._authorId !== userId) {\n      throw new InvalidCommentException(\n        'Only comment author can update content',\n      );\n    }\n\n    if (this._isDeleted) {\n      throw new InvalidCommentException('Cannot update deleted comment');\n    }\n\n    this.validateContent(newContent);\n\n    const oldContent = this._content;\n    this._content = newContent.trim();\n    this._updatedAt = new Date();\n\n    this.addDomainEvent(\n      new CommentUpdatedEvent(\n        {\n          id: this.id,\n          content: this._content,\n          authorId: this._authorId,\n          postId: this._postId,\n          parentId: this._parentId,\n          createdAt: this._createdAt,\n          updatedAt: this._updatedAt,\n        },\n        { oldContent, newContent: this._content },\n      ),\n    );\n  }\n\n  public delete(userId: string, isAuthorOrAdmin: boolean = false): void {\n    if (!isAuthorOrAdmin && this._authorId !== userId) {\n      throw new InvalidCommentException(\n        'Only comment author or admin can delete comment',\n      );\n    }\n\n    if (this._isDeleted) {\n      throw new InvalidCommentException('Comment is already deleted');\n    }\n\n    this._isDeleted = true;\n    this._updatedAt = new Date();\n\n    this.addDomainEvent(\n      new CommentDeletedEvent({\n        id: this.id,\n        content: this._content,\n        authorId: this._authorId,\n        postId: this._postId,\n        parentId: this._parentId,\n        createdAt: this._createdAt,\n        updatedAt: this._updatedAt,\n      }),\n    );\n  }\n\n  public addReaction(userId: string, reactionType: ReactionType): void {\n    if (this._isDeleted) {\n      throw new InvalidCommentException(\n        'Cannot add reaction to deleted comment',\n      );\n    }\n\n    this.addDomainEvent(\n      new CommentReactionAddedEvent(this.id, userId, reactionType),\n    );\n  }\n\n  public removeReaction(userId: string, reactionType: ReactionType): void {\n    this.addDomainEvent(\n      new CommentReactionRemovedEvent(this.id, userId, reactionType),\n    );\n  }\n\n  // Static factory methods\n  public static create(\n    props: Omit<CommentProps, 'id' | 'createdAt' | 'updatedAt'>,\n  ): CommentEntity {\n    return new CommentEntity(props);\n  }\n\n  public static createReply(\n    props: Omit<CommentProps, 'id' | 'createdAt' | 'updatedAt'>,\n    maxDepth: number = 3,\n  ): CommentEntity {\n    if (!props.parentId) {\n      throw new InvalidCommentException('Reply must have a parent comment');\n    }\n\n    // Note: Depth validation should be done by domain service with repository access\n    return new CommentEntity(props);\n  }\n\n  public static update(\n    existingComment: CommentEntity,\n    updateProps: { content?: string },\n  ): CommentEntity {\n    const updatedEntity = new CommentEntity({\n      id: existingComment.id,\n      content: updateProps.content ?? existingComment.content,\n      authorId: existingComment.authorId,\n      postId: existingComment.postId,\n      parentId: existingComment.parentId,\n      createdAt: existingComment.createdAt,\n      updatedAt: new Date(),\n    });\n\n    updatedEntity.addDomainEvent(\n      new CommentUpdatedEvent(\n        {\n          id: updatedEntity.id,\n          content: updatedEntity.content,\n          authorId: updatedEntity.authorId,\n          postId: updatedEntity.postId,\n          parentId: updatedEntity.parentId,\n          createdAt: updatedEntity.createdAt,\n          updatedAt: updatedEntity.updatedAt,\n        },\n        { content: updateProps.content },\n      ),\n    );\n\n    return updatedEntity;\n  }\n\n  public static fromPersistence(props: CommentProps): CommentEntity {\n    const entity = Object.create(CommentEntity.prototype);\n    Entity.call(entity, props.id);\n    entity._content = props.content;\n    entity._authorId = props.authorId;\n    entity._postId = props.postId;\n    entity._parentId = props.parentId;\n    entity._createdAt = props.createdAt;\n    entity._updatedAt = props.updatedAt;\n    entity._isDeleted = false;\n    return entity;\n  }\n\n  public toPlainObject(): CommentProps {\n    return {\n      id: this.id,\n      content: this._content,\n      authorId: this._authorId,\n      postId: this._postId,\n      parentId: this._parentId,\n      createdAt: this._createdAt,\n      updatedAt: this._updatedAt,\n    };\n  }\n\n  private validate(): void {\n    if (!this._authorId || this._authorId.trim() === '') {\n      throw new InvalidCommentException('Author ID is required');\n    }\n\n    if (!this._postId || this._postId.trim() === '') {\n      throw new InvalidCommentException('Post ID is required');\n    }\n\n    this.validateContent(this._content);\n  }\n\n  private validateContent(content: string): void {\n    if (!content || content.trim() === '') {\n      throw new CommentContentException('Comment content cannot be empty');\n    }\n\n    if (content.trim().length < 1) {\n      throw new CommentContentException('Comment content is too short');\n    }\n\n    if (content.trim().length > 1000) {\n      throw new CommentContentException(\n        'Comment content is too long (max 1000 characters)',\n      );\n    }\n\n    // Additional content validation rules can be added here\n    const trimmedContent = content.trim();\n    if (trimmedContent !== content) {\n      // This is just a validation, the actual trimming is done in business methods\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\comment.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\comment.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\factories\\comment.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\repositories\\comment.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\domain\\services\\comment-domain.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\infrastructure\\repositories\\prisma-comment.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":13,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":13,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":13,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":13,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":14,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":14,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":14,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":14,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":15,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":15,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .authorId on an `any` value.","line":15,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":15,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":16,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":16,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postId on an `any` value.","line":16,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":16,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":17,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":17,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":17,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":17,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":18,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":18,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":18,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":18,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":19,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":19,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":19,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":19,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":252,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":252,"endColumn":16},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'hasUserReacted' has no 'await' expression.","line":306,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":306,"endColumn":23,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7471,7583],"text":"hasUserReacted(\n    commentId: string,\n    userId: string,\n    reactionType: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'commentId' is defined but never used.","line":307,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":307,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":308,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":308,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reactionType' is defined but never used.","line":309,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":309,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'commentId' is defined but never used.","line":317,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":317,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":318,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":318,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reactionType' is defined but never used.","line":319,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":319,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'commentId' is defined but never used.","line":326,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":326,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":327,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":327,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reactionType' is defined but never used.","line":328,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":328,"endColumn":17},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getReactionCounts' has no 'await' expression.","line":334,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":334,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8143,8218],"text":"getReactionCounts(commentId: string): Record<string, number>"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'commentId' is defined but never used.","line":334,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":334,"endColumn":36}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport { CommentRepository } from '../../domain/repositories/comment.repository';\nimport { CommentEntity } from '../../domain/comment.entity';\nimport { CommentFactory } from '../../domain/factories/comment.factory';\n\n@Injectable()\nexport class PrismaCommentRepository implements CommentRepository {\n  constructor(private readonly prisma: PrismaService) {}\n\n  private mapToEntity(prismaComment: any): CommentEntity {\n    return CommentFactory.fromPersistence({\n      id: prismaComment.id,\n      content: prismaComment.content,\n      authorId: prismaComment.authorId,\n      postId: prismaComment.postId,\n      parentId: prismaComment.parentId || undefined,\n      createdAt: prismaComment.createdAt,\n      updatedAt: prismaComment.updatedAt,\n    });\n  }\n\n  async save(comment: CommentEntity): Promise<CommentEntity> {\n    const data = {\n      id: comment.id,\n      content: comment.content,\n      authorId: comment.authorId,\n      postId: comment.postId,\n      parentId: comment.parentId,\n      createdAt: comment.createdAt,\n      updatedAt: comment.updatedAt,\n    };\n\n    const savedComment = await this.prisma.comment.upsert({\n      where: { id: comment.id },\n      update: data,\n      create: data,\n    });\n\n    return this.mapToEntity(savedComment);\n  }\n\n  async update(comment: CommentEntity): Promise<CommentEntity> {\n    const updatedComment = await this.prisma.comment.update({\n      where: { id: comment.id },\n      data: {\n        content: comment.content,\n        updatedAt: comment.updatedAt,\n      },\n    });\n\n    return this.mapToEntity(updatedComment);\n  }\n\n  async findById(id: string): Promise<CommentEntity | null> {\n    const comment = await this.prisma.comment.findUnique({\n      where: { id },\n    });\n\n    if (!comment) {\n      return null;\n    }\n\n    return this.mapToEntity(comment);\n  }\n\n  async findByPostId(\n    postId: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    items: CommentEntity[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  }> {\n    const skip = (page - 1) * limit;\n\n    const [comments, total] = await Promise.all([\n      this.prisma.comment.findMany({\n        where: {\n          postId,\n          parentId: null, // Top-level comments only\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit,\n      }),\n      this.prisma.comment.count({\n        where: {\n          postId,\n          parentId: null,\n        },\n      }),\n    ]);\n\n    const entities = comments.map((comment) => this.mapToEntity(comment));\n\n    return {\n      items: entities,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit),\n    };\n  }\n\n  async findRepliesByCommentId(\n    commentId: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    items: CommentEntity[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  }> {\n    const skip = (page - 1) * limit;\n\n    const [replies, total] = await Promise.all([\n      this.prisma.comment.findMany({\n        where: { parentId: commentId },\n        orderBy: { createdAt: 'asc' },\n        skip,\n        take: limit,\n      }),\n      this.prisma.comment.count({\n        where: { parentId: commentId },\n      }),\n    ]);\n\n    const entities = replies.map((comment) => this.mapToEntity(comment));\n\n    return {\n      items: entities,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit),\n    };\n  }\n\n  async findByAuthorId(\n    authorId: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    items: CommentEntity[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  }> {\n    const skip = (page - 1) * limit;\n\n    const [comments, total] = await Promise.all([\n      this.prisma.comment.findMany({\n        where: { authorId },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit,\n      }),\n      this.prisma.comment.count({\n        where: { authorId },\n      }),\n    ]);\n\n    const entities = comments.map((comment) => this.mapToEntity(comment));\n\n    return {\n      items: entities,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit),\n    };\n  }\n\n  async deleteById(id: string): Promise<void> {\n    await this.prisma.comment.delete({\n      where: { id },\n    });\n  }\n\n  async exists(id: string): Promise<boolean> {\n    const count = await this.prisma.comment.count({\n      where: { id },\n    });\n    return count > 0;\n  }\n\n  async countByPostId(postId: string): Promise<number> {\n    return this.prisma.comment.count({\n      where: { postId },\n    });\n  }\n\n  async countRepliesByCommentId(commentId: string): Promise<number> {\n    return this.prisma.comment.count({\n      where: { parentId: commentId },\n    });\n  }\n\n  async getCommentDepth(commentId: string): Promise<number> {\n    let depth = 0;\n    let currentComment = await this.prisma.comment.findUnique({\n      where: { id: commentId },\n      select: { parentId: true },\n    });\n\n    while (currentComment?.parentId) {\n      depth++;\n      currentComment = await this.prisma.comment.findUnique({\n        where: { id: currentComment.parentId },\n        select: { parentId: true },\n      });\n    }\n\n    return depth;\n  }\n\n  async findTopLevelCommentsByPostId(\n    postId: string,\n    page: number,\n    limit: number,\n    sortBy: 'newest' | 'oldest' | 'popular' = 'newest',\n  ): Promise<{\n    items: CommentEntity[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  }> {\n    const skip = (page - 1) * limit;\n\n    let orderBy: any = { createdAt: 'desc' };\n    if (sortBy === 'oldest') {\n      orderBy = { createdAt: 'asc' };\n    } else if (sortBy === 'popular') {\n      // This would require reaction counts in a separate table\n      orderBy = { createdAt: 'desc' }; // Fallback to newest for now\n    }\n\n    const [comments, total] = await Promise.all([\n      this.prisma.comment.findMany({\n        where: {\n          postId,\n          parentId: null,\n        },\n        orderBy,\n        skip,\n        take: limit,\n      }),\n      this.prisma.comment.count({\n        where: {\n          postId,\n          parentId: null,\n        },\n      }),\n    ]);\n\n    const entities = comments.map((comment) => this.mapToEntity(comment));\n\n    return {\n      items: entities,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit),\n    };\n  }\n\n  async findCommentThread(rootCommentId: string): Promise<CommentEntity[]> {\n    // This would be a recursive query to get all nested replies\n    const comments = await this.prisma.$queryRaw<any[]>`\n      WITH RECURSIVE comment_tree AS (\n        SELECT id, content, \"authorId\", \"postId\", \"parentId\", \"createdAt\", \"updatedAt\", 0 as depth\n        FROM \"Comment\"\n        WHERE id = ${rootCommentId}\n        \n        UNION ALL\n        \n        SELECT c.id, c.content, c.\"authorId\", c.\"postId\", c.\"parentId\", c.\"createdAt\", c.\"updatedAt\", ct.depth + 1\n        FROM \"Comment\" c\n        INNER JOIN comment_tree ct ON c.\"parentId\" = ct.id\n      )\n      SELECT * FROM comment_tree\n      ORDER BY depth, \"createdAt\" ASC\n    `;\n\n    return comments.map((comment) => this.mapToEntity(comment));\n  }\n\n  async softDelete(id: string): Promise<void> {\n    await this.prisma.comment.update({\n      where: { id },\n      data: {\n        content: '[deleted]',\n        updatedAt: new Date(),\n      },\n    });\n  }\n\n  async hasUserReacted(\n    commentId: string,\n    userId: string,\n    reactionType: string,\n  ): Promise<boolean> {\n    // TODO: Implement when CommentReaction table is added to schema\n    // For now, always return false\n    return false;\n  }\n\n  async addReaction(\n    commentId: string,\n    userId: string,\n    reactionType: string,\n  ): Promise<void> {\n    // TODO: Implement when CommentReaction table is added to schema\n    // For now, do nothing\n  }\n\n  async removeReaction(\n    commentId: string,\n    userId: string,\n    reactionType: string,\n  ): Promise<void> {\n    // TODO: Implement when CommentReaction table is added to schema\n    // For now, do nothing\n  }\n\n  async getReactionCounts(commentId: string): Promise<Record<string, number>> {\n    // TODO: Implement when CommentReaction table is added to schema\n    // For now, return empty counts\n    return {};\n  }\n\n  async deleteByPostId(postId: string): Promise<void> {\n    await this.prisma.comment.deleteMany({\n      where: { postId },\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\comments\\presentation\\comments.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\dto\\follow-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\dto\\follow.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\follow-application.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\interfaces\\external-services.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\interfaces\\tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\mappers\\follow.mapper.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserSummaryDto' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FollowEntity } from '../../domain/follow.entity';\nimport {\n  FollowResponseDto,\n  FollowersResponseDto,\n  FollowingResponseDto,\n  FollowStatusResponseDto,\n  UserSummaryDto,\n} from '../dto/follow-response.dto';\nimport {\n  FollowWithUsers,\n  FollowersResult,\n  FollowingResult,\n  FollowStatusResult,\n} from '../../domain/repositories/follow.repository';\n\nexport class FollowMapper {\n  static toResponseDto(entity: FollowEntity): FollowResponseDto {\n    return {\n      id: entity.id,\n      followerId: entity.followerId,\n      followingId: entity.followingId,\n      createdAt: entity.createdAt,\n      updatedAt: entity.updatedAt,\n    };\n  }\n\n  static toResponseDtoWithUsers(data: FollowWithUsers): FollowResponseDto {\n    return {\n      ...this.toResponseDto(data.follow),\n      follower: data.follower,\n      following: data.following,\n    };\n  }\n\n  static toFollowersResponseDto(result: FollowersResult): FollowersResponseDto {\n    return {\n      userId: result.userId,\n      totalFollowers: result.totalFollowers,\n      followers: result.followers,\n    };\n  }\n\n  static toFollowingResponseDto(result: FollowingResult): FollowingResponseDto {\n    return {\n      userId: result.userId,\n      totalFollowing: result.totalFollowing,\n      following: result.following,\n    };\n  }\n\n  static toFollowStatusResponseDto(\n    result: FollowStatusResult,\n  ): FollowStatusResponseDto {\n    return {\n      userId: result.userId,\n      targetUserId: result.targetUserId,\n      isFollowing: result.isFollowing,\n      followId: result.followId,\n    };\n  }\n\n  static toResponseDtoArray(entities: FollowEntity[]): FollowResponseDto[] {\n    return entities.map((entity) => this.toResponseDto(entity));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\follow-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\get-follow-status.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\get-followers.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\get-following.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\get-follows.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\application\\use-cases\\unfollow-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\factories\\follow.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\follow.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\follow.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\follow.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\repositories\\follow.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\domain\\services\\follow-domain.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\follow.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\infrastructure\\external-services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\infrastructure\\prisma-follow.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followerId on an `any` value.","line":90,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":90,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followingId on an `any` value.","line":91,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":91,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":94,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":94,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followerId on an `any` value.","line":113,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followingId on an `any` value.","line":114,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":117,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":117,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport {\n  FollowRepository,\n  FindFollowsOptions,\n  FollowWithUsers,\n  FollowersResult,\n  FollowingResult,\n  FollowStatusResult,\n} from '../domain/repositories/follow.repository';\nimport { FollowEntity } from '../domain/follow.entity';\nimport { FollowFactory } from '../domain/factories/follow.factory';\n\n@Injectable()\nexport class PrismaFollowRepository implements FollowRepository {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly followFactory: FollowFactory,\n  ) {}\n\n  async save(follow: FollowEntity): Promise<FollowEntity> {\n    const data = {\n      followerId: follow.followerId,\n      followingId: follow.followingId,\n    };\n\n    if (follow.id) {\n      // Update existing\n      const updated = await this.prisma.follow.update({\n        where: { id: follow.id },\n        data,\n      });\n\n      return this.followFactory.createFromPrimitive({\n        ...updated,\n        updatedAt: updated.createdAt, // Fallback since Prisma model might not have updatedAt\n      });\n    } else {\n      // Create new\n      const created = await this.prisma.follow.create({\n        data,\n      });\n\n      return this.followFactory.createFromPrimitive({\n        ...created,\n        updatedAt: created.createdAt,\n      });\n    }\n  }\n\n  async findById(id: string): Promise<FollowEntity | null> {\n    const follow = await this.prisma.follow.findUnique({\n      where: { id },\n    });\n\n    if (!follow) {\n      return null;\n    }\n\n    return this.followFactory.createFromPrimitive({\n      ...follow,\n      updatedAt: follow.createdAt,\n    });\n  }\n\n  async findByFollowerAndFollowing(\n    followerId: string,\n    followingId: string,\n  ): Promise<FollowEntity | null> {\n    const follow = await this.prisma.follow.findFirst({\n      where: {\n        followerId,\n        followingId,\n      },\n    });\n\n    if (!follow) {\n      return null;\n    }\n\n    return this.followFactory.createFromPrimitive({\n      ...follow,\n      updatedAt: follow.createdAt,\n    });\n  }\n\n  async findAll(options?: FindFollowsOptions): Promise<FollowEntity[]> {\n    const where: any = {};\n\n    if (options?.followerId) where.followerId = options.followerId;\n    if (options?.followingId) where.followingId = options.followingId;\n\n    const follows = await this.prisma.follow.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: options?.limit,\n      skip: options?.offset,\n    });\n\n    return follows.map((follow) =>\n      this.followFactory.createFromPrimitive({\n        ...follow,\n        updatedAt: follow.createdAt,\n      }),\n    );\n  }\n\n  async findAllWithUsers(\n    options?: FindFollowsOptions,\n  ): Promise<FollowWithUsers[]> {\n    const where: any = {};\n\n    if (options?.followerId) where.followerId = options.followerId;\n    if (options?.followingId) where.followingId = options.followingId;\n\n    const follows = await this.prisma.follow.findMany({\n      where,\n      include: {\n        follower: {\n          select: {\n            id: true,\n            username: true,\n            fullName: true,\n            avatar: true,\n            bio: true,\n          },\n        },\n        following: {\n          select: {\n            id: true,\n            username: true,\n            fullName: true,\n            avatar: true,\n            bio: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: options?.limit,\n      skip: options?.offset,\n    });\n\n    return follows.map((follow) => ({\n      follow: this.followFactory.createFromPrimitive({\n        id: follow.id,\n        followerId: follow.followerId,\n        followingId: follow.followingId,\n        createdAt: follow.createdAt,\n        updatedAt: follow.createdAt,\n      }),\n      follower: follow.follower,\n      following: follow.following,\n    }));\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.prisma.follow.delete({\n      where: { id },\n    });\n  }\n\n  async getFollowers(userId: string): Promise<FollowersResult> {\n    const followers = await this.prisma.follow.findMany({\n      where: { followingId: userId },\n      include: {\n        follower: {\n          select: {\n            id: true,\n            username: true,\n            fullName: true,\n            avatar: true,\n            bio: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return {\n      userId,\n      totalFollowers: followers.length,\n      followers: followers.map((f) => f.follower),\n    };\n  }\n\n  async getFollowing(userId: string): Promise<FollowingResult> {\n    const following = await this.prisma.follow.findMany({\n      where: { followerId: userId },\n      include: {\n        following: {\n          select: {\n            id: true,\n            username: true,\n            fullName: true,\n            avatar: true,\n            bio: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return {\n      userId,\n      totalFollowing: following.length,\n      following: following.map((f) => f.following),\n    };\n  }\n\n  async getFollowStatus(\n    userId: string,\n    targetUserId: string,\n  ): Promise<FollowStatusResult> {\n    const follow = await this.prisma.follow.findFirst({\n      where: {\n        followerId: userId,\n        followingId: targetUserId,\n      },\n    });\n\n    return {\n      userId,\n      targetUserId,\n      isFollowing: !!follow,\n      followId: follow?.id || null,\n    };\n  }\n\n  async countFollowers(userId: string): Promise<number> {\n    return this.prisma.follow.count({\n      where: { followingId: userId },\n    });\n  }\n\n  async countFollowing(userId: string): Promise<number> {\n    return this.prisma.follow.count({\n      where: { followerId: userId },\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\infrastructure\\queue-notification.service.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'createFollowNotification' has no 'await' expression.","line":6,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":6,"endColumn":33,"suggestions":[{"messageId":"removeAsync","fix":{"range":[226,363],"text":"createFollowNotification(data: {\n    followerId: string;\n    followingId: string;\n    followerUserName: string;\n  }): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { NotificationService } from '../application/interfaces/external-services.interface';\n\n@Injectable()\nexport class QueueNotificationService implements NotificationService {\n  async createFollowNotification(data: {\n    followerId: string;\n    followingId: string;\n    followerUserName: string;\n  }): Promise<void> {\n    try {\n      // Implementation would use notification queue or service\n      // For now, we'll just log it\n      console.log('Follow notification:', {\n        type: 'follow',\n        from: data.followerId,\n        to: data.followingId,\n        message: `${data.followerUserName} started following you`,\n      });\n    } catch (error) {\n      console.error('Failed to create follow notification:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\follow\\presentation\\follows.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\mailer\\dto\\createMailer.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\mailer\\dto\\sendMail.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\mailer\\mailer.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\mailer\\mailer.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\mailer\\mailer.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":24,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":24,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":27,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":27,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .host on an `any` value.","line":27,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":27,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":28,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":28,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .port on an `any` value.","line":28,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":28,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":29,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":29,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .secure on an `any` value.","line":29,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":29,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":31,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":31,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .auth on an `any` value.","line":31,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":32,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":32,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .auth on an `any` value.","line":32,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":32,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":34,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":34,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .tls on an `any` value.","line":34,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'success' is defined but never used.","line":37,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":48,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":48,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .from on an `any` value.","line":53,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .from on an `any` value.","line":53,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":63,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":63,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":68,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":68,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .messageId on an `any` value.","line":68,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":68,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":305,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":305,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":305,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":305,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":322,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":322,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":322,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":322,"endColumn":29}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/mailer/mailer.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport * as nodemailer from 'nodemailer';\nimport {\n  SendEmailDto,\n  SendWelcomeEmailDto,\n  SendPasswordResetDto,\n  SendFriendRequestDto,\n} from './dto/sendMail.dto';\nimport { CreateMailerDto } from './dto/createMailer.dto';\nimport { URLS } from '../../shared/constants/urls.constant';\n\n@Injectable()\nexport class MailerService {\n  private transporter: nodemailer.Transporter;\n  private readonly logger = new Logger(MailerService.name);\n\n  constructor(private configService: ConfigService) {\n    this.createTransporter();\n  }\n\n  private createTransporter() {\n    const mailConfig = this.configService.get('mail');\n\n    this.transporter = nodemailer.createTransport({\n      host: mailConfig.host,\n      port: mailConfig.port,\n      secure: mailConfig.secure,\n      auth: {\n        user: mailConfig.auth.user,\n        pass: mailConfig.auth.pass,\n      },\n      tls: mailConfig.tls,\n    });\n\n    this.transporter.verify((error, success) => {\n      if (error) {\n        this.logger.error('Email transporter verification failed:', error);\n      } else {\n        this.logger.log('Email transporter is ready to send emails');\n      }\n    });\n  }\n\n  async sendEmail(createMailerDto: CreateMailerDto) {\n    try {\n      const mailConfig = this.configService.get('mail');\n\n      const mailOptions = {\n        from:\n          createMailerDto.from ||\n          `${mailConfig.from.name} <${mailConfig.from.email}>`,\n        to: createMailerDto.to,\n        subject: createMailerDto.subject,\n        text: createMailerDto.text,\n        html: createMailerDto.html,\n        cc: createMailerDto.cc,\n        bcc: createMailerDto.bcc,\n        attachments: createMailerDto.attachments,\n      };\n\n      const result = await this.transporter.sendMail(mailOptions);\n\n      this.logger.log(`Email sent successfully to ${createMailerDto.to}`);\n      return {\n        success: true,\n        messageId: result.messageId,\n        message: 'Email sent successfully',\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to send email to ${createMailerDto.to}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  async sendSimpleEmail(sendEmailDto: SendEmailDto) {\n    return this.sendEmail({\n      to: sendEmailDto.to,\n      subject: sendEmailDto.subject,\n      text: sendEmailDto.text,\n      html: sendEmailDto.html,\n    });\n  }\n\n  async sendWelcomeEmail(welcomeEmailDto: SendWelcomeEmailDto) {\n    const { email, username, fullname } = welcomeEmailDto;\n\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <style>\n            .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }\n            .header { background-color: #4F46E5; color: white; padding: 20px; text-align: center; }\n            .content { padding: 20px; }\n            .button { background-color: #4F46E5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; }\n            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <div class=\"header\">\n              <h1>Welcome to Social Media Mini! 🎉</h1>\n            </div>\n            <div class=\"content\">\n              <h2>Hello ${fullname}!</h2>\n              <p>Welcome to our social media platform! We're excited to have you join our community.</p>\n              <p>Your username: <strong>@${username}</strong></p>\n              <p>You can now:</p>\n              <ul>\n                <li>Create and share posts</li>\n                <li>Connect with friends</li>\n                <li>Join conversations</li>\n                <li>Discover new content</li>\n              </ul>\n              <a href=\"${URLS.FRONT_END_WEB}/login\" class=\"button\" style=\"color:white\">Get Started</a>\n            </div>\n            <div class=\"footer\">\n              <p>Thanks for joining Social Media Mini!</p>\n              <p>If you have any questions, feel free to contact us.</p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n\n    return this.sendEmail({\n      to: email,\n      subject: 'Welcome to Social Media Mini! 🎉',\n      html,\n      text: `Welcome to Social Media Mini, ${fullname}! Your username is @${username}. Start connecting with friends and sharing your moments.`,\n    });\n  }\n\n  async sendPasswordResetEmail(passwordResetDto: SendPasswordResetDto) {\n    const { email, resetToken, username } = passwordResetDto;\n    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;\n\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <style>\n            .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }\n            .header { background-color: #DC2626; color: white; padding: 20px; text-align: center; }\n            .content { padding: 20px; }\n            .button { background-color: #DC2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; }\n            .warning { background-color: #FEF3C7; border: 1px solid #F59E0B; padding: 15px; border-radius: 5px; margin: 20px 0; }\n            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <div class=\"header\">\n              <h1>Password Reset Request 🔒</h1>\n            </div>\n            <div class=\"content\">\n              <h2>Hello @${username}!</h2>\n              <p>We received a request to reset your password for your Social Media Mini account.</p>\n              <p>Click the button below to reset your password:</p>\n              <a href=\"${resetUrl}\" class=\"button\">Reset Password</a>\n              <div class=\"warning\">\n                <strong>⚠️ Important:</strong>\n                <ul>\n                  <li>This link will expire in 1 hour</li>\n                  <li>If you didn't request this reset, please ignore this email</li>\n                  <li>Never share this link with anyone</li>\n                </ul>\n              </div>\n              <p>If the button doesn't work, copy and paste this link into your browser:</p>\n              <p style=\"word-break: break-all; color: #666;\">${resetUrl}</p>\n            </div>\n            <div class=\"footer\">\n              <p>This is an automated email from Social Media Mini.</p>\n              <p>If you need help, contact our support team.</p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n\n    return this.sendEmail({\n      to: email,\n      subject: 'Reset Your Password - Social Media Mini',\n      html,\n      text: `Password reset requested for @${username}. Reset link: ${resetUrl} (expires in 1 hour)`,\n    });\n  }\n\n  async sendFriendRequestEmail(friendRequestDto: SendFriendRequestDto) {\n    const { to, senderName, senderUsername, receiverName } = friendRequestDto;\n\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <style>\n            .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }\n            .header { background-color: #10B981; color: white; padding: 20px; text-align: center; }\n            .content { padding: 20px; }\n            .button { background-color: #10B981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; }\n            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <div class=\"header\">\n              <h1>New Friend Request! 👋</h1>\n            </div>\n            <div class=\"content\">\n              <h2>Hello ${receiverName}!</h2>\n              <p><strong>${senderName}</strong> (@${senderUsername}) sent you a friend request on Social Media Mini!</p>\n              <p>Connect with them to see their posts and stay in touch.</p>\n              <a href=\"${process.env.FRONTEND_URL}/friends/requests\" class=\"button\">View Friend Requests</a>\n            </div>\n            <div class=\"footer\">\n              <p>Social Media Mini - Connecting People</p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n\n    return this.sendEmail({\n      to,\n      subject: `${senderName} sent you a friend request!`,\n      html,\n      text: `${senderName} (@${senderUsername}) sent you a friend request on Social Media Mini! Check your notifications to respond.`,\n    });\n  }\n\n  async sendEmailVerification(\n    email: string,\n    username: string,\n    verificationToken: string,\n  ) {\n    const verificationUrl = `${URLS.FRONT_END_WEB_PRODUCTION}/verify-email/${verificationToken}`;\n\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <style>\n            .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }\n            .header { background-color: #7C3AED; color: white; padding: 20px; text-align: center; }\n            .content { padding: 20px; }\n            .button { background-color: #7C3AED; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; }\n            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <div class=\"header\">\n              <h1>Verify Your Email ✉️</h1>\n            </div>\n            <div class=\"content\">\n              <h2>Hello @${username}!</h2>\n              <p>Please verify your email address to complete your Social Media Mini registration.</p>\n              <a href=\"${verificationUrl}\" style=\"color: #ffffff;\" class=\"button\">Verify Email Address</a>\n              <p>If the button doesn't work, copy and paste this link:</p>\n              <p style=\"word-break: break-all; color: #666;\">${verificationUrl}</p>\n              <p><em>This verification link will expire in 24 hours.</em></p>\n            </div>\n            <div class=\"footer\">\n              <p>Welcome to Social Media Mini!</p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n\n    return this.sendEmail({\n      to: email,\n      subject: 'Verify Your Email - Social Media Mini',\n      html,\n      text: `Please verify your email for Social Media Mini: ${verificationUrl}`,\n    });\n  }\n\n  async sendBulkEmails(emails: CreateMailerDto[]) {\n    const results: Array<\n      | {\n          email: string;\n          success: true;\n          result: { success: boolean; messageId: any; message: string };\n        }\n      | { email: string; success: false; error: string }\n    > = [];\n\n    for (const emailData of emails) {\n      try {\n        const result = await this.sendEmail(emailData);\n        results.push({ email: emailData.to, success: true, result });\n\n        // Add delay to avoid rate limiting\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      } catch (error) {\n        results.push({\n          email: emailData.to,\n          success: false,\n          error: error.message,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async testConnection() {\n    try {\n      await this.transporter.verify();\n      return { success: true, message: 'Email service is working correctly' };\n    } catch (error) {\n      this.logger.error('Email connection test failed:', error);\n      return {\n        success: false,\n        message: 'Email service connection failed',\n        error: error.message,\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\conversation.use-cases.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'conversation' is assigned a value but never used.","line":205,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":205,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { Conversation, ConversationType } from '../domain/conversation.entity';\nimport { ConversationRepository } from './repositories.interface';\nimport {\n  ConversationId,\n  UserId,\n  ConversationParticipant,\n  ConversationTitle,\n} from '../domain/value-objects';\nimport { ParticipantRole, ConversationStatus } from '../domain/enums';\n\nexport interface CreateConversationRequest {\n  participants: string[];\n  type: ConversationType;\n  metadata?: {\n    title?: string;\n    description?: string;\n  };\n  initiatorId: string;\n}\n\nexport interface GetConversationsRequest {\n  userId: string;\n  limit?: number;\n  offset?: number;\n}\n\n@Injectable()\nexport class ConversationUseCases {\n  constructor(\n    private readonly conversationRepository: ConversationRepository,\n  ) {}\n\n  async createConversation(\n    request: CreateConversationRequest,\n  ): Promise<Conversation> {\n    // Validate participants include the initiator\n    if (!request.participants.includes(request.initiatorId)) {\n      request.participants.push(request.initiatorId);\n    }\n\n    // For private conversations, ensure only 2 participants\n    if (\n      request.type === ConversationType.PRIVATE &&\n      request.participants.length !== 2\n    ) {\n      throw new Error('Private conversations must have exactly 2 participants');\n    }\n\n    // Check if private conversation already exists\n    if (request.type === ConversationType.PRIVATE) {\n      const existingConversation =\n        await this.conversationRepository.existsWithParticipants(\n          request.participants,\n        );\n\n      if (existingConversation) {\n        throw new Error(\n          'Private conversation already exists between these users',\n        );\n      }\n    }\n\n    // Create conversation participants\n    const participants = request.participants.map((participantId) =>\n      ConversationParticipant.create(\n        UserId.fromString(participantId),\n        new Date(),\n        participantId === request.initiatorId\n          ? ParticipantRole.ADMIN\n          : ParticipantRole.MEMBER,\n      ),\n    );\n\n    const now = new Date();\n    const conversationProps = {\n      id: ConversationId.create(),\n      participants,\n      type: request.type,\n      createdBy: UserId.fromString(request.initiatorId),\n      createdAt: now,\n      lastActivityAt: now,\n      status: ConversationStatus.ACTIVE,\n      ...(request.metadata?.title && {\n        title: ConversationTitle.create(request.metadata.title),\n      }),\n    };\n\n    // Create conversation\n    const conversation = Conversation.create(conversationProps);\n\n    await this.conversationRepository.create(conversation);\n    return conversation;\n  }\n\n  async getConversationById(\n    conversationId: string,\n    userId: string,\n  ): Promise<Conversation> {\n    const conversation =\n      await this.conversationRepository.findById(conversationId);\n\n    if (!conversation) {\n      throw new NotFoundException('Conversation not found');\n    }\n\n    if (!conversation.isParticipant(UserId.fromString(userId))) {\n      throw new ForbiddenException(\n        'User is not a participant in this conversation',\n      );\n    }\n\n    return conversation;\n  }\n\n  async getUserConversations(\n    request: GetConversationsRequest,\n  ): Promise<Conversation[]> {\n    return this.conversationRepository.findByUserId(request.userId);\n  }\n\n  async addParticipantToConversation(\n    conversationId: string,\n    participantId: string,\n    requesterId: string,\n  ): Promise<void> {\n    const conversation = await this.getConversationById(\n      conversationId,\n      requesterId,\n    );\n\n    if (conversation.isPrivateConversation()) {\n      throw new Error('Cannot add participants to private conversations');\n    }\n\n    const updatedConversation = conversation.addParticipant(\n      UserId.fromString(participantId),\n      new Date(),\n      ParticipantRole.MEMBER,\n    );\n    await this.conversationRepository.update(updatedConversation);\n  }\n\n  async removeParticipantFromConversation(\n    conversationId: string,\n    participantId: string,\n    requesterId: string,\n  ): Promise<void> {\n    const conversation = await this.getConversationById(\n      conversationId,\n      requesterId,\n    );\n\n    if (conversation.isPrivateConversation()) {\n      throw new Error('Cannot remove participants from private conversations');\n    }\n\n    // Users can only remove themselves or be removed by group admins (future feature)\n    if (participantId !== requesterId) {\n      throw new ForbiddenException(\n        'Can only remove yourself from group conversations',\n      );\n    }\n\n    const updatedConversation = conversation.removeParticipant(\n      UserId.fromString(participantId),\n      new Date(),\n    );\n    await this.conversationRepository.update(updatedConversation);\n  }\n\n  async updateConversationMetadata(\n    conversationId: string,\n    metadata: { title?: string; description?: string },\n    requesterId: string,\n  ): Promise<void> {\n    const conversation = await this.getConversationById(\n      conversationId,\n      requesterId,\n    );\n\n    let updatedConversation = conversation;\n\n    // Update title if provided\n    if (metadata.title !== undefined) {\n      updatedConversation = updatedConversation.updateTitle(\n        ConversationTitle.create(metadata.title),\n      );\n    }\n\n    // Note: description is not currently supported in ConversationSettings\n    // If needed, it could be added to ConversationSettings interface\n\n    await this.conversationRepository.update(updatedConversation);\n  }\n\n  async deleteConversation(\n    conversationId: string,\n    requesterId: string,\n  ): Promise<void> {\n    const conversation = await this.getConversationById(\n      conversationId,\n      requesterId,\n    );\n\n    // For now, any participant can delete the conversation\n    // In future, might want to add admin checks for group conversations\n    await this.conversationRepository.delete(conversationId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\message.use-cases.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Conversation' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":312,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":312,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":326,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":326,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":357,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":357,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":375,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":375,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":393,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":393,"endColumn":50}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { Message, MessageType, MessageContent } from '../domain/message.entity';\nimport { MessageStatus } from '../domain/enums';\nimport { Conversation } from '../domain/conversation.entity';\nimport {\n  MessageRepository,\n  ConversationRepository,\n} from './repositories.interface';\nimport {\n  ConversationId,\n  MessageId,\n  UserId,\n  ConversationParticipant,\n} from '../domain/value-objects';\nimport { WebSocketGatewayService } from '../../../shared/websocket';\nimport { WebSocketEvent, WebSocketNamespace } from '../../../shared/websocket';\n\nexport interface SendMessageRequest {\n  conversationId: string;\n  senderId: string;\n  content: MessageContent;\n  type: MessageType;\n}\n\nexport interface GetMessagesRequest {\n  conversationId: string;\n  userId: string;\n  limit?: number;\n  offset?: number;\n}\n\nexport interface MarkMessagesAsReadRequest {\n  conversationId: string;\n  userId: string;\n  messageIds?: string[]; // If not provided, mark all unread messages as read\n}\n\n@Injectable()\nexport class MessageUseCases {\n  constructor(\n    private readonly messageRepository: MessageRepository,\n    private readonly conversationRepository: ConversationRepository,\n    private readonly webSocketGateway: WebSocketGatewayService,\n  ) {}\n\n  async sendMessage(request: SendMessageRequest): Promise<Message> {\n    // Verify user is participant in conversation\n    const conversation = await this.conversationRepository.findById(\n      request.conversationId,\n    );\n\n    if (!conversation) {\n      throw new NotFoundException('Conversation not found');\n    }\n\n    if (!conversation.isParticipant(UserId.fromString(request.senderId))) {\n      throw new ForbiddenException(\n        'User is not a participant in this conversation',\n      );\n    }\n\n    // Create message\n    const message = Message.create({\n      id: MessageId.create(),\n      conversationId: ConversationId.fromString(request.conversationId),\n      senderId: UserId.fromString(request.senderId),\n      content: request.content,\n      type: request.type,\n      status: MessageStatus.PENDING,\n      sentAt: new Date(),\n    });\n\n    // Save message\n    await this.messageRepository.create(message);\n\n    // Emit real-time message to all participants\n    await this.emitMessageToParticipants(\n      message,\n      this.extractParticipantIds(conversation.participants),\n    );\n\n    // Emit conversation updated event\n    await this.emitConversationUpdate(\n      request.conversationId,\n      this.extractParticipantIds(conversation.participants),\n    );\n\n    return message;\n  }\n\n  async getMessages(request: GetMessagesRequest): Promise<Message[]> {\n    // Verify user is participant in conversation\n    const conversation = await this.conversationRepository.findById(\n      request.conversationId,\n    );\n\n    if (!conversation) {\n      throw new NotFoundException('Conversation not found');\n    }\n\n    if (!conversation.isParticipant(UserId.fromString(request.userId))) {\n      throw new ForbiddenException(\n        'User is not a participant in this conversation',\n      );\n    }\n\n    return this.messageRepository.findByConversationId(\n      request.conversationId,\n      request.limit,\n      request.offset,\n    );\n  }\n\n  async getMessageById(messageId: string, userId: string): Promise<Message> {\n    const message = await this.messageRepository.findById(messageId);\n\n    if (!message) {\n      throw new NotFoundException('Message not found');\n    }\n\n    // Verify user is participant in the conversation\n    const conversation = await this.conversationRepository.findById(\n      message.conversationId.value,\n    );\n\n    if (\n      !conversation ||\n      !conversation.isParticipant(UserId.fromString(userId))\n    ) {\n      throw new ForbiddenException(\n        'User is not a participant in this conversation',\n      );\n    }\n\n    return message;\n  }\n\n  async markMessagesAsRead(request: MarkMessagesAsReadRequest): Promise<void> {\n    // Verify user is participant in conversation\n    const conversation = await this.conversationRepository.findById(\n      request.conversationId,\n    );\n\n    if (!conversation) {\n      throw new NotFoundException('Conversation not found');\n    }\n\n    if (!conversation.isParticipant(UserId.fromString(request.userId))) {\n      throw new ForbiddenException(\n        'User is not a participant in this conversation',\n      );\n    }\n\n    let messageIds = request.messageIds;\n\n    // If no specific messages provided, get all unread messages\n    if (!messageIds || messageIds.length === 0) {\n      const unreadMessages =\n        await this.messageRepository.findUnreadByConversationId(\n          request.conversationId,\n          request.userId,\n        );\n      messageIds = unreadMessages.map((msg) => msg.id.value);\n    }\n\n    if (messageIds && messageIds.length > 0) {\n      await this.messageRepository.markAsRead(messageIds, request.userId);\n\n      // Emit read receipts to other participants\n      await this.emitReadReceipts(\n        messageIds,\n        request.userId,\n        this.extractParticipantIds(conversation.participants),\n      );\n    }\n  }\n\n  async markMessagesAsDelivered(messageIds: string[]): Promise<void> {\n    if (messageIds.length > 0) {\n      await this.messageRepository.markAsDelivered(messageIds);\n    }\n  }\n\n  async editMessage(\n    messageId: string,\n    newContent: MessageContent,\n    userId: string,\n  ): Promise<Message> {\n    const message = await this.getMessageById(messageId, userId);\n\n    // Only sender can edit their message\n    if (!message.senderId || message.senderId.value !== userId) {\n      throw new ForbiddenException('Can only edit your own messages');\n    }\n\n    // Cannot edit deleted messages\n    if (message.isDeleted()) {\n      throw new Error('Cannot edit deleted messages');\n    }\n\n    message.editContent(newContent);\n    await this.messageRepository.update(message);\n\n    // Emit message updated event\n    const conversation = await this.conversationRepository.findById(\n      message.conversationId.value,\n    );\n    if (conversation) {\n      await this.emitMessageUpdate(\n        message,\n        this.extractParticipantIds(conversation.participants),\n      );\n    }\n\n    return message;\n  }\n\n  async deleteMessage(messageId: string, userId: string): Promise<void> {\n    const message = await this.getMessageById(messageId, userId);\n\n    // Only sender can delete their message\n    if (!message.senderId || message.senderId.value !== userId) {\n      throw new ForbiddenException('Can only delete your own messages');\n    }\n\n    message.deleteMessage();\n    await this.messageRepository.update(message);\n\n    // Emit message deleted event\n    const conversation = await this.conversationRepository.findById(\n      message.conversationId.value,\n    );\n    if (conversation) {\n      await this.emitMessageDelete(\n        message,\n        this.extractParticipantIds(conversation.participants),\n      );\n    }\n  }\n\n  async addReactionToMessage(\n    messageId: string,\n    emoji: string,\n    userId: string,\n  ): Promise<void> {\n    const message = await this.getMessageById(messageId, userId);\n\n    message.addReaction(emoji, UserId.fromString(userId));\n    await this.messageRepository.update(message);\n\n    // Emit reaction added event\n    const conversation = await this.conversationRepository.findById(\n      message.conversationId.value,\n    );\n    if (conversation) {\n      await this.emitReactionUpdate(\n        message,\n        this.extractParticipantIds(conversation.participants),\n      );\n    }\n  }\n\n  async removeReactionFromMessage(\n    messageId: string,\n    emoji: string,\n    userId: string,\n  ): Promise<void> {\n    const message = await this.getMessageById(messageId, userId);\n\n    message.removeReaction(emoji, UserId.fromString(userId));\n    await this.messageRepository.update(message);\n\n    // Emit reaction removed event\n    const conversation = await this.conversationRepository.findById(\n      message.conversationId.value,\n    );\n    if (conversation) {\n      await this.emitReactionUpdate(\n        message,\n        this.extractParticipantIds(conversation.participants),\n      );\n    }\n  }\n\n  async searchMessages(\n    query: string,\n    userId: string,\n    limit?: number,\n  ): Promise<Message[]> {\n    return this.messageRepository.searchMessages(query, userId, limit);\n  }\n\n  async getUserUnreadMessages(userId: string): Promise<Message[]> {\n    return this.messageRepository.findUnreadByUserId(userId);\n  }\n\n  // Real-time event emission methods\n  private async emitMessageToParticipants(\n    message: Message,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      if (participantId !== message.senderId?.value) {\n        await this.webSocketGateway.emitToUser(\n          participantId,\n          WebSocketEvent.MESSAGE_RECEIVED,\n          {\n            message: this.serializeMessage(message),\n            conversationId: message.conversationId.value,\n          },\n          WebSocketNamespace.MESSAGING,\n        );\n      }\n    }\n\n    // Emit to sender as well for confirmation\n    if (message.senderId) {\n      await this.webSocketGateway.emitToUser(\n        message.senderId.value,\n        WebSocketEvent.MESSAGE_SENT,\n        {\n          message: this.serializeMessage(message),\n          conversationId: message.conversationId.value,\n        },\n        WebSocketNamespace.MESSAGING,\n      );\n    }\n  }\n\n  private async emitConversationUpdate(\n    conversationId: string,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      await this.webSocketGateway.emitToUser(\n        participantId,\n        WebSocketEvent.CONVERSATION_UPDATED,\n        { conversationId },\n        WebSocketNamespace.MESSAGING,\n      );\n    }\n  }\n\n  private async emitMessageUpdate(\n    message: Message,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      await this.webSocketGateway.emitToUser(\n        participantId,\n        WebSocketEvent.MESSAGE_RECEIVED, // Reuse for updates\n        {\n          message: this.serializeMessage(message),\n          conversationId: message.conversationId.value,\n          isUpdate: true,\n        },\n        WebSocketNamespace.MESSAGING,\n      );\n    }\n  }\n\n  private async emitMessageDelete(\n    message: Message,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      await this.webSocketGateway.emitToUser(\n        participantId,\n        WebSocketEvent.MESSAGE_RECEIVED, // Reuse for deletions\n        {\n          message: this.serializeMessage(message),\n          conversationId: message.conversationId.value,\n          isDeleted: true,\n        },\n        WebSocketNamespace.MESSAGING,\n      );\n    }\n  }\n\n  private async emitReactionUpdate(\n    message: Message,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      await this.webSocketGateway.emitToUser(\n        participantId,\n        WebSocketEvent.MESSAGE_RECEIVED, // Reuse for reactions\n        {\n          message: this.serializeMessage(message),\n          conversationId: message.conversationId.value,\n          isReactionUpdate: true,\n        },\n        WebSocketNamespace.MESSAGING,\n      );\n    }\n  }\n\n  private async emitReadReceipts(\n    messageIds: string[],\n    userId: string,\n    participants: string[],\n  ): Promise<void> {\n    for (const participantId of participants) {\n      if (participantId !== userId) {\n        await this.webSocketGateway.emitToUser(\n          participantId,\n          WebSocketEvent.MESSAGE_READ,\n          {\n            messageIds,\n            readByUserId: userId,\n            readAt: new Date(),\n          },\n          WebSocketNamespace.MESSAGING,\n        );\n      }\n    }\n  }\n\n  private extractParticipantIds(\n    participants: ConversationParticipant[],\n  ): string[] {\n    return participants.map((participant) => participant.userId.value);\n  }\n\n  private serializeMessage(message: Message): any {\n    return {\n      id: message.id,\n      conversationId: message.conversationId,\n      senderId: message.senderId,\n      content: message.content,\n      type: message.type,\n      status: message.status,\n      createdAt: message.createdAt,\n      updatedAt: message.updatedAt,\n      deliveredAt: message.deliveredAt,\n      readAt: message.readAt,\n      metadata: message.metadata,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\messaging-application.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\repositories.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\services\\messaging-application.services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\use-cases\\conversation.use-cases.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\application\\use-cases\\message.use-cases.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\conversation.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":296,"column":16,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":296,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7436,7443],"text":"ParticipantRole.ADMIN"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ConversationId,\n  UserId,\n  ConversationTitle,\n  ConversationParticipant,\n} from './value-objects';\nimport { ConversationType, ConversationStatus, ParticipantRole } from './enums';\nimport { Entity } from '../../../shared/domain';\n\nexport { ConversationType };\n\nexport interface ConversationProps {\n  id: ConversationId;\n  type: ConversationType;\n  participants: ConversationParticipant[];\n  title?: ConversationTitle;\n  description?: string;\n  avatarUrl?: string;\n  createdBy: UserId;\n  createdAt: Date;\n  updatedAt: Date;\n  lastMessageAt?: Date;\n  lastActivityAt: Date;\n  status: ConversationStatus;\n  settings?: ConversationSettings;\n  unreadCount?: number;\n}\n\nexport interface ConversationSettings {\n  isEncrypted?: boolean;\n  allowNotifications?: boolean;\n  muteUntil?: Date;\n  autoDeleteMessages?: boolean;\n  autoDeleteDuration?: number; // in hours\n  maxParticipants?: number;\n  allowInviteLinks?: boolean;\n  adminOnlyMessaging?: boolean;\n}\n\nexport class Conversation extends Entity<ConversationId> {\n  private constructor(private readonly props: ConversationProps) {\n    super(props.id);\n  }\n\n  public static create(\n    props: Omit<ConversationProps, 'updatedAt'>,\n  ): Conversation {\n    return new Conversation({\n      ...props,\n      updatedAt: props.createdAt,\n    });\n  }\n\n  public static fromPrimitives(data: {\n    id: string;\n    type: string;\n    participants: Array<{\n      userId: string;\n      joinedAt: string;\n      role?: string;\n      leftAt?: string;\n    }>;\n    title?: string;\n    createdBy: string;\n    createdAt: string;\n    updatedAt: string;\n    lastMessageAt?: string;\n    isArchived?: boolean;\n    settings?: ConversationSettings;\n  }): Conversation {\n    return new Conversation({\n      id: ConversationId.fromString(data.id),\n      type: data.type as ConversationType,\n      participants: data.participants.map((p) =>\n        ConversationParticipant.create(\n          UserId.fromString(p.userId),\n          new Date(p.joinedAt),\n          (p.role as ParticipantRole) || ParticipantRole.MEMBER,\n          p.leftAt ? new Date(p.leftAt) : undefined,\n        ),\n      ),\n      title: data.title ? ConversationTitle.create(data.title) : undefined,\n      createdBy: UserId.fromString(data.createdBy),\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      lastMessageAt: data.lastMessageAt\n        ? new Date(data.lastMessageAt)\n        : undefined,\n      lastActivityAt: new Date(),\n      status: ConversationStatus.ACTIVE,\n      settings: data.settings,\n    });\n  }\n\n  // Getters\n  public get id(): ConversationId {\n    return this.props.id;\n  }\n\n  public get type(): ConversationType {\n    return this.props.type;\n  }\n\n  public get participants(): ConversationParticipant[] {\n    return [...this.props.participants];\n  }\n\n  public get activeParticipants(): ConversationParticipant[] {\n    return this.props.participants.filter((p) => p.isActive);\n  }\n\n  public get title(): ConversationTitle | undefined {\n    return this.props.title;\n  }\n\n  public get createdBy(): UserId {\n    return this.props.createdBy;\n  }\n\n  public get createdAt(): Date {\n    return this.props.createdAt;\n  }\n\n  public get updatedAt(): Date {\n    return this.props.updatedAt;\n  }\n\n  public get lastMessageAt(): Date | undefined {\n    return this.props.lastMessageAt;\n  }\n\n  public get lastActivityAt(): Date {\n    return this.props.lastActivityAt;\n  }\n\n  public get status(): ConversationStatus {\n    return this.props.status;\n  }\n\n  public get description(): string | undefined {\n    return this.props.description;\n  }\n\n  public get avatarUrl(): string | undefined {\n    return this.props.avatarUrl;\n  }\n\n  public get unreadCount(): number {\n    return this.props.unreadCount || 0;\n  }\n\n  public isActive(): boolean {\n    return this.props.status === ConversationStatus.ACTIVE;\n  }\n\n  public isArchived(): boolean {\n    return this.props.status === ConversationStatus.ARCHIVED;\n  }\n\n  public isDeleted(): boolean {\n    return this.props.status === ConversationStatus.DELETED;\n  }\n\n  public isMuted(): boolean {\n    return this.props.status === ConversationStatus.MUTED;\n  }\n\n  public get settings(): ConversationSettings | undefined {\n    return this.props.settings;\n  }\n\n  // Business Logic Methods\n  public isParticipant(userId: UserId): boolean {\n    return this.activeParticipants.some((p) => p.userId.equals(userId));\n  }\n\n  public getParticipant(userId: UserId): ConversationParticipant | undefined {\n    return this.props.participants.find((p) => p.userId.equals(userId));\n  }\n\n  public addParticipant(\n    userId: UserId,\n    joinedAt: Date,\n    role: string = 'member',\n  ): Conversation {\n    if (this.isParticipant(userId)) {\n      throw new Error('User is already a participant');\n    }\n\n    const newParticipant = ConversationParticipant.create(\n      userId,\n      joinedAt,\n      role as ParticipantRole,\n    );\n    const updatedParticipants = [...this.props.participants, newParticipant];\n\n    return new Conversation({\n      ...this.props,\n      participants: updatedParticipants,\n      updatedAt: new Date(),\n    });\n  }\n\n  public removeParticipant(userId: UserId, leftAt: Date): Conversation {\n    const participantIndex = this.props.participants.findIndex((p) =>\n      p.userId.equals(userId),\n    );\n\n    if (participantIndex === -1) {\n      throw new Error('User is not a participant');\n    }\n\n    const participant = this.props.participants[participantIndex];\n    const updatedParticipant = participant.leave(leftAt);\n\n    const updatedParticipants = [...this.props.participants];\n    updatedParticipants[participantIndex] = updatedParticipant;\n\n    return new Conversation({\n      ...this.props,\n      participants: updatedParticipants,\n      updatedAt: new Date(),\n    });\n  }\n\n  public updateTitle(title: ConversationTitle): Conversation {\n    if (this.type === ConversationType.PRIVATE) {\n      throw new Error('Cannot set title for private conversations');\n    }\n\n    return new Conversation({\n      ...this.props,\n      title,\n      updatedAt: new Date(),\n    });\n  }\n\n  public updateSettings(settings: Partial<ConversationSettings>): Conversation {\n    return new Conversation({\n      ...this.props,\n      settings: {\n        ...this.props.settings,\n        ...settings,\n      },\n      updatedAt: new Date(),\n    });\n  }\n\n  public archive(): Conversation {\n    return new Conversation({\n      ...this.props,\n      status: ConversationStatus.ARCHIVED,\n      updatedAt: new Date(),\n    });\n  }\n\n  public unarchive(): Conversation {\n    return new Conversation({\n      ...this.props,\n      status: ConversationStatus.ACTIVE,\n      updatedAt: new Date(),\n    });\n  }\n\n  public updateLastMessageAt(lastMessageAt: Date): Conversation {\n    return new Conversation({\n      ...this.props,\n      lastMessageAt,\n      updatedAt: new Date(),\n    });\n  }\n\n  public isPrivateConversation(): boolean {\n    return this.props.type === ConversationType.PRIVATE;\n  }\n\n  public updateMetadata(metadata: Partial<ConversationSettings>): Conversation {\n    return this.updateSettings(metadata);\n  }\n\n  public canUserPerformAction(\n    userId: UserId,\n    action: 'read' | 'write' | 'admin',\n  ): boolean {\n    const participant = this.getParticipant(userId);\n\n    if (!participant || !participant.isActive) {\n      return false;\n    }\n\n    switch (action) {\n      case 'read':\n      case 'write':\n        return true;\n      case 'admin':\n        return participant.role === 'admin' || this.createdBy.equals(userId);\n      default:\n        return false;\n    }\n  }\n\n  // Serialization\n  public toPrimitives(): {\n    id: string;\n    type: string;\n    participants: Array<{\n      userId: string;\n      joinedAt: string;\n      role: string;\n      leftAt?: string;\n    }>;\n    title?: string;\n    createdBy: string;\n    createdAt: string;\n    updatedAt: string;\n    lastMessageAt?: string;\n    isArchived: boolean;\n    settings?: ConversationSettings;\n  } {\n    return {\n      id: this.props.id.value,\n      type: this.props.type,\n      participants: this.props.participants.map((p) => ({\n        userId: p.userId.value,\n        joinedAt: p.joinedAt.toISOString(),\n        role: p.role,\n        leftAt: p.leftAt?.toISOString(),\n      })),\n      title: this.props.title?.value,\n      createdBy: this.props.createdBy.value,\n      createdAt: this.props.createdAt.toISOString(),\n      updatedAt: this.props.updatedAt.toISOString(),\n      lastMessageAt: this.props.lastMessageAt?.toISOString(),\n      isArchived: this.props.status === ConversationStatus.ARCHIVED,\n      settings: this.props.settings,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\enums.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\events\\conversation.events.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConversationStatus' is defined but never used.","line":3,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DomainEvent } from '../../../../shared/domain';\nimport { ConversationId, UserId, ConversationTitle } from '../value-objects';\nimport { ConversationType, ConversationStatus } from '../enums';\n\nexport interface ConversationCreatedEventData {\n  conversationId: ConversationId;\n  type: ConversationType;\n  createdBy: UserId;\n  participants: UserId[];\n  title?: ConversationTitle;\n  createdAt: Date;\n}\n\nexport class ConversationCreatedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationCreatedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationCreated';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationUpdatedEventData {\n  conversationId: ConversationId;\n  updatedBy: UserId;\n  participants: UserId[];\n  changes: {\n    title?: ConversationTitle;\n    description?: string;\n    avatarUrl?: string;\n    settings?: any;\n  };\n  updatedAt: Date;\n}\n\nexport class ConversationUpdatedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationUpdatedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationUpdated';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationDeletedEventData {\n  conversationId: ConversationId;\n  deletedBy: UserId;\n  participants: UserId[];\n  deletedAt: Date;\n}\n\nexport class ConversationDeletedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationDeletedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationDeleted';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationArchivedEventData {\n  conversationId: ConversationId;\n  archivedBy: UserId;\n  participants: UserId[];\n  archivedAt: Date;\n}\n\nexport class ConversationArchivedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationArchivedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationArchived';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationUnarchivedEventData {\n  conversationId: ConversationId;\n  unarchivedBy: UserId;\n  participants: UserId[];\n  unarchivedAt: Date;\n}\n\nexport class ConversationUnarchivedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationUnarchivedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationUnarchived';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationMutedEventData {\n  conversationId: ConversationId;\n  mutedBy: UserId;\n  muteUntil?: Date;\n  mutedAt: Date;\n}\n\nexport class ConversationMutedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationMutedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationMuted';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface ConversationUnmutedEventData {\n  conversationId: ConversationId;\n  unmutedBy: UserId;\n  unmutedAt: Date;\n}\n\nexport class ConversationUnmutedEvent extends DomainEvent {\n  constructor(public readonly data: ConversationUnmutedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'ConversationUnmuted';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\events\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\events\\message.events.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MessageStatus' is defined but never used.","line":8,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DomainEvent } from '../../../../shared/domain';\nimport {\n  MessageId,\n  ConversationId,\n  UserId,\n  MessageContent,\n} from '../value-objects';\nimport { MessageType, MessageStatus } from '../enums';\n\nexport interface MessageSentEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  senderId: UserId;\n  content: MessageContent;\n  type: MessageType;\n  sentAt: Date;\n  participants: UserId[];\n}\n\nexport class MessageSentEvent extends DomainEvent {\n  constructor(public readonly data: MessageSentEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageSent';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageDeliveredEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  senderId: UserId;\n  deliveredAt: Date;\n  participants: UserId[];\n}\n\nexport class MessageDeliveredEvent extends DomainEvent {\n  constructor(public readonly data: MessageDeliveredEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageDelivered';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageReadEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  readBy: UserId;\n  readAt: Date;\n  participants: UserId[];\n}\n\nexport class MessageReadEvent extends DomainEvent {\n  constructor(public readonly data: MessageReadEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageRead';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageEditedEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  editedBy: UserId;\n  oldContent: MessageContent;\n  newContent: MessageContent;\n  editedAt: Date;\n}\n\nexport class MessageEditedEvent extends DomainEvent {\n  constructor(public readonly data: MessageEditedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageEdited';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageDeletedEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  deletedBy: UserId;\n  deletedAt: Date;\n}\n\nexport class MessageDeletedEvent extends DomainEvent {\n  constructor(public readonly data: MessageDeletedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageDeleted';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageReactionAddedEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  userId: UserId;\n  reactionType: string;\n  addedAt: Date;\n}\n\nexport class MessageReactionAddedEvent extends DomainEvent {\n  constructor(public readonly data: MessageReactionAddedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageReactionAdded';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageReactionRemovedEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  userId: UserId;\n  reactionType: string;\n  removedAt: Date;\n}\n\nexport class MessageReactionRemovedEvent extends DomainEvent {\n  constructor(public readonly data: MessageReactionRemovedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageReactionRemoved';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n\nexport interface MessageFailedEventData {\n  messageId: MessageId;\n  conversationId: ConversationId;\n  senderId: UserId;\n  error: string;\n  failedAt: Date;\n}\n\nexport class MessageFailedEvent extends DomainEvent {\n  constructor(public readonly data: MessageFailedEventData) {\n    super();\n  }\n\n  get eventType(): string {\n    return 'MessageFailed';\n  }\n\n  protected getEventData() {\n    return this.data;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\events\\participant.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\message.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of type `Map<any, any>` from function with return type `Map<string, UserId[]>`.","line":325,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturnAssignment","endLine":325,"endColumn":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ConversationId,\n  MessageId,\n  UserId,\n  MessageContent,\n  MessageAttachment,\n  MessageMetadata,\n  MessageLocation,\n} from './value-objects';\nimport { MessageType, MessageStatus } from './enums';\nimport { Entity } from '../../../shared/domain';\n\nexport { MessageType, MessageContent };\n\nexport interface MessageProps {\n  id: MessageId;\n  conversationId: ConversationId;\n  senderId: UserId | null; // null for system messages\n  content: MessageContent;\n  type: MessageType;\n  status: MessageStatus;\n  sentAt: Date;\n  deliveredAt?: Date;\n  readAt?: Date;\n  editedAt?: Date;\n  deletedAt?: Date;\n  attachments?: MessageAttachment[];\n  location?: MessageLocation;\n  replyToMessageId?: MessageId;\n  metadata?: MessageMetadata;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport class Message extends Entity<MessageId> {\n  private constructor(private readonly props: MessageProps) {\n    super(props.id);\n  }\n\n  public static create(\n    props: Omit<\n      MessageProps,\n      | 'deliveredAt'\n      | 'readAt'\n      | 'editedAt'\n      | 'deletedAt'\n      | 'metadata'\n      | 'createdAt'\n      | 'updatedAt'\n    >,\n  ): Message {\n    const now = new Date();\n\n    // Validate content for text messages\n    if (props.type === MessageType.TEXT && !props.content) {\n      throw new Error('Text messages must have content');\n    }\n\n    // Validate attachment for media messages\n    const mediaTypes = [\n      MessageType.IMAGE,\n      MessageType.VIDEO,\n      MessageType.AUDIO,\n      MessageType.DOCUMENT,\n      MessageType.GIF,\n      MessageType.STICKER,\n    ];\n    if (\n      mediaTypes.includes(props.type) &&\n      (!props.attachments || props.attachments.length === 0)\n    ) {\n      throw new Error('Media messages must have at least one attachment');\n    }\n\n    // Validate location for location messages\n    if (props.type === MessageType.LOCATION && !props.location) {\n      throw new Error('Location messages must have location data');\n    }\n\n    // System messages can have null sender\n    if (props.type !== MessageType.SYSTEM && !props.senderId) {\n      throw new Error('Non-system messages must have a sender');\n    }\n\n    const messageProps: MessageProps = {\n      ...props,\n      metadata: MessageMetadata.create(),\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    return new Message(messageProps);\n  }\n\n  public static fromPrimitives(data: {\n    id: string;\n    conversationId: string;\n    senderId: string | null;\n    content: string;\n    type: string;\n    status: string;\n    sentAt: string;\n    deliveredAt?: string;\n    readAt?: string;\n    editedAt?: string;\n    attachmentUrl?: string;\n    replyToMessageId?: string;\n    reactions?: Array<{ emoji: string; userIds: string[] }>;\n  }): Message {\n    // Convert reactions to Map\n    const reactionsMap = new Map<string, UserId[]>();\n    if (data.reactions) {\n      data.reactions.forEach((r) => {\n        reactionsMap.set(\n          r.emoji,\n          r.userIds.map((id) => UserId.fromString(id)),\n        );\n      });\n    }\n\n    const metadata = MessageMetadata.create(\n      data.deliveredAt ? new Date(data.deliveredAt) : undefined,\n      data.readAt ? new Date(data.readAt) : undefined,\n      data.editedAt ? new Date(data.editedAt) : undefined,\n      data.replyToMessageId\n        ? MessageId.fromString(data.replyToMessageId)\n        : undefined,\n      reactionsMap,\n    );\n\n    return new Message({\n      id: MessageId.fromString(data.id),\n      conversationId: ConversationId.fromString(data.conversationId),\n      senderId: data.senderId ? UserId.fromString(data.senderId) : null,\n      content: MessageContent.create(data.content),\n      type: data.type as MessageType,\n      status: data.status as MessageStatus,\n      sentAt: new Date(data.sentAt),\n      deliveredAt: data.deliveredAt ? new Date(data.deliveredAt) : undefined,\n      readAt: data.readAt ? new Date(data.readAt) : undefined,\n      editedAt: data.editedAt ? new Date(data.editedAt) : undefined,\n      attachments: data.attachmentUrl\n        ? [{ url: data.attachmentUrl } as MessageAttachment]\n        : undefined,\n      replyToMessageId: data.replyToMessageId\n        ? MessageId.fromString(data.replyToMessageId)\n        : undefined,\n      metadata,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    });\n  }\n\n  // Getters\n  public get id(): MessageId {\n    return this.props.id;\n  }\n\n  public get conversationId(): ConversationId {\n    return this.props.conversationId;\n  }\n\n  public get senderId(): UserId | null {\n    return this.props.senderId;\n  }\n\n  public get content(): MessageContent {\n    return this.props.content;\n  }\n\n  public get type(): MessageType {\n    return this.props.type;\n  }\n\n  public get status(): MessageStatus {\n    return this.props.status;\n  }\n\n  public get sentAt(): Date {\n    return this.props.sentAt;\n  }\n\n  public get deliveredAt(): Date | undefined {\n    return this.props.deliveredAt;\n  }\n\n  public get readAt(): Date | undefined {\n    return this.props.readAt;\n  }\n\n  public get editedAt(): Date | undefined {\n    return this.props.editedAt;\n  }\n\n  public get attachmentUrl(): string | undefined {\n    return this.props.attachments?.[0]?.url;\n  }\n\n  public get replyToMessageId(): MessageId | undefined {\n    return this.props.replyToMessageId;\n  }\n\n  public get metadata(): MessageMetadata | undefined {\n    return this.props.metadata;\n  }\n\n  public get isSystemMessage(): boolean {\n    return (\n      this.props.type === MessageType.SYSTEM || this.props.senderId === null\n    );\n  }\n\n  public get isDelivered(): boolean {\n    return !!this.props.deliveredAt;\n  }\n\n  public get isRead(): boolean {\n    return !!this.props.readAt;\n  }\n\n  public get isEdited(): boolean {\n    return !!this.props.editedAt;\n  }\n\n  public get hasAttachment(): boolean {\n    return !!this.props.attachments && this.props.attachments.length > 0;\n  }\n\n  public get isReply(): boolean {\n    return !!this.props.replyToMessageId;\n  }\n\n  // Business Logic Methods\n  public markAsDelivered(deliveredAt: Date): Message {\n    if (this.props.status === MessageStatus.FAILED) {\n      throw new Error('Cannot mark failed message as delivered');\n    }\n\n    if (this.props.deliveredAt) {\n      return this; // Already delivered\n    }\n\n    return new Message({\n      ...this.props,\n      status: MessageStatus.DELIVERED,\n      deliveredAt,\n      metadata: this.props.metadata?.markAsDelivered(deliveredAt),\n    });\n  }\n\n  public markAsRead(readAt: Date): Message {\n    if (this.props.status === MessageStatus.FAILED) {\n      throw new Error('Cannot mark failed message as read');\n    }\n\n    if (!this.props.deliveredAt) {\n      throw new Error('Cannot mark message as read before it is delivered');\n    }\n\n    if (this.props.readAt) {\n      return this; // Already read\n    }\n\n    return new Message({\n      ...this.props,\n      status: MessageStatus.READ,\n      readAt,\n      metadata: this.props.metadata?.markAsRead(readAt),\n    });\n  }\n\n  public markAsFailed(): Message {\n    return new Message({\n      ...this.props,\n      status: MessageStatus.FAILED,\n    });\n  }\n\n  public edit(newContent: string, editedAt: Date): Message {\n    if (this.props.type === MessageType.SYSTEM) {\n      throw new Error('Cannot edit system messages');\n    }\n\n    if (this.props.sentAt && editedAt < this.props.sentAt) {\n      throw new Error('Edit timestamp cannot be before send timestamp');\n    }\n\n    return new Message({\n      ...this.props,\n      content: MessageContent.create(newContent),\n      editedAt,\n      metadata: this.props.metadata?.markAsEdited(editedAt),\n    });\n  }\n\n  public addReaction(emoji: string, userId: UserId): Message {\n    if (!emoji || emoji.trim().length === 0) {\n      throw new Error('Emoji cannot be empty');\n    }\n\n    const updatedMetadata =\n      this.props.metadata?.addReaction(emoji, userId) ||\n      MessageMetadata.create().addReaction(emoji, userId);\n\n    return new Message({\n      ...this.props,\n      metadata: updatedMetadata,\n    });\n  }\n\n  public removeReaction(emoji: string, userId: UserId): Message {\n    if (!this.props.metadata) {\n      return this; // No reactions to remove\n    }\n\n    const updatedMetadata = this.props.metadata.removeReaction(emoji, userId);\n\n    return new Message({\n      ...this.props,\n      metadata: updatedMetadata,\n    });\n  }\n\n  public getReactions(): Map<string, UserId[]> {\n    return this.props.metadata?.reactions || new Map();\n  }\n\n  public getUserReactions(userId: UserId): string[] {\n    const reactions = this.getReactions();\n    const userReactions: string[] = [];\n\n    reactions.forEach((userIds, emoji) => {\n      if (userIds.some((id) => id.equals(userId))) {\n        userReactions.push(emoji);\n      }\n    });\n\n    return userReactions;\n  }\n\n  public getReactionCount(emoji: string): number {\n    const reactions = this.getReactions();\n    return reactions.get(emoji)?.length || 0;\n  }\n\n  public canBeEditedBy(userId: UserId): boolean {\n    if (this.props.type === MessageType.SYSTEM) {\n      return false;\n    }\n\n    return this.props.senderId?.equals(userId) || false;\n  }\n\n  public canBeDeletedBy(userId: UserId): boolean {\n    return this.canBeEditedBy(userId);\n  }\n\n  public isEditableWithinTimeLimit(timeLimitHours: number = 24): boolean {\n    if (!this.props.sentAt) {\n      return false;\n    }\n\n    const timeLimitMs = timeLimitHours * 60 * 60 * 1000;\n    const now = new Date();\n    return now.getTime() - this.props.sentAt.getTime() <= timeLimitMs;\n  }\n\n  public get createdAt(): Date {\n    return this.props.sentAt;\n  }\n\n  public get updatedAt(): Date {\n    return this.props.editedAt || this.props.sentAt;\n  }\n\n  public isDeleted(): boolean {\n    return (\n      this.props.status === MessageStatus.FAILED &&\n      this.props.content.value === '[deleted]'\n    );\n  }\n\n  public editContent(newContent: MessageContent): Message {\n    if (!this.canBeEditedBy(this.props.senderId!)) {\n      throw new Error('Message cannot be edited');\n    }\n\n    if (this.isDeleted()) {\n      throw new Error('Cannot edit a deleted message');\n    }\n\n    return new Message({\n      ...this.props,\n      content: newContent,\n      editedAt: new Date(),\n    });\n  }\n\n  public deleteMessage(): Message {\n    return new Message({\n      ...this.props,\n      content: MessageContent.create('[deleted]'),\n      status: MessageStatus.FAILED,\n      editedAt: new Date(),\n    });\n  }\n\n  // Serialization\n  public toPrimitives(): {\n    id: string;\n    conversationId: string;\n    senderId: string | null;\n    content: string;\n    type: string;\n    status: string;\n    sentAt: string;\n    deliveredAt?: string;\n    readAt?: string;\n    editedAt?: string;\n    attachmentUrl?: string;\n    replyToMessageId?: string;\n    reactions: Array<{ emoji: string; userIds: string[] }>;\n  } {\n    const reactions = this.getReactions();\n    const reactionsArray = Array.from(reactions.entries()).map(\n      ([emoji, userIds]) => ({\n        emoji,\n        userIds: userIds.map((id) => id.value),\n      }),\n    );\n\n    return {\n      id: this.props.id.value,\n      conversationId: this.props.conversationId.value,\n      senderId: this.props.senderId?.value || null,\n      content: this.props.content.value,\n      type: this.props.type,\n      status: this.props.status,\n      sentAt: this.props.sentAt.toISOString(),\n      deliveredAt: this.props.deliveredAt?.toISOString(),\n      readAt: this.props.readAt?.toISOString(),\n      editedAt: this.props.editedAt?.toISOString(),\n      attachmentUrl: this.attachmentUrl,\n      replyToMessageId: this.props.replyToMessageId?.value,\n      reactions: reactionsArray,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\repositories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\services.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":333,"column":27,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":333,"endColumn":55,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[8698,8705],"text":"ParticipantRole.ADMIN"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { Conversation } from './conversation.entity';\nimport { Message } from './message.entity';\nimport {\n  ConversationId,\n  MessageId,\n  UserId,\n  ConversationParticipant,\n  ConversationTitle,\n  MessageContent,\n} from './value-objects';\nimport {\n  ConversationType,\n  MessageType,\n  MessageStatus,\n  ConversationStatus,\n  ParticipantRole,\n} from './enums';\n\n@Injectable()\nexport class ConversationDomainService {\n  public createPrivateConversation(\n    participantIds: [UserId, UserId],\n    createdBy: UserId,\n  ): Conversation {\n    if (participantIds.length !== 2) {\n      throw new Error('Private conversation must have exactly 2 participants');\n    }\n\n    if (participantIds[0].equals(participantIds[1])) {\n      throw new Error('Cannot create conversation with the same user');\n    }\n\n    const conversationId = ConversationId.create();\n    const participants = participantIds.map((userId) =>\n      ConversationParticipant.create(userId, new Date()),\n    );\n\n    return Conversation.create({\n      id: conversationId,\n      type: ConversationType.PRIVATE,\n      participants,\n      createdBy,\n      createdAt: new Date(),\n      lastActivityAt: new Date(),\n      status: ConversationStatus.ACTIVE,\n    });\n  }\n\n  public createGroupConversation(\n    title: string,\n    participantIds: UserId[],\n    createdBy: UserId,\n  ): Conversation {\n    if (participantIds.length < 2) {\n      throw new Error('Group conversation must have at least 2 participants');\n    }\n\n    if (participantIds.length > 100) {\n      throw new Error(\n        'Group conversation cannot have more than 100 participants',\n      );\n    }\n\n    // Ensure creator is included in participants\n    if (!participantIds.some((id) => id.equals(createdBy))) {\n      participantIds.push(createdBy);\n    }\n\n    const conversationId = ConversationId.create();\n    const participants = participantIds.map((userId) =>\n      ConversationParticipant.create(\n        userId,\n        new Date(),\n        userId.equals(createdBy)\n          ? ParticipantRole.ADMIN\n          : ParticipantRole.MEMBER,\n      ),\n    );\n\n    return Conversation.create({\n      id: conversationId,\n      type: ConversationType.GROUP,\n      title: ConversationTitle.create(title),\n      participants,\n      createdBy,\n      createdAt: new Date(),\n      lastActivityAt: new Date(),\n      status: ConversationStatus.ACTIVE,\n    });\n  }\n\n  public addParticipant(\n    conversation: Conversation,\n    userId: UserId,\n    addedBy: UserId,\n  ): Conversation {\n    if (conversation.type === ConversationType.PRIVATE) {\n      throw new Error('Cannot add participants to private conversation');\n    }\n\n    if (!conversation.isParticipant(addedBy)) {\n      throw new Error('Only participants can add new members');\n    }\n\n    if (conversation.isParticipant(userId)) {\n      throw new Error('User is already a participant');\n    }\n\n    return conversation.addParticipant(userId, new Date());\n  }\n\n  public removeParticipant(\n    conversation: Conversation,\n    userId: UserId,\n    removedBy: UserId,\n  ): Conversation {\n    if (conversation.type === ConversationType.PRIVATE) {\n      throw new Error('Cannot remove participants from private conversation');\n    }\n\n    if (!conversation.isParticipant(removedBy) && !removedBy.equals(userId)) {\n      throw new Error('Only participants can remove members');\n    }\n\n    if (!conversation.isParticipant(userId)) {\n      throw new Error('User is not a participant');\n    }\n\n    return conversation.removeParticipant(userId, new Date());\n  }\n\n  public canUserAccessConversation(\n    conversation: Conversation,\n    userId: UserId,\n  ): boolean {\n    return conversation.isParticipant(userId);\n  }\n\n  public canUserSendMessage(\n    conversation: Conversation,\n    userId: UserId,\n  ): boolean {\n    return conversation.isParticipant(userId);\n  }\n}\n\n@Injectable()\nexport class MessageDomainService {\n  public createTextMessage(\n    conversationId: ConversationId,\n    senderId: UserId,\n    content: string,\n  ): Message {\n    if (!content || content.trim().length === 0) {\n      throw new Error('Message content cannot be empty');\n    }\n\n    return Message.create({\n      id: MessageId.create(),\n      conversationId,\n      senderId,\n      type: MessageType.TEXT,\n      content: MessageContent.create(content),\n      status: MessageStatus.PENDING,\n      sentAt: new Date(),\n    });\n  }\n\n  public createMediaMessage(\n    conversationId: ConversationId,\n    senderId: UserId,\n    type: MessageType,\n    attachmentUrl: string,\n    content?: string,\n  ): Message {\n    if (\n      ![\n        MessageType.IMAGE,\n        MessageType.VIDEO,\n        MessageType.AUDIO,\n        MessageType.DOCUMENT,\n      ].includes(type)\n    ) {\n      throw new Error('Invalid media message type');\n    }\n\n    if (!attachmentUrl) {\n      throw new Error('Attachment URL is required for media messages');\n    }\n\n    return Message.create({\n      id: MessageId.create(),\n      conversationId,\n      senderId,\n      type,\n      content: MessageContent.create(content || ''),\n      attachments: attachmentUrl ? [{ url: attachmentUrl } as any] : undefined,\n      status: MessageStatus.PENDING,\n      sentAt: new Date(),\n    });\n  }\n\n  public createSystemMessage(\n    conversationId: ConversationId,\n    content: string,\n  ): Message {\n    return Message.create({\n      id: MessageId.create(),\n      conversationId,\n      senderId: null, // System messages don't have a sender\n      type: MessageType.SYSTEM,\n      content: MessageContent.create(content),\n      status: MessageStatus.SENT,\n      sentAt: new Date(),\n    });\n  }\n\n  public createReplyMessage(\n    conversationId: ConversationId,\n    senderId: UserId,\n    content: string,\n    replyToMessageId: MessageId,\n  ): Message {\n    if (!content || content.trim().length === 0) {\n      throw new Error('Reply content cannot be empty');\n    }\n\n    return Message.create({\n      id: MessageId.create(),\n      conversationId,\n      senderId,\n      type: MessageType.TEXT,\n      content: MessageContent.create(content),\n      status: MessageStatus.PENDING,\n      sentAt: new Date(),\n      replyToMessageId,\n    });\n  }\n\n  public markAsDelivered(message: Message, deliveredAt: Date): Message {\n    if (message.status === MessageStatus.FAILED) {\n      throw new Error('Cannot mark failed message as delivered');\n    }\n\n    return message.markAsDelivered(deliveredAt);\n  }\n\n  public markAsRead(message: Message, readAt: Date): Message {\n    if (message.status === MessageStatus.FAILED) {\n      throw new Error('Cannot mark failed message as read');\n    }\n\n    if (!message.deliveredAt) {\n      throw new Error('Cannot mark message as read before it is delivered');\n    }\n\n    return message.markAsRead(readAt);\n  }\n\n  public editMessage(\n    message: Message,\n    newContent: string,\n    editedAt: Date,\n  ): Message {\n    if (message.type === MessageType.SYSTEM) {\n      throw new Error('Cannot edit system messages');\n    }\n\n    if (!newContent || newContent.trim().length === 0) {\n      throw new Error('Edited content cannot be empty');\n    }\n\n    if (message.sentAt && editedAt < message.sentAt) {\n      throw new Error('Edit timestamp cannot be before send timestamp');\n    }\n\n    return message.edit(newContent, editedAt);\n  }\n\n  public addReaction(message: Message, emoji: string, userId: UserId): Message {\n    if (!emoji || emoji.trim().length === 0) {\n      throw new Error('Emoji cannot be empty');\n    }\n\n    return message.addReaction(emoji, userId);\n  }\n\n  public removeReaction(\n    message: Message,\n    emoji: string,\n    userId: UserId,\n  ): Message {\n    return message.removeReaction(emoji, userId);\n  }\n\n  public canUserEditMessage(message: Message, userId: UserId): boolean {\n    return message.senderId?.equals(userId) || false;\n  }\n\n  public canUserDeleteMessage(message: Message, userId: UserId): boolean {\n    return message.senderId?.equals(userId) || false;\n  }\n\n  public isMessageExpired(\n    message: Message,\n    expirationHours: number = 24,\n  ): boolean {\n    if (!message.sentAt) {\n      return false;\n    }\n\n    const expirationTime = new Date(\n      message.sentAt.getTime() + expirationHours * 60 * 60 * 1000,\n    );\n    return new Date() > expirationTime;\n  }\n}\n\n@Injectable()\nexport class MessagingValidationService {\n  public validateConversationAccess(\n    conversation: Conversation,\n    userId: UserId,\n    operation: 'read' | 'write' | 'admin',\n  ): void {\n    if (!conversation.isParticipant(userId)) {\n      throw new Error('User does not have access to this conversation');\n    }\n\n    if (operation === 'admin') {\n      const participant = conversation.getParticipant(userId);\n      if (!participant || participant.role !== 'admin') {\n        throw new Error('User does not have admin privileges');\n      }\n    }\n  }\n\n  public validateMessageOperation(\n    message: Message,\n    userId: UserId,\n    operation: 'edit' | 'delete' | 'react',\n  ): void {\n    switch (operation) {\n      case 'edit':\n      case 'delete':\n        if (!message.senderId?.equals(userId)) {\n          throw new Error('Only message sender can perform this operation');\n        }\n        if (message.type === MessageType.SYSTEM) {\n          throw new Error('Cannot modify system messages');\n        }\n        break;\n      case 'react':\n        // Anyone in the conversation can react\n        break;\n      default:\n        throw new Error('Unknown operation');\n    }\n  }\n\n  public validateMessageContent(content: string, type: MessageType): void {\n    if (\n      type === MessageType.TEXT &&\n      (!content || content.trim().length === 0)\n    ) {\n      throw new Error('Text message content cannot be empty');\n    }\n\n    if (content && content.length > 10000) {\n      throw new Error('Message content cannot exceed 10000 characters');\n    }\n  }\n\n  public validateConversationParticipants(\n    participants: UserId[],\n    type: ConversationType,\n  ): void {\n    if (type === ConversationType.PRIVATE && participants.length !== 2) {\n      throw new Error('Private conversation must have exactly 2 participants');\n    }\n\n    if (type === ConversationType.GROUP && participants.length < 2) {\n      throw new Error('Group conversation must have at least 2 participants');\n    }\n\n    if (participants.length > 100) {\n      throw new Error('Conversation cannot have more than 100 participants');\n    }\n\n    // Check for duplicate participants\n    const uniqueParticipants = new Set(participants.map((p) => p.value));\n    if (uniqueParticipants.size !== participants.length) {\n      throw new Error('Duplicate participants are not allowed');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\domain\\value-objects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\infrastructure\\messaging-infrastructure.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\infrastructure\\repositories\\conversation.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":20,"column":18,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":20,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":166,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":166,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .participants on an `any` value.","line":166,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":166,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":168,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":168,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":168,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":168,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isGroup on an `any` value.","line":169,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":169,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":172,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":177,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":172,"column":23,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":172,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .participants on an `any` value.","line":172,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":172,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":173,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":173,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":173,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":173,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":174,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":174,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":174,"column":21,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":174,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .joinedAt on an `any` value.","line":174,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":174,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":175,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":175,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .role on an `any` value.","line":175,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":175,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":178,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":178,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":178,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":178,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":179,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":179,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":179,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":179,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":180,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":180,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":180,"column":20,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":180,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":180,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":180,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":181,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":181,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":181,"column":20,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":181,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":181,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":181,"endColumn":42}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport { IConversationRepository } from '../../domain/repositories';\nimport { Conversation } from '../../domain/conversation.entity';\nimport { ConversationId, UserId } from '../../domain/value-objects';\nimport { ConversationType } from '../../domain/enums';\n\n@Injectable()\nexport class ConversationRepositoryImpl implements IConversationRepository {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async save(conversation: Conversation): Promise<void> {\n    const data = conversation.toPrimitives();\n\n    // Map domain model to current schema\n    await this.prisma.conversation.create({\n      data: {\n        id: data.id,\n        name: data.title,\n        isGroup: data.type === ConversationType.GROUP,\n        createdAt: new Date(data.createdAt),\n        updatedAt: new Date(data.updatedAt),\n        participants: {\n          createMany: {\n            data: data.participants.map((p) => ({\n              userId: p.userId,\n              role: p.role,\n              joinedAt: new Date(p.joinedAt),\n              lastReadAt: null, // Will be updated later\n            })),\n          },\n        },\n      },\n    });\n  }\n\n  async findById(id: ConversationId): Promise<Conversation | null> {\n    const conversation = await this.prisma.conversation.findUnique({\n      where: { id: id.value },\n      include: {\n        participants: {\n          include: {\n            user: true,\n          },\n        },\n      },\n    });\n\n    if (!conversation) {\n      return null;\n    }\n\n    // Map current schema to domain model\n    const firstParticipant = conversation.participants[0];\n    return Conversation.fromPrimitives({\n      id: conversation.id,\n      type: conversation.isGroup\n        ? ConversationType.GROUP\n        : ConversationType.PRIVATE,\n      participants: conversation.participants.map((p) => ({\n        userId: p.userId,\n        joinedAt: p.joinedAt.toISOString(),\n        role: p.role,\n        leftAt: undefined, // Current schema doesn't support leftAt\n      })),\n      title: conversation.name || undefined,\n      createdBy: firstParticipant?.userId || '', // Fallback\n      createdAt: conversation.createdAt.toISOString(),\n      updatedAt: conversation.updatedAt.toISOString(),\n      lastMessageAt: undefined, // Current schema doesn't support this\n      isArchived: false, // Current schema doesn't support this\n      settings: undefined, // Current schema doesn't support this\n    });\n  }\n\n  async findByParticipants(participantIds: UserId[]): Promise<Conversation[]> {\n    const userIdValues = participantIds.map((id) => id.value);\n\n    const conversations = await this.prisma.conversation.findMany({\n      where: {\n        participants: {\n          every: {\n            userId: { in: userIdValues },\n          },\n        },\n      },\n      include: {\n        participants: {\n          include: {\n            user: true,\n          },\n        },\n      },\n    });\n\n    return this.mapToConversations(conversations);\n  }\n\n  async findByParticipant(participantId: UserId): Promise<Conversation[]> {\n    const conversations = await this.prisma.conversation.findMany({\n      where: {\n        participants: {\n          some: {\n            userId: participantId.value,\n          },\n        },\n      },\n      include: {\n        participants: {\n          include: {\n            user: true,\n          },\n        },\n      },\n      orderBy: {\n        updatedAt: 'desc',\n      },\n    });\n\n    return this.mapToConversations(conversations);\n  }\n\n  async update(conversation: Conversation): Promise<void> {\n    const data = conversation.toPrimitives();\n\n    // Update conversation - only update fields supported by current schema\n    await this.prisma.conversation.update({\n      where: { id: data.id },\n      data: {\n        name: data.title,\n        updatedAt: new Date(data.updatedAt),\n      },\n    });\n\n    // Update participants - delete existing and recreate\n    await this.prisma.userConversation.deleteMany({\n      where: { conversationId: data.id },\n    });\n\n    await this.prisma.userConversation.createMany({\n      data: data.participants.map((p) => ({\n        conversationId: data.id,\n        userId: p.userId,\n        role: p.role,\n        joinedAt: new Date(p.joinedAt),\n        lastReadAt: null,\n      })),\n    });\n  }\n\n  async delete(id: ConversationId): Promise<void> {\n    await this.prisma.conversation.delete({\n      where: { id: id.value },\n    });\n  }\n\n  async exists(id: ConversationId): Promise<boolean> {\n    const count = await this.prisma.conversation.count({\n      where: { id: id.value },\n    });\n    return count > 0;\n  }\n\n  private mapToConversations(conversations: any[]): Conversation[] {\n    return conversations.map((conversation) => {\n      const firstParticipant = conversation.participants[0];\n      return Conversation.fromPrimitives({\n        id: conversation.id,\n        type: conversation.isGroup\n          ? ConversationType.GROUP\n          : ConversationType.PRIVATE,\n        participants: conversation.participants.map((p: any) => ({\n          userId: p.userId,\n          joinedAt: p.joinedAt.toISOString(),\n          role: p.role,\n          leftAt: undefined, // Current schema doesn't support leftAt\n        })),\n        title: conversation.name || undefined,\n        createdBy: firstParticipant?.userId || '',\n        createdAt: conversation.createdAt.toISOString(),\n        updatedAt: conversation.updatedAt.toISOString(),\n        lastMessageAt: undefined, // Current schema doesn't support this\n        isArchived: false, // Current schema doesn't support this\n        settings: undefined, // Current schema doesn't support this\n      });\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\infrastructure\\repositories\\message.repository.ts","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":68,"column":25,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":68,"endColumn":42},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":107,"column":36,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":107,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":121,"column":17,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":121,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deliveredAt' is defined but never used.","line":134,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'readAt' is defined but never used.","line":145,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":201,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":201,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":201,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":201,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":202,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":202,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .conversationId on an `any` value.","line":202,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":202,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":203,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":203,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .senderId on an `any` value.","line":203,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":203,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":204,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":204,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":204,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":204,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .messageType on an `any` value.","line":205,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":205,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":206,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":206,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":207,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":207,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":207,"column":15,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":207,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":207,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":207,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":209,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":209,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":209,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":209,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":209,"column":32,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":209,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":209,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":209,"endColumn":49}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport { IMessageRepository } from '../../domain/repositories';\nimport { Message } from '../../domain/message.entity';\nimport { ConversationId, MessageId, UserId } from '../../domain/value-objects';\nimport { MessageType, MessageStatus } from '../../domain/enums';\n\n@Injectable()\nexport class MessageRepositoryImpl implements IMessageRepository {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async save(message: Message): Promise<void> {\n    const data = message.toPrimitives();\n\n    // Skip system messages (senderId is null) as current schema requires senderId\n    if (!data.senderId) {\n      throw new Error('Current schema does not support system messages');\n    }\n\n    await this.prisma.message.create({\n      data: {\n        id: data.id,\n        content: data.content,\n        messageType: data.type,\n        senderId: data.senderId,\n        conversationId: data.conversationId,\n        createdAt: new Date(data.sentAt),\n      },\n    });\n  }\n\n  async findById(id: MessageId): Promise<Message | null> {\n    const message = await this.prisma.message.findUnique({\n      where: { id: id.value },\n      include: {\n        sender: true,\n        conversation: true,\n      },\n    });\n\n    if (!message) {\n      return null;\n    }\n\n    return this.mapToMessage(message);\n  }\n\n  async findByConversationId(\n    conversationId: ConversationId,\n    limit: number = 50,\n    offset: number = 0,\n  ): Promise<Message[]> {\n    const messages = await this.prisma.message.findMany({\n      where: {\n        conversationId: conversationId.value,\n      },\n      include: {\n        sender: true,\n        conversation: true,\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n      take: limit,\n      skip: offset,\n    });\n\n    return messages.map(this.mapToMessage);\n  }\n\n  async findByConversationIdPaginated(\n    conversationId: ConversationId,\n    cursor?: MessageId,\n    limit: number = 50,\n  ): Promise<{\n    messages: Message[];\n    hasMore: boolean;\n    nextCursor?: MessageId;\n  }> {\n    const messages = await this.prisma.message.findMany({\n      where: {\n        conversationId: conversationId.value,\n        ...(cursor && {\n          id: {\n            lt: cursor.value,\n          },\n        }),\n      },\n      include: {\n        sender: true,\n        conversation: true,\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n      take: limit + 1, // Take one extra to check if there are more\n    });\n\n    const hasMore = messages.length > limit;\n    const resultMessages = hasMore ? messages.slice(0, -1) : messages;\n    const nextCursor =\n      hasMore && resultMessages.length > 0\n        ? MessageId.fromString(resultMessages[resultMessages.length - 1].id)\n        : undefined;\n\n    return {\n      messages: resultMessages.map(this.mapToMessage),\n      hasMore,\n      nextCursor,\n    };\n  }\n\n  async update(message: Message): Promise<void> {\n    const data = message.toPrimitives();\n\n    await this.prisma.message.update({\n      where: { id: data.id },\n      data: {\n        content: data.content,\n        messageType: data.type,\n        isRead: data.status === MessageStatus.READ,\n      },\n    });\n  }\n\n  async delete(id: MessageId): Promise<void> {\n    await this.prisma.message.delete({\n      where: { id: id.value },\n    });\n  }\n\n  async markAsDelivered(\n    messageId: MessageId,\n    deliveredAt: Date,\n  ): Promise<void> {\n    // Current schema doesn't support delivered status, so we just update the read status\n    await this.prisma.message.update({\n      where: { id: messageId.value },\n      data: {\n        // Current schema only has isRead, so we can't mark as delivered separately\n      },\n    });\n  }\n\n  async markAsRead(messageId: MessageId, readAt: Date): Promise<void> {\n    await this.prisma.message.update({\n      where: { id: messageId.value },\n      data: {\n        isRead: true,\n      },\n    });\n  }\n\n  async countUnreadMessages(\n    conversationId: ConversationId,\n    userId: UserId,\n  ): Promise<number> {\n    return await this.prisma.message.count({\n      where: {\n        conversationId: conversationId.value,\n        senderId: {\n          not: userId.value,\n        },\n        isRead: false,\n      },\n    });\n  }\n\n  async getLastMessage(\n    conversationId: ConversationId,\n  ): Promise<Message | null> {\n    const message = await this.prisma.message.findFirst({\n      where: {\n        conversationId: conversationId.value,\n      },\n      include: {\n        sender: true,\n        conversation: true,\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n    });\n\n    if (!message) {\n      return null;\n    }\n\n    return this.mapToMessage(message);\n  }\n\n  async exists(id: MessageId): Promise<boolean> {\n    const count = await this.prisma.message.count({\n      where: { id: id.value },\n    });\n    return count > 0;\n  }\n\n  private mapToMessage(message: any): Message {\n    return Message.fromPrimitives({\n      id: message.id,\n      conversationId: message.conversationId,\n      senderId: message.senderId,\n      content: message.content,\n      type: message.messageType as MessageType,\n      status: message.isRead ? MessageStatus.READ : MessageStatus.SENT,\n      sentAt: message.createdAt.toISOString(),\n      deliveredAt: undefined, // Current schema doesn't support this\n      readAt: message.isRead ? message.createdAt.toISOString() : undefined,\n      editedAt: undefined, // Current schema doesn't support this\n      attachmentUrl: undefined, // Current schema doesn't support this\n      replyToMessageId: undefined, // Current schema doesn't support this\n      reactions: [], // Current schema doesn't support this\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\infrastructure\\repositories\\messaging-unit-of-work.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'rollback' has no 'await' expression.","line":34,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":34,"endColumn":17,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1067,1098],"text":"rollback(): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport {\n  IMessagingUnitOfWork,\n  IConversationRepository,\n  IMessageRepository,\n} from '../../domain/repositories';\nimport { ConversationRepositoryImpl } from './conversation.repository';\nimport { MessageRepositoryImpl } from './message.repository';\n\n@Injectable()\nexport class MessagingUnitOfWorkImpl implements IMessagingUnitOfWork {\n  private _conversations: IConversationRepository;\n  private _messages: IMessageRepository;\n\n  constructor(private readonly prisma: PrismaService) {\n    this._conversations = new ConversationRepositoryImpl(this.prisma);\n    this._messages = new MessageRepositoryImpl(this.prisma);\n  }\n\n  get conversations(): IConversationRepository {\n    return this._conversations;\n  }\n\n  get messages(): IMessageRepository {\n    return this._messages;\n  }\n\n  async commit(): Promise<void> {\n    // In a real implementation, this would commit a database transaction\n    // For now, we'll use Prisma's implicit transactions\n  }\n\n  async rollback(): Promise<void> {\n    // In a real implementation, this would rollback a database transaction\n    // For now, we'll throw an error to indicate rollback\n    throw new Error(\n      'Transaction rollback not implemented with current Prisma setup',\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\messaging.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\controllers\\conversation.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UseGuards' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RemoveParticipantDto' is defined but never used.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":65,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":65,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":65,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":65,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":65,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":65,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":71,"column":40,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":71,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":80,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":80,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":85,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":85,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":85,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":113,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":113,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":113,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":113,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":120,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":120,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":126,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":126,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":142,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":142,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":142,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":142,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":142,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":142,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":147,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":149,"endColumn":9},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":148,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":148,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":151,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":151,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":176,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":176,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":176,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":176,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":183,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":183,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":191,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":191,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":191,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":191,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":192,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":192,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":194,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":194,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":194,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":194,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":195,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":195,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":222,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":222,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":222,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":222,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":222,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":222,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":230,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":230,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":235,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":235,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":235,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":235,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":236,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":236,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":239,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":239,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":239,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":239,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":240,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":240,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":240,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":240,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":242,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":242,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":269,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":269,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":269,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":269,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":269,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":269,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":277,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":277,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":282,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":282,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":282,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":282,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":283,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":283,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":286,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":286,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":286,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":286,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":287,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":287,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":287,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":287,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":289,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":289,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":291,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":291,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":317,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":317,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":317,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":317,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":325,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":325,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":330,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":330,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":330,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":330,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":331,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":331,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":334,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":334,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":334,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":334,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":335,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":335,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":335,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":335,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":337,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":337,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":339,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":339,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":356,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":356,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":356,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":356,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":356,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":356,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":361,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":361,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":364,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":364,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":364,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":364,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":365,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":365,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":367,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":380,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":380,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":380,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":380,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":380,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":380,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":385,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":385,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":388,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":388,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":388,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":388,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":389,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":389,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":391,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":391,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":391,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":391,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":392,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":392,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":407,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":407,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":407,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":407,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":407,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":407,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":412,"column":65,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":412,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":415,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":415,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":415,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":415,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":416,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":416,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":418,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":418,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":418,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":418,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":419,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":419,"endColumn":51}],"suppressedMessages":[],"errorCount":89,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Request,\n  HttpStatus,\n  BadRequestException,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiParam,\n} from '@nestjs/swagger';\nimport { ConversationUseCases } from '../../application/use-cases/conversation.use-cases';\nimport { MessagingApplicationServices } from '../../application/services/messaging-application.services';\nimport {\n  CreatePrivateConversationDto,\n  CreateGroupConversationDto,\n  UpdateConversationTitleDto,\n  AddParticipantDto,\n  RemoveParticipantDto,\n  GetConversationsQueryDto,\n  ConversationResponseDto,\n  ConversationWithLastMessageDto,\n} from '../dto/conversation.dto';\n\n@ApiTags('Conversations')\n@ApiBearerAuth()\n@Controller('conversations')\nexport class ConversationController {\n  constructor(\n    private readonly conversationUseCases: ConversationUseCases,\n    private readonly messagingServices: MessagingApplicationServices,\n  ) {}\n\n  @Post('private')\n  @ApiOperation({ summary: 'Create a private conversation' })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Private conversation created successfully',\n    schema: {\n      type: 'object',\n      properties: { conversationId: { type: 'string' } },\n    },\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input or conversation already exists',\n  })\n  async createPrivateConversation(\n    @Body() dto: CreatePrivateConversationDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      // Validate that current user is one of the participants\n      if (!dto.participantIds.includes(userId)) {\n        throw new ForbiddenException(\n          'You must be a participant in the conversation',\n        );\n      }\n\n      const conversationId =\n        await this.conversationUseCases.createPrivateConversation({\n          participantIds: dto.participantIds,\n          createdBy: userId,\n        });\n\n      return { conversationId };\n    } catch (error) {\n      if (error.message.includes('already exists')) {\n        throw new BadRequestException(\n          'Private conversation already exists between these users',\n        );\n      }\n      throw error;\n    }\n  }\n\n  @Post('group')\n  @ApiOperation({ summary: 'Create a group conversation' })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Group conversation created successfully',\n    schema: {\n      type: 'object',\n      properties: { conversationId: { type: 'string' } },\n    },\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input',\n  })\n  async createGroupConversation(\n    @Body() dto: CreateGroupConversationDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const conversationId = await this.messagingServices.createGroupChat(\n        dto.title,\n        userId,\n        dto.participantIds,\n      );\n\n      return { conversationId };\n    } catch (error) {\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get user conversations with last messages' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversations retrieved successfully',\n    type: [ConversationWithLastMessageDto],\n  })\n  async getUserConversations(\n    @Query() query: GetConversationsQueryDto,\n    @Request() req: any,\n  ): Promise<ConversationWithLastMessageDto[]> {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      return await this.messagingServices.getUserConversationsWithLastMessage(\n        userId,\n      );\n    } catch (error) {\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get conversation by ID' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversation retrieved successfully',\n    type: ConversationResponseDto,\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async getConversationById(\n    @Param('id') id: string,\n    @Request() req: any,\n  ): Promise<ConversationResponseDto> {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const conversation = await this.conversationUseCases.getConversationById(\n        id,\n        userId,\n      );\n      if (!conversation) {\n        throw new NotFoundException('Conversation not found or access denied');\n      }\n\n      return conversation.toPrimitives() as ConversationResponseDto;\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw error;\n    }\n  }\n\n  @Put(':id/title')\n  @ApiOperation({ summary: 'Update conversation title' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversation title updated successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async updateConversationTitle(\n    @Param('id') id: string,\n    @Body() dto: UpdateConversationTitleDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.conversationUseCases.updateConversationTitle({\n        conversationId: id,\n        title: dto.title,\n        updatedBy: userId,\n      });\n\n      return { message: 'Conversation title updated successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (\n        error.message.includes('access') ||\n        error.message.includes('privileges')\n      ) {\n        throw new ForbiddenException(error.message);\n      }\n      throw error;\n    }\n  }\n\n  @Post(':id/participants')\n  @ApiOperation({ summary: 'Add participant to conversation' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Participant added successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied or insufficient privileges',\n  })\n  async addParticipant(\n    @Param('id') id: string,\n    @Body() dto: AddParticipantDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.conversationUseCases.addParticipant({\n        conversationId: id,\n        userId: dto.userId,\n        addedBy: userId,\n      });\n\n      return { message: 'Participant added successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (\n        error.message.includes('access') ||\n        error.message.includes('privileges')\n      ) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Delete(':id/participants/:userId')\n  @ApiOperation({ summary: 'Remove participant from conversation' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiParam({ name: 'userId', description: 'User ID to remove' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Participant removed successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied or insufficient privileges',\n  })\n  async removeParticipant(\n    @Param('id') id: string,\n    @Param('userId') participantUserId: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.conversationUseCases.removeParticipant({\n        conversationId: id,\n        userId: participantUserId,\n        removedBy: userId,\n      });\n\n      return { message: 'Participant removed successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (\n        error.message.includes('access') ||\n        error.message.includes('privileges')\n      ) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post(':id/leave')\n  @ApiOperation({ summary: 'Leave group conversation' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Left conversation successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  async leaveConversation(@Param('id') id: string, @Request() req: any) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messagingServices.leaveGroupConversation(id, userId);\n      return { message: 'Left conversation successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post(':id/archive')\n  @ApiOperation({ summary: 'Archive conversation' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversation archived successfully',\n  })\n  async archiveConversation(@Param('id') id: string, @Request() req: any) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.conversationUseCases.archiveConversation(id, userId);\n      return { message: 'Conversation archived successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw error;\n    }\n  }\n\n  @Post(':id/unarchive')\n  @ApiOperation({ summary: 'Unarchive conversation' })\n  @ApiParam({ name: 'id', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversation unarchived successfully',\n  })\n  async unarchiveConversation(@Param('id') id: string, @Request() req: any) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.conversationUseCases.unarchiveConversation(id, userId);\n      return { message: 'Conversation unarchived successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\controllers\\message.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UseGuards' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":69,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":69,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":69,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":69,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":69,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":69,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":76,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":76,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":82,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":82,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":82,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":82,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":83,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":83,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":85,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":85,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":85,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":86,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":86,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":88,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":88,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":114,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":114,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":114,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":114,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":121,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":121,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":129,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":129,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":129,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":129,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":130,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":132,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":132,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":132,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":132,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":133,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":133,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":135,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":135,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":161,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":161,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":161,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":161,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":168,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":168,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":175,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":175,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":175,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":175,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":176,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":178,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":178,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":178,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":178,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":179,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":179,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":181,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":181,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":207,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":207,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":207,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":207,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":207,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":207,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":214,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":214,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":227,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":227,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":227,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":227,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":228,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":228,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":230,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":230,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":230,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":230,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":231,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":231,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":233,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":233,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":259,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":259,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":259,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":259,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":259,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":259,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":266,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":266,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":272,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":272,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":272,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":273,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":273,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":275,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":275,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":275,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":275,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":276,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":276,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":278,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":278,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":303,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":303,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":303,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":303,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":303,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":303,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":311,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":311,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":316,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":316,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":316,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":316,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":317,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":319,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":319,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":319,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":319,"column":45,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":319,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":319,"column":51,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":320,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":320,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":322,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":322,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":346,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":346,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":346,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":346,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":346,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":346,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":353,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":353,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":358,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":358,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":358,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":358,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":359,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":359,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":362,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":362,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":362,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":362,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":363,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":363,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":363,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":363,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":365,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":365,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":367,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":392,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":392,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":392,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":392,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":392,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":392,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":400,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":400,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":405,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":405,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":405,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":405,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":406,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":406,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":408,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":408,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":408,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":408,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":409,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":409,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":411,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":411,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":437,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":437,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":437,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":437,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":437,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":437,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":445,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":445,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":450,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":450,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":450,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":450,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":451,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":451,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":453,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":453,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":453,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":453,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":454,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":454,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":456,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":456,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":476,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":476,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":476,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":476,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":476,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":476,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":483,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":483,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":488,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":488,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":488,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":488,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":489,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":489,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":491,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":491,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":491,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":491,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":492,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":492,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":494,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":494,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":514,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":514,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":514,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":514,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":514,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":514,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":521,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":521,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":526,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":526,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":526,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":526,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":527,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":527,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":529,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":529,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":529,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":529,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":530,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":530,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":532,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":532,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":549,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":549,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":549,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":549,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":549,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":549,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":556,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":556,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":560,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":560,"endColumn":50}],"suppressedMessages":[],"errorCount":129,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Request,\n  HttpStatus,\n  BadRequestException,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiParam,\n} from '@nestjs/swagger';\nimport { MessageUseCases } from '../../application/use-cases/message.use-cases';\nimport { MessagingApplicationServices } from '../../application/services/messaging-application.services';\nimport {\n  SendTextMessageDto,\n  SendMediaMessageDto,\n  SendReplyMessageDto,\n  EditMessageDto,\n  AddReactionDto,\n  GetMessagesQueryDto,\n  MessageResponseDto,\n  MessagesResponseDto,\n  ConversationWithMessagesDto,\n} from '../dto/message.dto';\n\n@ApiTags('Messages')\n@ApiBearerAuth()\n@Controller()\nexport class MessageController {\n  constructor(\n    private readonly messageUseCases: MessageUseCases,\n    private readonly messagingServices: MessagingApplicationServices,\n  ) {}\n\n  @Post('conversations/:conversationId/messages/text')\n  @ApiOperation({ summary: 'Send a text message' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Text message sent successfully',\n    schema: { type: 'object', properties: { messageId: { type: 'string' } } },\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async sendTextMessage(\n    @Param('conversationId') conversationId: string,\n    @Body() dto: SendTextMessageDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const messageId = await this.messageUseCases.sendTextMessage({\n        conversationId,\n        senderId: userId,\n        content: dto.content,\n      });\n\n      return { messageId };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post('conversations/:conversationId/messages/media')\n  @ApiOperation({ summary: 'Send a media message' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Media message sent successfully',\n    schema: { type: 'object', properties: { messageId: { type: 'string' } } },\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async sendMediaMessage(\n    @Param('conversationId') conversationId: string,\n    @Body() dto: SendMediaMessageDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const messageId = await this.messageUseCases.sendMediaMessage({\n        conversationId,\n        senderId: userId,\n        type: dto.type,\n        attachmentUrl: dto.attachmentUrl,\n        content: dto.content,\n      });\n\n      return { messageId };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post('conversations/:conversationId/messages/reply')\n  @ApiOperation({ summary: 'Send a reply message' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Reply message sent successfully',\n    schema: { type: 'object', properties: { messageId: { type: 'string' } } },\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation or reply target message not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async sendReplyMessage(\n    @Param('conversationId') conversationId: string,\n    @Body() dto: SendReplyMessageDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const messageId = await this.messageUseCases.sendReplyMessage({\n        conversationId,\n        senderId: userId,\n        content: dto.content,\n        replyToMessageId: dto.replyToMessageId,\n      });\n\n      return { messageId };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Get('conversations/:conversationId/messages')\n  @ApiOperation({ summary: 'Get conversation messages' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Messages retrieved successfully',\n    type: MessagesResponseDto,\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async getConversationMessages(\n    @Param('conversationId') conversationId: string,\n    @Query() query: GetMessagesQueryDto,\n    @Request() req: any,\n  ): Promise<MessagesResponseDto> {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const result = await this.messageUseCases.getConversationMessages({\n        conversationId,\n        userId,\n        limit: query.limit,\n        cursor: query.cursor,\n      });\n\n      return {\n        messages: result.messages.map((msg) =>\n          msg.toPrimitives(),\n        ) as MessageResponseDto[],\n        hasMore: result.hasMore,\n        nextCursor: result.nextCursor,\n      };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Get('conversations/:conversationId/with-messages')\n  @ApiOperation({ summary: 'Get conversation with messages in one request' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Conversation with messages retrieved successfully',\n    type: ConversationWithMessagesDto,\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async getConversationWithMessages(\n    @Param('conversationId') conversationId: string,\n    @Query() query: GetMessagesQueryDto,\n    @Request() req: any,\n  ): Promise<ConversationWithMessagesDto> {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const result = await this.messagingServices.getConversationWithMessages(\n        conversationId,\n        userId,\n        query.limit,\n      );\n\n      return result as ConversationWithMessagesDto;\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Put('messages/:messageId')\n  @ApiOperation({ summary: 'Edit a message' })\n  @ApiParam({ name: 'messageId', description: 'Message ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Message edited successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Message not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Cannot edit this message',\n  })\n  async editMessage(\n    @Param('messageId') messageId: string,\n    @Body() dto: EditMessageDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.editMessage({\n        messageId,\n        newContent: dto.newContent,\n        editedBy: userId,\n      });\n\n      return { message: 'Message edited successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('edit') || error.message.includes('sender')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Delete('messages/:messageId')\n  @ApiOperation({ summary: 'Delete a message' })\n  @ApiParam({ name: 'messageId', description: 'Message ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Message deleted successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Message not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Cannot delete this message',\n  })\n  async deleteMessage(\n    @Param('messageId') messageId: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.deleteMessage({\n        messageId,\n        deletedBy: userId,\n      });\n\n      return { message: 'Message deleted successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (\n        error.message.includes('delete') ||\n        error.message.includes('sender')\n      ) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post('messages/:messageId/reactions')\n  @ApiOperation({ summary: 'Add reaction to message' })\n  @ApiParam({ name: 'messageId', description: 'Message ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Reaction added successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Message not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async addReaction(\n    @Param('messageId') messageId: string,\n    @Body() dto: AddReactionDto,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.addReaction({\n        messageId,\n        emoji: dto.emoji,\n        userId,\n      });\n\n      return { message: 'Reaction added successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Delete('messages/:messageId/reactions/:emoji')\n  @ApiOperation({ summary: 'Remove reaction from message' })\n  @ApiParam({ name: 'messageId', description: 'Message ID' })\n  @ApiParam({ name: 'emoji', description: 'Emoji to remove' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Reaction removed successfully',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Message not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access denied',\n  })\n  async removeReaction(\n    @Param('messageId') messageId: string,\n    @Param('emoji') emoji: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.removeReaction({\n        messageId,\n        emoji: decodeURIComponent(emoji),\n        userId,\n      });\n\n      return { message: 'Reaction removed successfully' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post('messages/:messageId/read')\n  @ApiOperation({ summary: 'Mark message as read' })\n  @ApiParam({ name: 'messageId', description: 'Message ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Message marked as read',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Message not found',\n  })\n  async markMessageAsRead(\n    @Param('messageId') messageId: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.markMessageAsRead({\n        messageId,\n        userId,\n      });\n\n      return { message: 'Message marked as read' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Post('conversations/:conversationId/read-all')\n  @ApiOperation({ summary: 'Mark all messages in conversation as read' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'All messages marked as read',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Conversation not found',\n  })\n  async markConversationAsRead(\n    @Param('conversationId') conversationId: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      await this.messageUseCases.markConversationAsRead({\n        conversationId,\n        userId,\n      });\n\n      return { message: 'All messages marked as read' };\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        throw new NotFoundException(error.message);\n      }\n      if (error.message.includes('access')) {\n        throw new ForbiddenException(error.message);\n      }\n      throw new BadRequestException(error.message);\n    }\n  }\n\n  @Get('conversations/:conversationId/unread-count')\n  @ApiOperation({ summary: 'Get unread message count for conversation' })\n  @ApiParam({ name: 'conversationId', description: 'Conversation ID' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Unread count retrieved successfully',\n    schema: { type: 'object', properties: { count: { type: 'number' } } },\n  })\n  async getUnreadCount(\n    @Param('conversationId') conversationId: string,\n    @Request() req: any,\n  ) {\n    try {\n      const userId = req.user?.id || req.user?.sub;\n      if (!userId) {\n        throw new BadRequestException('User not authenticated');\n      }\n\n      const count = await this.messageUseCases.getUnreadMessageCount(\n        conversationId,\n        userId,\n      );\n      return { count };\n    } catch (error) {\n      throw new BadRequestException(error.message);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\dto\\conversation.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsEnum' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsNotEmpty,\n  IsArray,\n  ArrayMinSize,\n  IsOptional,\n  IsEnum,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class CreatePrivateConversationDto {\n  @ApiProperty({\n    description: 'Array of exactly 2 user IDs for private conversation',\n    example: ['user1-uuid', 'user2-uuid'],\n  })\n  @IsArray()\n  @ArrayMinSize(2)\n  @IsString({ each: true })\n  participantIds: [string, string];\n}\n\nexport class CreateGroupConversationDto {\n  @ApiProperty({\n    description: 'Title of the group conversation',\n    example: 'Project Team Chat',\n  })\n  @IsString()\n  @IsNotEmpty()\n  title: string;\n\n  @ApiProperty({\n    description: 'Array of user IDs to be participants',\n    example: ['user1-uuid', 'user2-uuid', 'user3-uuid'],\n  })\n  @IsArray()\n  @ArrayMinSize(1)\n  @IsString({ each: true })\n  participantIds: string[];\n}\n\nexport class UpdateConversationTitleDto {\n  @ApiProperty({\n    description: 'New title for the conversation',\n    example: 'Updated Team Chat',\n  })\n  @IsString()\n  @IsNotEmpty()\n  title: string;\n}\n\nexport class AddParticipantDto {\n  @ApiProperty({\n    description: 'User ID to add to the conversation',\n    example: 'user-uuid',\n  })\n  @IsString()\n  @IsNotEmpty()\n  userId: string;\n}\n\nexport class RemoveParticipantDto {\n  @ApiProperty({\n    description: 'User ID to remove from the conversation',\n    example: 'user-uuid',\n  })\n  @IsString()\n  @IsNotEmpty()\n  userId: string;\n}\n\nexport class GetConversationsQueryDto {\n  @ApiPropertyOptional({\n    description: 'Number of conversations to return',\n    example: 20,\n    default: 50,\n  })\n  @IsOptional()\n  @Type(() => Number)\n  limit?: number;\n\n  @ApiPropertyOptional({\n    description: 'Offset for pagination',\n    example: 0,\n    default: 0,\n  })\n  @IsOptional()\n  @Type(() => Number)\n  offset?: number;\n}\n\nexport class ConversationResponseDto {\n  @ApiProperty({ example: 'conv-uuid' })\n  id: string;\n\n  @ApiProperty({ example: 'private' })\n  type: string;\n\n  @ApiProperty({ example: 'Team Chat', required: false })\n  title?: string;\n\n  @ApiProperty({ example: 'user-uuid' })\n  createdBy: string;\n\n  @ApiProperty({ example: '2023-01-01T00:00:00Z' })\n  createdAt: string;\n\n  @ApiProperty({ example: '2023-01-01T00:00:00Z' })\n  updatedAt: string;\n\n  @ApiProperty({ example: '2023-01-01T00:00:00Z', required: false })\n  lastMessageAt?: string;\n\n  @ApiProperty({ example: false })\n  isArchived: boolean;\n\n  @ApiProperty({ type: [Object] })\n  participants: Array<{\n    userId: string;\n    joinedAt: string;\n    role: string;\n    leftAt?: string;\n  }>;\n}\n\nexport class ConversationWithLastMessageDto extends ConversationResponseDto {\n  @ApiPropertyOptional({ type: Object })\n  lastMessage?: {\n    id: string;\n    content: string;\n    type: string;\n    senderId: string | null;\n    sentAt: string;\n  };\n\n  @ApiProperty({ example: 5 })\n  unreadCount: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\dto\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\dto\\message.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\gateways\\messaging.gateway.ts","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":65,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":65,"endColumn":62,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1738,1738],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1738,1738],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":73,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":59},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleDisconnect' has no 'await' expression.","line":78,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":78,"endColumn":25,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2077,2083],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":90,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":90,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":116,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":116,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":131,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":131,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":132,"column":30,"nodeType":"Property","messageId":"anyAssignment","endLine":132,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":132,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":132,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":133,"column":32,"nodeType":"Property","messageId":"anyAssignment","endLine":133,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":133,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":133,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":160,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":160,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":161,"column":32,"nodeType":"Property","messageId":"anyAssignment","endLine":161,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":161,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":52},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleTypingStart' has no 'await' expression.","line":166,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":166,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4619,4625],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":179,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":179,"endColumn":61},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleTypingStop' has no 'await' expression.","line":184,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":184,"endColumn":25,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5105,5111],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":197,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":197,"endColumn":60},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":217,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":217,"endColumn":60,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6034,6034],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6034,6034],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":223,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":223,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":224,"column":32,"nodeType":"Property","messageId":"anyAssignment","endLine":224,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":224,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":224,"endColumn":52},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleLeaveConversation' has no 'await' expression.","line":229,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":229,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6388,6394],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":234,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":234,"endColumn":59,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6546,6546],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6546,6546],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":237,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":237,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":238,"column":32,"nodeType":"Property","messageId":"anyAssignment","endLine":238,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":238,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":238,"endColumn":52},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'emitToUser' has no 'await' expression.","line":243,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":243,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6837,6843],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'emitToConversation' has no 'await' expression.","line":251,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":251,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7084,7090],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  WebSocketGateway,\n  WebSocketServer,\n  SubscribeMessage,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  ConnectedSocket,\n  MessageBody,\n} from '@nestjs/websockets';\nimport { Logger, Inject } from '@nestjs/common';\nimport { Server, Socket } from 'socket.io';\nimport { MessageUseCases } from '../../application/use-cases/message.use-cases';\nimport { ConversationUseCases } from '../../application/use-cases/conversation.use-cases';\nimport {\n  SendMessageDto,\n  MarkMessageAsReadDto,\n  TypingIndicatorDto,\n} from '../dto';\nimport { MessageType } from '../../domain/enums';\n\ninterface AuthenticatedSocket extends Socket {\n  userId?: string;\n}\n\n@WebSocketGateway({\n  namespace: '/messaging',\n  cors: {\n    origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n    credentials: true,\n  },\n})\nexport class MessagingGateway\n  implements OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer()\n  server: Server;\n\n  private readonly logger = new Logger(MessagingGateway.name);\n  private connectedUsers = new Map<string, string>(); // userId -> socketId\n\n  constructor(\n    @Inject('MESSAGE_USE_CASES')\n    private readonly messageUseCases: MessageUseCases,\n    @Inject('CONVERSATION_USE_CASES')\n    private readonly conversationUseCases: ConversationUseCases,\n  ) {}\n\n  async handleConnection(client: AuthenticatedSocket) {\n    try {\n      const userId = client.userId;\n      if (!userId) {\n        client.disconnect();\n        return;\n      }\n\n      this.connectedUsers.set(userId, client.id);\n\n      // Join user to their conversation rooms\n      const conversations =\n        await this.conversationUseCases.getUserConversations({\n          userId,\n        });\n\n      conversations.forEach((conversation) => {\n        client.join(`conversation:${conversation.id.value}`);\n      });\n\n      // Set user as online\n      client.broadcast.emit('user:online', { userId });\n\n      this.logger.log(`User ${userId} connected to messaging`);\n    } catch (error) {\n      this.logger.error(`Connection error: ${error.message}`);\n      client.disconnect();\n    }\n  }\n\n  async handleDisconnect(client: AuthenticatedSocket) {\n    try {\n      const userId = client.userId;\n      if (userId) {\n        this.connectedUsers.delete(userId);\n\n        // Set user as offline\n        client.broadcast.emit('user:offline', { userId });\n\n        this.logger.log(`User ${userId} disconnected from messaging`);\n      }\n    } catch (error) {\n      this.logger.error(`Disconnect error: ${error.message}`);\n    }\n  }\n\n  @SubscribeMessage('message:send')\n  async handleSendMessage(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: SendMessageDto,\n  ) {\n    try {\n      const userId = client.userId;\n      if (!userId) return;\n\n      let messageId: string;\n\n      if (data.type === MessageType.TEXT || !data.type) {\n        messageId = await this.messageUseCases.sendTextMessage({\n          senderId: userId,\n          conversationId: data.conversationId,\n          content: data.content,\n        });\n      } else {\n        messageId = await this.messageUseCases.sendMediaMessage({\n          senderId: userId,\n          conversationId: data.conversationId,\n          type: data.type,\n          attachmentUrl: data.attachments?.[0] || '',\n          content: data.content,\n        });\n      }\n\n      // Emit to all participants in the conversation\n      this.server\n        .to(`conversation:${data.conversationId}`)\n        .emit('message:received', {\n          messageId,\n          conversationId: data.conversationId,\n        });\n\n      return { success: true, messageId };\n    } catch (error) {\n      this.logger.error(`Send message error: ${error.message}`);\n      client.emit('error', { message: error.message });\n      return { success: false, error: error.message };\n    }\n  }\n\n  @SubscribeMessage('message:read')\n  async handleMarkMessageAsRead(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: MarkMessageAsReadDto,\n  ) {\n    try {\n      const userId = client.userId;\n      if (!userId) return;\n\n      await this.messageUseCases.markMessageAsRead({\n        messageId: data.messageId,\n        userId,\n      });\n\n      // Notify other participants that message was read\n      client.to(`conversation:${data.conversationId}`).emit('message:read', {\n        messageId: data.messageId,\n        userId,\n        readAt: new Date(),\n      });\n\n      return { success: true };\n    } catch (error) {\n      this.logger.error(`Mark message as read error: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  @SubscribeMessage('typing:start')\n  async handleTypingStart(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: TypingIndicatorDto,\n  ) {\n    try {\n      const userId = client.userId;\n      if (!userId) return;\n\n      client.to(`conversation:${data.conversationId}`).emit('typing:start', {\n        userId,\n        conversationId: data.conversationId,\n      });\n    } catch (error) {\n      this.logger.error(`Typing start error: ${error.message}`);\n    }\n  }\n\n  @SubscribeMessage('typing:stop')\n  async handleTypingStop(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: TypingIndicatorDto,\n  ) {\n    try {\n      const userId = client.userId;\n      if (!userId) return;\n\n      client.to(`conversation:${data.conversationId}`).emit('typing:stop', {\n        userId,\n        conversationId: data.conversationId,\n      });\n    } catch (error) {\n      this.logger.error(`Typing stop error: ${error.message}`);\n    }\n  }\n\n  @SubscribeMessage('conversation:join')\n  async handleJoinConversation(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { conversationId: string },\n  ) {\n    try {\n      const userId = client.userId;\n      if (!userId) return;\n\n      // Verify user is participant in the conversation\n      const conversation = await this.conversationUseCases.getConversationById(\n        data.conversationId,\n        userId,\n      );\n\n      if (conversation) {\n        client.join(`conversation:${data.conversationId}`);\n        return { success: true };\n      }\n\n      return { success: false, error: 'Access denied' };\n    } catch (error) {\n      this.logger.error(`Join conversation error: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  @SubscribeMessage('conversation:leave')\n  async handleLeaveConversation(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { conversationId: string },\n  ) {\n    try {\n      client.leave(`conversation:${data.conversationId}`);\n      return { success: true };\n    } catch (error) {\n      this.logger.error(`Leave conversation error: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Method to emit message to specific user\n  async emitToUser(userId: string, event: string, data: any) {\n    const socketId = this.connectedUsers.get(userId);\n    if (socketId) {\n      this.server.to(socketId).emit(event, data);\n    }\n  }\n\n  // Method to emit to conversation participants\n  async emitToConversation(conversationId: string, event: string, data: any) {\n    this.server.to(`conversation:${conversationId}`).emit(event, data);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\messaging\\presentation\\messaging-presentation.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\dto\\notification.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsDateString' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsEnum,\n  IsOptional,\n  IsBoolean,\n  IsUUID,\n  IsDateString,\n} from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { NotificationType, NotificationEntityType } from '../../domain';\n\nexport class CreateNotificationDto {\n  @ApiProperty({\n    enum: NotificationType,\n    description: 'Type of notification',\n  })\n  @IsEnum(NotificationType)\n  type: NotificationType;\n\n  @ApiProperty({ description: 'Notification title' })\n  @IsString()\n  title: string;\n\n  @ApiProperty({ description: 'Notification content' })\n  @IsString()\n  content: string;\n\n  @ApiProperty({ description: 'User ID who will receive the notification' })\n  @IsUUID()\n  userId: string;\n\n  @ApiPropertyOptional({\n    description: 'ID of related entity (post, user, etc.)',\n  })\n  @IsOptional()\n  @IsString()\n  entityId?: string;\n\n  @ApiPropertyOptional({\n    enum: NotificationEntityType,\n    description: 'Type of related entity',\n  })\n  @IsOptional()\n  @IsEnum(NotificationEntityType)\n  entityType?: NotificationEntityType;\n}\n\nexport class UpdateNotificationDto {\n  @ApiPropertyOptional({ description: 'Notification title' })\n  @IsOptional()\n  @IsString()\n  title?: string;\n\n  @ApiPropertyOptional({ description: 'Notification content' })\n  @IsOptional()\n  @IsString()\n  content?: string;\n\n  @ApiPropertyOptional({ description: 'Read status' })\n  @IsOptional()\n  @IsBoolean()\n  isRead?: boolean;\n}\n\nexport class NotificationResponseDto {\n  @ApiProperty({ description: 'Notification ID' })\n  id: string;\n\n  @ApiProperty({\n    enum: NotificationType,\n    description: 'Type of notification',\n  })\n  type: NotificationType;\n\n  @ApiProperty({ description: 'Notification title' })\n  title: string;\n\n  @ApiProperty({ description: 'Notification content' })\n  content: string;\n\n  @ApiProperty({ description: 'User ID who received the notification' })\n  userId: string;\n\n  @ApiProperty({ description: 'Read status' })\n  isRead: boolean;\n\n  @ApiPropertyOptional({ description: 'ID of related entity' })\n  entityId?: string;\n\n  @ApiPropertyOptional({\n    enum: NotificationEntityType,\n    description: 'Type of related entity',\n  })\n  entityType?: NotificationEntityType;\n\n  @ApiProperty({ description: 'Creation timestamp' })\n  createdAt: Date;\n\n  @ApiPropertyOptional({ description: 'Notification priority' })\n  priority?: 'high' | 'medium' | 'low';\n}\n\nexport class NotificationListResponseDto {\n  @ApiProperty({\n    type: [NotificationResponseDto],\n    description: 'List of notifications',\n  })\n  notifications: NotificationResponseDto[];\n\n  @ApiProperty({ description: 'Total count of notifications' })\n  total: number;\n\n  @ApiProperty({ description: 'Count of unread notifications' })\n  unreadCount: number;\n\n  @ApiProperty({ description: 'Current page number' })\n  page: number;\n\n  @ApiProperty({ description: 'Number of items per page' })\n  limit: number;\n\n  @ApiProperty({ description: 'Total number of pages' })\n  totalPages: number;\n}\n\nexport class NotificationStatsDto {\n  @ApiProperty({ description: 'Total count of notifications' })\n  totalCount: number;\n\n  @ApiProperty({ description: 'Count of unread notifications' })\n  unreadCount: number;\n\n  @ApiProperty({\n    description: 'Breakdown by notification type',\n  })\n  typeBreakdown: Record<NotificationType, number>;\n\n  @ApiProperty({\n    description: 'Breakdown by priority',\n  })\n  priorityBreakdown: Record<'high' | 'medium' | 'low', number>;\n}\n\nexport class BulkNotificationActionDto {\n  @ApiProperty({\n    type: [String],\n    description: 'Array of notification IDs',\n  })\n  @IsUUID(4, { each: true })\n  notificationIds: string[];\n}\n\nexport class MarkAsReadDto extends BulkNotificationActionDto {}\n\nexport class MarkAsUnreadDto extends BulkNotificationActionDto {}\n\nexport class DeleteNotificationsDto extends BulkNotificationActionDto {}\n\nexport class NotificationQueryDto {\n  @ApiPropertyOptional({\n    description: 'Filter by read status',\n  })\n  @IsOptional()\n  @IsBoolean()\n  isRead?: boolean;\n\n  @ApiPropertyOptional({\n    enum: NotificationType,\n    description: 'Filter by notification type',\n  })\n  @IsOptional()\n  @IsEnum(NotificationType)\n  type?: NotificationType;\n\n  @ApiPropertyOptional({\n    enum: NotificationEntityType,\n    description: 'Filter by entity type',\n  })\n  @IsOptional()\n  @IsEnum(NotificationEntityType)\n  entityType?: NotificationEntityType;\n\n  @ApiPropertyOptional({\n    description: 'Filter by entity ID',\n  })\n  @IsOptional()\n  @IsString()\n  entityId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Page number',\n    default: 1,\n    minimum: 1,\n  })\n  @IsOptional()\n  page?: number = 1;\n\n  @ApiPropertyOptional({\n    description: 'Number of items per page',\n    default: 20,\n    minimum: 1,\n    maximum: 100,\n  })\n  @IsOptional()\n  limit?: number = 20;\n\n  @ApiPropertyOptional({\n    enum: ['newest', 'oldest'],\n    description: 'Sort order',\n    default: 'newest',\n  })\n  @IsOptional()\n  sortBy?: 'newest' | 'oldest' = 'newest';\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\interfaces\\notification-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\notification-application.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\create-notification.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":45,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":45,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":49,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":49,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":49,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":50,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":50,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":50,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":50,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":51,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":51,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":51,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":51,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":52,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":52,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":52,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":52,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":53,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":53,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":53,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":54,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":54,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":54,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":54,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":55,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":55,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":55,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":55,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":56,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":56,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":56,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":56,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":57,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":57,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":57,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":57,"endColumn":40}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { NotificationFactory } from '../../domain/factories/notification.factory';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  CreateNotificationDto,\n  NotificationResponseDto,\n} from '../dto/notification.dto';\n\nexport const NOTIFICATION_REPOSITORY_TOKEN = 'NOTIFICATION_REPOSITORY';\n\n/**\n * Use case for creating a new notification\n */\n@Injectable()\nexport class CreateNotificationUseCase {\n  constructor(\n    private readonly notificationFactory: NotificationFactory,\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  async execute(dto: CreateNotificationDto): Promise<NotificationResponseDto> {\n    // Create notification entity using factory\n    const notification = this.notificationFactory.createNotification({\n      type: dto.type,\n      userId: dto.userId,\n      entityId: dto.entityId,\n      entityType: dto.entityType,\n      customTitle: dto.title,\n      customContent: dto.content,\n    });\n\n    // Save to repository\n    const savedNotification =\n      await this.notificationRepository.save(notification);\n\n    // Convert to response DTO\n    return this.mapToResponseDto(savedNotification);\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.notificationDomainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\delete-notification.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedNotificationAccessException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n} from '../../domain/notification.exceptions';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for deleting notification(s)\n */\n@Injectable()\nexport class DeleteNotificationUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  /**\n   * Delete a single notification\n   */\n  async executeSingle(notificationId: string, userId: string): Promise<void> {\n    // Find notification\n    const notification =\n      await this.notificationRepository.findById(notificationId);\n\n    if (!notification) {\n      throw new NotificationNotFoundException(notificationId);\n    }\n\n    // Validate access permissions\n    this.notificationDomainService.validateNotificationAccess(\n      notification,\n      userId,\n    );\n\n    // Mark for deletion (adds domain event)\n    notification.delete();\n\n    // Delete from repository\n    await this.notificationRepository.delete(notificationId);\n  }\n\n  /**\n   * Delete multiple notifications\n   */\n  async executeBulk(notificationIds: string[], userId: string): Promise<void> {\n    // Find all notifications\n    const notifications =\n      await this.notificationRepository.findByIds(notificationIds);\n\n    // Validate that all notifications exist\n    const foundIds = notifications.map((n) => n.id);\n    const missingIds = notificationIds.filter((id) => !foundIds.includes(id));\n\n    if (missingIds.length > 0) {\n      throw new NotificationNotFoundException(\n        `Notifications not found: ${missingIds.join(', ')}`,\n      );\n    }\n\n    // Validate permissions for all notifications\n    this.notificationDomainService.validateBulkOperationPermissions(\n      notifications,\n      userId,\n    );\n\n    // Mark all for deletion\n    notifications.forEach((notification) => notification.delete());\n\n    // Use bulk delete for better performance\n    await this.notificationRepository.deleteBulk(notificationIds, userId);\n  }\n\n  /**\n   * Delete all read notifications for a user (cleanup)\n   */\n  async executeReadCleanup(\n    userId: string,\n    olderThanDays: number = 30,\n  ): Promise<number> {\n    // Get read notifications older than specified days\n    const result = await this.notificationRepository.findByUserId(userId, {\n      isRead: true,\n      page: 1,\n      limit: 1000, // Process in batches\n    });\n\n    const oldNotifications = result.notifications.filter((notification) => {\n      const notificationEntity = {\n        createdAt: notification.createdAt,\n        isOlderThan: (days: number) => {\n          const millisecondsInDay = 24 * 60 * 60 * 1000;\n          const age = Date.now() - notification.createdAt.getTime();\n          return age > days * millisecondsInDay;\n        },\n      };\n      return notificationEntity.isOlderThan(olderThanDays);\n    });\n\n    if (oldNotifications.length === 0) {\n      return 0;\n    }\n\n    const oldNotificationIds = oldNotifications.map((n) => n.id);\n\n    // Delete old notifications\n    await this.notificationRepository.deleteBulk(oldNotificationIds, userId);\n\n    return oldNotifications.length;\n  }\n\n  /**\n   * Delete all notifications for a user (complete cleanup)\n   */\n  async executeAllForUser(userId: string): Promise<void> {\n    // Get all notifications for user\n    const result = await this.notificationRepository.findByUserId(userId, {\n      page: 1,\n      limit: 10000, // Large limit to get all notifications\n    });\n\n    if (result.notifications.length === 0) {\n      return; // No notifications to delete\n    }\n\n    const notificationIds = result.notifications.map((n) => n.id);\n\n    // Use bulk delete\n    await this.notificationRepository.deleteBulk(notificationIds, userId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\get-notification-stats.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\get-notification.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedNotificationAccessException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":46,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":46,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":46,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":46,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":50,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":50,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":50,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":50,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":51,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":51,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":51,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":51,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":52,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":52,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":52,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":52,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":53,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":53,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":53,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":54,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":54,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":54,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":54,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":55,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":55,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":55,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":55,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":56,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":56,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":56,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":56,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":57,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":57,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":57,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":57,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":58,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":58,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":58,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":58,"endColumn":40}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n} from '../../domain/notification.exceptions';\nimport { NotificationResponseDto } from '../dto/notification.dto';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for getting a single notification\n */\n@Injectable()\nexport class GetNotificationUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  async execute(\n    notificationId: string,\n    userId: string,\n  ): Promise<NotificationResponseDto> {\n    // Find notification\n    const notification =\n      await this.notificationRepository.findById(notificationId);\n\n    if (!notification) {\n      throw new NotificationNotFoundException(notificationId);\n    }\n\n    // Validate access permissions\n    this.notificationDomainService.validateNotificationAccess(\n      notification,\n      userId,\n    );\n\n    // Convert to response DTO\n    return this.mapToResponseDto(notification);\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.notificationDomainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\get-notifications.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":53,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":53,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":53,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":57,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":57,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":57,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":57,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":58,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":58,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":58,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":58,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":59,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":59,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":59,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":59,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":60,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":60,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":60,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":60,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":61,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":61,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":61,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":61,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":62,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":62,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":62,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":62,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":63,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":63,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":63,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":63,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":64,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":64,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":64,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":64,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":65,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":65,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":65,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":65,"endColumn":40}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationQueryDto,\n  NotificationListResponseDto,\n  NotificationResponseDto,\n} from '../dto/notification.dto';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for getting user notifications with pagination and filtering\n */\n@Injectable()\nexport class GetNotificationsUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  async execute(\n    userId: string,\n    query: NotificationQueryDto,\n  ): Promise<NotificationListResponseDto> {\n    // Get notifications from repository\n    const result = await this.notificationRepository.findByUserId(userId, {\n      ...query,\n      page: query.page || 1,\n      limit: Math.min(query.limit || 20, 100), // Max 100 items per page\n    });\n\n    // Convert entities to DTOs\n    const notifications = result.notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n\n    // Calculate pagination info\n    const totalPages = Math.ceil(result.total / (query.limit || 20));\n\n    return {\n      notifications,\n      total: result.total,\n      unreadCount: result.unreadCount,\n      page: query.page || 1,\n      limit: query.limit || 20,\n      totalPages,\n    };\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.notificationDomainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\get-realtime-notifications.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":90,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":90,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":90,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":90,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":94,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":94,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":94,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":94,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":95,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":95,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":95,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":96,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":96,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":96,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":97,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":97,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":97,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":98,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":98,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":98,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":99,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":99,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":99,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":100,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":100,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":100,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":101,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":101,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":101,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":102,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":102,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":102,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":40}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport { NotificationResponseDto } from '../dto/notification.dto';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for getting real-time notifications\n * Used for WebSocket/SSE connections to get latest notifications\n */\n@Injectable()\nexport class GetRealtimeNotificationsUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  /**\n   * Get latest notifications since a specific timestamp\n   */\n  async execute(\n    userId: string,\n    sinceTimestamp: Date,\n    limit: number = 50,\n  ): Promise<NotificationResponseDto[]> {\n    // Get latest notifications from repository\n    const notifications =\n      await this.notificationRepository.getLatestNotifications(\n        userId,\n        sinceTimestamp,\n        limit,\n      );\n\n    // Convert entities to DTOs\n    return notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n  }\n\n  /**\n   * Get unread notifications for initial connection\n   */\n  async getUnreadNotifications(\n    userId: string,\n    limit: number = 20,\n  ): Promise<NotificationResponseDto[]> {\n    const result = await this.notificationRepository.findByUserId(userId, {\n      isRead: false,\n      page: 1,\n      limit,\n      sortBy: 'newest',\n    });\n\n    return result.notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n  }\n\n  /**\n   * Get notifications for a specific time range (used for reconnection)\n   */\n  async getNotificationsInRange(\n    userId: string,\n    startTime: Date,\n    endTime: Date,\n    limit: number = 100,\n  ): Promise<NotificationResponseDto[]> {\n    // This would need a new method in domain repository for time range queries\n    // For now, we'll use the existing method with since timestamp\n    const notifications =\n      await this.notificationRepository.getLatestNotifications(\n        userId,\n        startTime,\n        limit,\n      );\n\n    // Filter by end time\n    const filteredNotifications = notifications.filter(\n      (notification) => notification.createdAt <= endTime,\n    );\n\n    return filteredNotifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.notificationDomainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\mark-as-read.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedNotificationAccessException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n} from '../../domain/notification.exceptions';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for marking notification(s) as read\n */\n@Injectable()\nexport class MarkAsReadUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  /**\n   * Mark a single notification as read\n   */\n  async executeSingle(notificationId: string, userId: string): Promise<void> {\n    // Find notification\n    const notification =\n      await this.notificationRepository.findById(notificationId);\n\n    if (!notification) {\n      throw new NotificationNotFoundException(notificationId);\n    }\n\n    // Validate access permissions\n    this.notificationDomainService.validateNotificationAccess(\n      notification,\n      userId,\n    );\n\n    // Mark as read\n    notification.markAsRead();\n\n    // Save changes\n    await this.notificationRepository.save(notification);\n  }\n\n  /**\n   * Mark multiple notifications as read\n   */\n  async executeBulk(notificationIds: string[], userId: string): Promise<void> {\n    // Find all notifications\n    const notifications =\n      await this.notificationRepository.findByIds(notificationIds);\n\n    // Validate that all notifications exist\n    const foundIds = notifications.map((n) => n.id);\n    const missingIds = notificationIds.filter((id) => !foundIds.includes(id));\n\n    if (missingIds.length > 0) {\n      throw new NotificationNotFoundException(\n        `Notifications not found: ${missingIds.join(', ')}`,\n      );\n    }\n\n    // Validate permissions for all notifications\n    this.notificationDomainService.validateBulkOperationPermissions(\n      notifications,\n      userId,\n    );\n\n    // Mark all as read\n    notifications.forEach((notification) => {\n      if (!notification.isRead) {\n        notification.markAsRead();\n      }\n    });\n\n    // Use bulk update for better performance\n    await this.notificationRepository.markAsReadBulk(notificationIds, userId);\n  }\n\n  /**\n   * Mark all user notifications as read\n   */\n  async executeAll(userId: string): Promise<void> {\n    // Get all unread notifications for user\n    const result = await this.notificationRepository.findByUserId(userId, {\n      isRead: false,\n      page: 1,\n      limit: 1000, // Reasonable limit for bulk operation\n    });\n\n    if (result.notifications.length === 0) {\n      return; // No unread notifications\n    }\n\n    const notificationIds = result.notifications.map((n) => n.id);\n\n    // Use bulk update\n    await this.notificationRepository.markAsReadBulk(notificationIds, userId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\mark-as-unread.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedNotificationAccessException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n} from '../../domain/notification.exceptions';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for marking notification(s) as unread\n */\n@Injectable()\nexport class MarkAsUnreadUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  /**\n   * Mark a single notification as unread\n   */\n  async executeSingle(notificationId: string, userId: string): Promise<void> {\n    // Find notification\n    const notification =\n      await this.notificationRepository.findById(notificationId);\n\n    if (!notification) {\n      throw new NotificationNotFoundException(notificationId);\n    }\n\n    // Validate access permissions\n    this.notificationDomainService.validateNotificationAccess(\n      notification,\n      userId,\n    );\n\n    // Mark as unread\n    notification.markAsUnread();\n\n    // Save changes\n    await this.notificationRepository.save(notification);\n  }\n\n  /**\n   * Mark multiple notifications as unread\n   */\n  async executeBulk(notificationIds: string[], userId: string): Promise<void> {\n    // Find all notifications\n    const notifications =\n      await this.notificationRepository.findByIds(notificationIds);\n\n    // Validate that all notifications exist\n    const foundIds = notifications.map((n) => n.id);\n    const missingIds = notificationIds.filter((id) => !foundIds.includes(id));\n\n    if (missingIds.length > 0) {\n      throw new NotificationNotFoundException(\n        `Notifications not found: ${missingIds.join(', ')}`,\n      );\n    }\n\n    // Validate permissions for all notifications\n    this.notificationDomainService.validateBulkOperationPermissions(\n      notifications,\n      userId,\n    );\n\n    // Mark all as unread\n    notifications.forEach((notification) => {\n      if (notification.isRead) {\n        notification.markAsUnread();\n      }\n    });\n\n    // Use bulk update for better performance\n    await this.notificationRepository.markAsUnreadBulk(notificationIds, userId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\notification-cleanup.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationEntityType`.","line":69,"column":9,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":69,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationEntityType`.","line":76,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":76,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":108,"column":81,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":88}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\nexport interface CleanupResult {\n  deletedCount: number;\n  message: string;\n}\n\n/**\n * Use case for cleaning up old notifications\n * Used for maintenance and storage optimization\n */\n@Injectable()\nexport class NotificationCleanupUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  /**\n   * Clean up old read notifications for a specific user\n   */\n  async cleanupUserReadNotifications(\n    userId: string,\n    olderThanDays: number = 30,\n  ): Promise<CleanupResult> {\n    const deletedCount =\n      await this.notificationRepository.deleteReadNotifications(\n        userId,\n        olderThanDays,\n      );\n\n    return {\n      deletedCount,\n      message: `Deleted ${deletedCount} read notifications older than ${olderThanDays} days for user ${userId}`,\n    };\n  }\n\n  /**\n   * Clean up all old notifications system-wide (admin operation)\n   */\n  async cleanupSystemOldNotifications(\n    olderThanDays: number = 90,\n  ): Promise<CleanupResult> {\n    const deletedCount =\n      await this.notificationRepository.deleteOldNotifications(olderThanDays);\n\n    return {\n      deletedCount,\n      message: `System cleanup: Deleted ${deletedCount} notifications older than ${olderThanDays} days`,\n    };\n  }\n\n  /**\n   * Clean up notifications related to a deleted entity\n   */\n  async cleanupNotificationsByEntity(\n    entityId: string,\n    entityType: any, // NotificationEntityType\n    userId?: string,\n  ): Promise<CleanupResult> {\n    // Find notifications to be deleted first (for counting)\n    const notificationsToDelete =\n      await this.notificationRepository.findByEntity(\n        entityId,\n        entityType,\n        userId,\n      );\n\n    // Delete the notifications\n    await this.notificationRepository.deleteByEntity(\n      entityId,\n      entityType,\n      userId,\n    );\n\n    const deletedCount = notificationsToDelete.length;\n    const userScope = userId ? `for user ${userId}` : 'system-wide';\n\n    return {\n      deletedCount,\n      message: `Deleted ${deletedCount} notifications related to ${entityType} ${entityId} ${userScope}`,\n    };\n  }\n\n  /**\n   * Batch cleanup for multiple users (admin operation)\n   */\n  async batchCleanupUsers(\n    userIds: string[],\n    olderThanDays: number = 30,\n  ): Promise<CleanupResult[]> {\n    const results: CleanupResult[] = [];\n\n    for (const userId of userIds) {\n      try {\n        const result = await this.cleanupUserReadNotifications(\n          userId,\n          olderThanDays,\n        );\n        results.push(result);\n      } catch (error) {\n        results.push({\n          deletedCount: 0,\n          message: `Failed to cleanup notifications for user ${userId}: ${error.message}`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get cleanup statistics before performing cleanup\n   */\n  async getCleanupStats(\n    userId?: string,\n    olderThanDays: number = 30,\n  ): Promise<{\n    totalNotifications: number;\n    readNotifications: number;\n    oldReadNotifications: number;\n    estimatedCleanupCount: number;\n  }> {\n    const filters = userId ? { userId } : {};\n\n    // Get all notifications\n    const allResult = await this.notificationRepository.findAll({\n      ...filters,\n      page: 1,\n      limit: 100000, // Large number to get all\n    });\n\n    // Get read notifications\n    const readResult = await this.notificationRepository.findAll({\n      ...filters,\n      isRead: true,\n      page: 1,\n      limit: 100000,\n    });\n\n    // Calculate old read notifications\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const oldReadNotifications = readResult.notifications.filter(\n      (notification) => notification.createdAt < cutoffDate,\n    );\n\n    return {\n      totalNotifications: allResult.total,\n      readNotifications: readResult.total,\n      oldReadNotifications: oldReadNotifications.length,\n      estimatedCleanupCount: oldReadNotifications.length,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\application\\use-cases\\update-notification.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedNotificationAccessException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":71,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":71,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":71,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":75,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":75,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":75,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":75,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":76,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":76,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":76,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":76,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":77,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":77,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":77,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":77,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":78,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":78,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":78,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":78,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":79,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":79,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":79,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":79,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":80,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":80,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":80,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":80,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":81,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":81,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":81,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":81,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":82,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":82,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":82,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":82,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":83,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":83,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":83,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":83,"endColumn":40}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { INotificationDomainRepository } from '../../domain/repositories/notification-domain-repository.interface';\nimport { NotificationDomainService } from '../../domain/services/notification-domain.service';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n} from '../../domain/notification.exceptions';\nimport {\n  UpdateNotificationDto,\n  NotificationResponseDto,\n} from '../dto/notification.dto';\nimport { NOTIFICATION_REPOSITORY_TOKEN } from './create-notification.use-case';\n\n/**\n * Use case for updating a notification\n */\n@Injectable()\nexport class UpdateNotificationUseCase {\n  constructor(\n    private readonly notificationDomainService: NotificationDomainService,\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly notificationRepository: INotificationDomainRepository,\n  ) {}\n\n  async execute(\n    notificationId: string,\n    userId: string,\n    dto: UpdateNotificationDto,\n  ): Promise<NotificationResponseDto> {\n    // Find notification\n    const notification =\n      await this.notificationRepository.findById(notificationId);\n\n    if (!notification) {\n      throw new NotificationNotFoundException(notificationId);\n    }\n\n    // Validate access permissions\n    this.notificationDomainService.validateNotificationAccess(\n      notification,\n      userId,\n    );\n\n    // Update notification content if provided\n    if (dto.title || dto.content) {\n      notification.updateContent(\n        dto.title || notification.title,\n        dto.content || notification.content,\n      );\n    }\n\n    // Update read status if provided\n    if (dto.isRead !== undefined) {\n      if (dto.isRead && !notification.isRead) {\n        notification.markAsRead();\n      } else if (!dto.isRead && notification.isRead) {\n        notification.markAsUnread();\n      }\n    }\n\n    // Save changes\n    const updatedNotification =\n      await this.notificationRepository.save(notification);\n\n    // Convert to response DTO\n    return this.mapToResponseDto(updatedNotification);\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.notificationDomainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\factories\\notification.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\notification.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\notification.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\notification.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\repositories\\notification-domain-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\domain\\services\\notification-domain.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotificationEntityType' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotificationNotFoundException' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotificationBulkOperationException' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":37}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport {\n  NotificationEntity,\n  NotificationType,\n  NotificationEntityType,\n} from '../notification.entity';\nimport {\n  NotificationNotFoundException,\n  UnauthorizedNotificationAccessException,\n  NotificationBulkOperationException,\n} from '../notification.exceptions';\n\n/**\n * Domain service for complex notification business logic\n */\n@Injectable()\nexport class NotificationDomainService {\n  /**\n   * Validates if a user can access a notification\n   */\n  validateNotificationAccess(\n    notification: NotificationEntity,\n    userId: string,\n  ): void {\n    if (!notification.isOwnedBy(userId)) {\n      throw new UnauthorizedNotificationAccessException(\n        notification.id,\n        userId,\n      );\n    }\n  }\n\n  /**\n   * Validates bulk operation permissions\n   */\n  validateBulkOperationPermissions(\n    notifications: NotificationEntity[],\n    userId: string,\n  ): void {\n    const unauthorizedNotifications = notifications.filter(\n      (notification) => !notification.isOwnedBy(userId),\n    );\n\n    if (unauthorizedNotifications.length > 0) {\n      const unauthorizedIds = unauthorizedNotifications.map((n) => n.id);\n      throw new UnauthorizedNotificationAccessException(\n        `Multiple notifications: ${unauthorizedIds.join(', ')}`,\n        userId,\n      );\n    }\n  }\n\n  /**\n   * Determines notification priority based on type\n   */\n  getNotificationPriority(type: NotificationType): 'high' | 'medium' | 'low' {\n    const highPriorityTypes = [\n      NotificationType.MESSAGE,\n      NotificationType.FRIEND_REQUEST,\n    ];\n\n    const mediumPriorityTypes = [\n      NotificationType.COMMENT,\n      NotificationType.POST_MENTION,\n      NotificationType.COMMENT_MENTION,\n    ];\n\n    if (highPriorityTypes.includes(type)) {\n      return 'high';\n    }\n\n    if (mediumPriorityTypes.includes(type)) {\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  /**\n   * Checks if notifications should be grouped together\n   */\n  shouldGroupNotifications(\n    notification1: NotificationEntity,\n    notification2: NotificationEntity,\n  ): boolean {\n    // Group notifications of the same type for the same entity\n    return (\n      notification1.type === notification2.type &&\n      notification1.entityId === notification2.entityId &&\n      notification1.entityType === notification2.entityType &&\n      this.areNotificationsRecent(notification1, notification2)\n    );\n  }\n\n  /**\n   * Checks if notifications are recent enough to be grouped\n   */\n  private areNotificationsRecent(\n    notification1: NotificationEntity,\n    notification2: NotificationEntity,\n    maxHoursDifference: number = 24,\n  ): boolean {\n    const timeDifference = Math.abs(\n      notification1.createdAt.getTime() - notification2.createdAt.getTime(),\n    );\n    const maxDifference = maxHoursDifference * 60 * 60 * 1000; // Convert to milliseconds\n\n    return timeDifference <= maxDifference;\n  }\n\n  /**\n   * Generates notification content based on type and context\n   */\n  generateNotificationContent(\n    type: NotificationType,\n    context: {\n      actorName?: string;\n      entityName?: string;\n      customMessage?: string;\n    },\n  ): { title: string; content: string } {\n    switch (type) {\n      case NotificationType.LIKE:\n        return {\n          title: 'New Like',\n          content: `${context.actorName} liked your ${context.entityName || 'post'}`,\n        };\n\n      case NotificationType.COMMENT:\n        return {\n          title: 'New Comment',\n          content: `${context.actorName} commented on your ${context.entityName || 'post'}`,\n        };\n\n      case NotificationType.FOLLOW:\n        return {\n          title: 'New Follower',\n          content: `${context.actorName} started following you`,\n        };\n\n      case NotificationType.MESSAGE:\n        return {\n          title: 'New Message',\n          content: `${context.actorName} sent you a message`,\n        };\n\n      case NotificationType.POST_MENTION:\n        return {\n          title: 'You were mentioned',\n          content: `${context.actorName} mentioned you in a post`,\n        };\n\n      case NotificationType.COMMENT_MENTION:\n        return {\n          title: 'You were mentioned',\n          content: `${context.actorName} mentioned you in a comment`,\n        };\n\n      case NotificationType.FRIEND_REQUEST:\n        return {\n          title: 'Friend Request',\n          content: `${context.actorName} sent you a friend request`,\n        };\n\n      case NotificationType.BIRTHDAY:\n        return {\n          title: 'Birthday Reminder',\n          content: `It's ${context.actorName}'s birthday today!`,\n        };\n\n      case NotificationType.POST_SHARE:\n        return {\n          title: 'Post Shared',\n          content: `${context.actorName} shared your ${context.entityName || 'post'}`,\n        };\n\n      case NotificationType.SYSTEM:\n        return {\n          title: 'System Notification',\n          content:\n            context.customMessage || 'You have a new system notification',\n        };\n\n      default:\n        return {\n          title: 'New Notification',\n          content: context.customMessage || 'You have a new notification',\n        };\n    }\n  }\n\n  /**\n   * Determines if notification should be sent in real-time\n   */\n  shouldSendRealTime(type: NotificationType): boolean {\n    const realTimeTypes = [\n      NotificationType.MESSAGE,\n      NotificationType.FRIEND_REQUEST,\n      NotificationType.COMMENT,\n      NotificationType.POST_MENTION,\n      NotificationType.COMMENT_MENTION,\n    ];\n\n    return realTimeTypes.includes(type);\n  }\n\n  /**\n   * Determines if notification should be sent via email\n   */\n  shouldSendEmail(type: NotificationType): boolean {\n    const emailTypes = [\n      NotificationType.FRIEND_REQUEST,\n      NotificationType.MESSAGE,\n      NotificationType.SYSTEM,\n    ];\n\n    return emailTypes.includes(type);\n  }\n\n  /**\n   * Determines if notification should be sent via push notification\n   */\n  shouldSendPush(type: NotificationType): boolean {\n    // Most notifications should be sent via push, except system ones\n    return type !== NotificationType.SYSTEM;\n  }\n\n  /**\n   * Calculates notification digest summary\n   */\n  createNotificationDigest(notifications: NotificationEntity[]): {\n    totalCount: number;\n    unreadCount: number;\n    typeBreakdown: Record<NotificationType, number>;\n    priorityBreakdown: Record<'high' | 'medium' | 'low', number>;\n  } {\n    const digest = {\n      totalCount: notifications.length,\n      unreadCount: notifications.filter((n) => !n.isRead).length,\n      typeBreakdown: {} as Record<NotificationType, number>,\n      priorityBreakdown: { high: 0, medium: 0, low: 0 },\n    };\n\n    notifications.forEach((notification) => {\n      // Count by type\n      if (!digest.typeBreakdown[notification.type]) {\n        digest.typeBreakdown[notification.type] = 0;\n      }\n      digest.typeBreakdown[notification.type]++;\n\n      // Count by priority\n      const priority = this.getNotificationPriority(notification.type);\n      digest.priorityBreakdown[priority]++;\n    });\n\n    return digest;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\repositories\\notification-application.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `NotificationType`.","line":234,"column":7,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":234,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":234,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":234,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":238,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":238,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":238,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":238,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":239,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":239,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":239,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":239,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":240,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":240,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":240,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":240,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":241,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":241,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":241,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":241,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":242,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":242,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":242,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":242,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":243,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":243,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":243,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":243,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":244,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":244,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":244,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":244,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":245,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":245,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":245,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":245,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":246,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":246,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":246,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":246,"endColumn":40}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport {\n  INotificationRepository,\n  CreateNotificationDto,\n  UpdateNotificationDto,\n  NotificationResponseDto,\n  NotificationListResponseDto,\n  NotificationStatsDto,\n  NotificationQueryDto,\n} from '../../application';\nimport {\n  INotificationDomainRepository,\n  NotificationDomainService,\n  NotificationFactory,\n} from '../../domain';\n\nexport const NOTIFICATION_REPOSITORY_TOKEN = 'NOTIFICATION_REPOSITORY';\n\n/**\n * Application-layer repository implementation that adapts domain repository\n * This acts as an adapter between the application and domain layers\n */\n@Injectable()\nexport class NotificationApplicationRepository\n  implements INotificationRepository\n{\n  constructor(\n    @Inject(NOTIFICATION_REPOSITORY_TOKEN)\n    private readonly domainRepository: INotificationDomainRepository,\n    private readonly notificationFactory: NotificationFactory,\n    private readonly domainService: NotificationDomainService,\n  ) {}\n\n  async create(dto: CreateNotificationDto): Promise<NotificationResponseDto> {\n    // Create domain entity using factory\n    const notification = this.notificationFactory.createNotification({\n      type: dto.type,\n      userId: dto.userId,\n      entityId: dto.entityId,\n      entityType: dto.entityType,\n      customTitle: dto.title,\n      customContent: dto.content,\n    });\n\n    // Save using domain repository\n    const savedNotification = await this.domainRepository.save(notification);\n\n    // Convert to application DTO\n    return this.mapToResponseDto(savedNotification);\n  }\n\n  async findById(id: string): Promise<NotificationResponseDto | null> {\n    const notification = await this.domainRepository.findById(id);\n\n    if (!notification) {\n      return null;\n    }\n\n    return this.mapToResponseDto(notification);\n  }\n\n  async update(\n    id: string,\n    dto: UpdateNotificationDto,\n  ): Promise<NotificationResponseDto> {\n    const notification = await this.domainRepository.findById(id);\n\n    if (!notification) {\n      throw new Error(`Notification with id ${id} not found`);\n    }\n\n    // Update using domain methods\n    if (dto.title || dto.content) {\n      notification.updateContent(\n        dto.title || notification.title,\n        dto.content || notification.content,\n      );\n    }\n\n    if (dto.isRead !== undefined) {\n      if (dto.isRead && !notification.isRead) {\n        notification.markAsRead();\n      } else if (!dto.isRead && notification.isRead) {\n        notification.markAsUnread();\n      }\n    }\n\n    // Save changes\n    const updatedNotification = await this.domainRepository.save(notification);\n\n    return this.mapToResponseDto(updatedNotification);\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.domainRepository.delete(id);\n  }\n\n  async exists(id: string): Promise<boolean> {\n    return await this.domainRepository.exists(id);\n  }\n\n  async findByUserId(\n    userId: string,\n    query: NotificationQueryDto,\n  ): Promise<NotificationListResponseDto> {\n    const result = await this.domainRepository.findByUserId(userId, {\n      isRead: query.isRead,\n      type: query.type,\n      entityType: query.entityType,\n      page: query.page || 1,\n      limit: query.limit || 20,\n      sortBy: query.sortBy || 'newest',\n    });\n\n    const notifications = result.notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n\n    const totalPages = Math.ceil(result.total / (query.limit || 20));\n\n    return {\n      notifications,\n      total: result.total,\n      unreadCount: result.unreadCount,\n      page: query.page || 1,\n      limit: query.limit || 20,\n      totalPages,\n    };\n  }\n\n  async findAll(\n    query: NotificationQueryDto & { userId?: string },\n  ): Promise<NotificationListResponseDto> {\n    const result = await this.domainRepository.findAll({\n      userId: query.userId,\n      isRead: query.isRead,\n      type: query.type,\n      entityType: query.entityType,\n      entityId: query.entityId,\n      page: query.page || 1,\n      limit: query.limit || 20,\n      sortBy: query.sortBy || 'newest',\n    });\n\n    const notifications = result.notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n\n    const totalPages = Math.ceil(result.total / (query.limit || 20));\n\n    return {\n      notifications,\n      total: result.total,\n      unreadCount: 0, // Not applicable for general findAll\n      page: query.page || 1,\n      limit: query.limit || 20,\n      totalPages,\n    };\n  }\n\n  async markAsReadBulk(\n    notificationIds: string[],\n    userId: string,\n  ): Promise<void> {\n    await this.domainRepository.markAsReadBulk(notificationIds, userId);\n  }\n\n  async markAsUnreadBulk(\n    notificationIds: string[],\n    userId: string,\n  ): Promise<void> {\n    await this.domainRepository.markAsUnreadBulk(notificationIds, userId);\n  }\n\n  async deleteBulk(notificationIds: string[], userId: string): Promise<void> {\n    await this.domainRepository.deleteBulk(notificationIds, userId);\n  }\n\n  async getStats(userId: string): Promise<NotificationStatsDto> {\n    const result = await this.domainRepository.findByUserId(userId, {\n      page: 1,\n      limit: 10000, // Get all for stats\n    });\n\n    // Use domain service to create digest\n    const digest = this.domainService.createNotificationDigest(\n      result.notifications,\n    );\n\n    return {\n      totalCount: digest.totalCount,\n      unreadCount: digest.unreadCount,\n      typeBreakdown: digest.typeBreakdown,\n      priorityBreakdown: digest.priorityBreakdown,\n    };\n  }\n\n  async getUnreadCount(userId: string): Promise<number> {\n    return await this.domainRepository.getUnreadCount(userId);\n  }\n\n  async getLatestNotifications(\n    userId: string,\n    sinceTimestamp: Date,\n    limit?: number,\n  ): Promise<NotificationResponseDto[]> {\n    const notifications = await this.domainRepository.getLatestNotifications(\n      userId,\n      sinceTimestamp,\n      limit,\n    );\n\n    return notifications.map((notification) =>\n      this.mapToResponseDto(notification),\n    );\n  }\n\n  async cleanupOldNotifications(olderThanDays: number): Promise<number> {\n    return await this.domainRepository.deleteOldNotifications(olderThanDays);\n  }\n\n  async cleanupReadNotifications(\n    userId: string,\n    olderThanDays: number,\n  ): Promise<number> {\n    return await this.domainRepository.deleteReadNotifications(\n      userId,\n      olderThanDays,\n    );\n  }\n\n  private mapToResponseDto(notification: any): NotificationResponseDto {\n    const priority = this.domainService.getNotificationPriority(\n      notification.type,\n    );\n\n    return {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n      priority,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\repositories\\notification.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":89,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":93,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":93,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":97,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":109,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":109,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":114,"column":40,"nodeType":"Property","messageId":"anyAssignment","endLine":114,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":143,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":143,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":147,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":151,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":151,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":155,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":159,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":171,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":171,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":176,"column":40,"nodeType":"Property","messageId":"anyAssignment","endLine":176,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":245,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":245,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":249,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":249,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":267,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":267,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":270,"column":49,"nodeType":"Property","messageId":"anyAssignment","endLine":270,"endColumn":54},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'findUserNotificationPreferences' has no 'await' expression.","line":330,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":330,"endColumn":40,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7496,7640],"text":"findUserNotificationPreferences(userId: string): {\n    enabledTypes: NotificationType[];\n    mutedEntityIds: string[];\n  } | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":330,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":330,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":363,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":363,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":363,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":363,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":364,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":364,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":365,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":365,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":365,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":365,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":366,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":366,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":366,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":366,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":367,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":367,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":367,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":368,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":368,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isRead on an `any` value.","line":368,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":368,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":369,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":369,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":369,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":369,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":370,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":370,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":371,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":371,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":371,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":371,"endColumn":46}],"suppressedMessages":[],"errorCount":34,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport {\n  NotificationEntity,\n  NotificationType,\n  NotificationEntityType,\n  INotificationDomainRepository,\n} from '../../domain';\n\n/**\n * Prisma implementation of the notification domain repository\n */\n@Injectable()\nexport class NotificationRepository implements INotificationDomainRepository {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async save(notification: NotificationEntity): Promise<NotificationEntity> {\n    const data = {\n      id: notification.id,\n      type: notification.type,\n      title: notification.title,\n      content: notification.content,\n      userId: notification.userId,\n      isRead: notification.isRead,\n      entityId: notification.entityId,\n      entityType: notification.entityType,\n      createdAt: notification.createdAt,\n    };\n\n    const savedNotification = await this.prisma.notification.upsert({\n      where: { id: notification.id },\n      create: data,\n      update: {\n        type: data.type,\n        title: data.title,\n        content: data.content,\n        isRead: data.isRead,\n        entityId: data.entityId,\n        entityType: data.entityType,\n      },\n    });\n\n    return this.mapToDomainEntity(savedNotification);\n  }\n\n  async findById(id: string): Promise<NotificationEntity | null> {\n    const notification = await this.prisma.notification.findUnique({\n      where: { id },\n    });\n\n    if (!notification) {\n      return null;\n    }\n\n    return this.mapToDomainEntity(notification);\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.prisma.notification.delete({\n      where: { id },\n    });\n  }\n\n  async exists(id: string): Promise<boolean> {\n    const count = await this.prisma.notification.count({\n      where: { id },\n    });\n    return count > 0;\n  }\n\n  async findByUserId(\n    userId: string,\n    filters: {\n      isRead?: boolean;\n      type?: NotificationType;\n      entityType?: NotificationEntityType;\n      page: number;\n      limit: number;\n      sortBy?: 'newest' | 'oldest';\n    },\n  ): Promise<{\n    notifications: NotificationEntity[];\n    total: number;\n    unreadCount: number;\n  }> {\n    const where: any = { userId };\n\n    if (filters.isRead !== undefined) {\n      where.isRead = filters.isRead;\n    }\n\n    if (filters.type) {\n      where.type = filters.type;\n    }\n\n    if (filters.entityType) {\n      where.entityType = filters.entityType;\n    }\n\n    const orderBy = {\n      createdAt:\n        filters.sortBy === 'oldest' ? ('asc' as const) : ('desc' as const),\n    };\n\n    const skip = (filters.page - 1) * filters.limit;\n\n    const [notifications, total, unreadCount] = await Promise.all([\n      this.prisma.notification.findMany({\n        where,\n        orderBy,\n        skip,\n        take: filters.limit,\n      }),\n      this.prisma.notification.count({ where }),\n      this.prisma.notification.count({\n        where: { userId, isRead: false },\n      }),\n    ]);\n\n    return {\n      notifications: notifications.map((n) => this.mapToDomainEntity(n)),\n      total,\n      unreadCount,\n    };\n  }\n\n  async findAll(filters: {\n    userId?: string;\n    isRead?: boolean;\n    type?: NotificationType;\n    entityType?: NotificationEntityType;\n    entityId?: string;\n    page: number;\n    limit: number;\n    sortBy?: 'newest' | 'oldest';\n  }): Promise<{\n    notifications: NotificationEntity[];\n    total: number;\n  }> {\n    const where: any = {};\n\n    if (filters.userId) {\n      where.userId = filters.userId;\n    }\n\n    if (filters.isRead !== undefined) {\n      where.isRead = filters.isRead;\n    }\n\n    if (filters.type) {\n      where.type = filters.type;\n    }\n\n    if (filters.entityType) {\n      where.entityType = filters.entityType;\n    }\n\n    if (filters.entityId) {\n      where.entityId = filters.entityId;\n    }\n\n    const orderBy = {\n      createdAt:\n        filters.sortBy === 'oldest' ? ('asc' as const) : ('desc' as const),\n    };\n\n    const skip = (filters.page - 1) * filters.limit;\n\n    const [notifications, total] = await Promise.all([\n      this.prisma.notification.findMany({\n        where,\n        orderBy,\n        skip,\n        take: filters.limit,\n      }),\n      this.prisma.notification.count({ where }),\n    ]);\n\n    return {\n      notifications: notifications.map((n) => this.mapToDomainEntity(n)),\n      total,\n    };\n  }\n\n  async findByIds(ids: string[]): Promise<NotificationEntity[]> {\n    const notifications = await this.prisma.notification.findMany({\n      where: {\n        id: { in: ids },\n      },\n    });\n\n    return notifications.map((n) => this.mapToDomainEntity(n));\n  }\n\n  async markAsReadBulk(\n    notificationIds: string[],\n    userId: string,\n  ): Promise<void> {\n    await this.prisma.notification.updateMany({\n      where: {\n        id: { in: notificationIds },\n        userId, // Ensure user owns the notifications\n      },\n      data: {\n        isRead: true,\n      },\n    });\n  }\n\n  async markAsUnreadBulk(\n    notificationIds: string[],\n    userId: string,\n  ): Promise<void> {\n    await this.prisma.notification.updateMany({\n      where: {\n        id: { in: notificationIds },\n        userId, // Ensure user owns the notifications\n      },\n      data: {\n        isRead: false,\n      },\n    });\n  }\n\n  async deleteBulk(notificationIds: string[], userId: string): Promise<void> {\n    await this.prisma.notification.deleteMany({\n      where: {\n        id: { in: notificationIds },\n        userId, // Ensure user owns the notifications\n      },\n    });\n  }\n\n  async findByEntity(\n    entityId: string,\n    entityType: NotificationEntityType,\n    userId?: string,\n  ): Promise<NotificationEntity[]> {\n    const where: any = {\n      entityId,\n      entityType,\n    };\n\n    if (userId) {\n      where.userId = userId;\n    }\n\n    const notifications = await this.prisma.notification.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return notifications.map((n) => this.mapToDomainEntity(n));\n  }\n\n  async deleteByEntity(\n    entityId: string,\n    entityType: NotificationEntityType,\n    userId?: string,\n  ): Promise<void> {\n    const where: any = {\n      entityId,\n      entityType,\n    };\n\n    if (userId) {\n      where.userId = userId;\n    }\n\n    await this.prisma.notification.deleteMany({ where });\n  }\n\n  async getUnreadCount(userId: string): Promise<number> {\n    return await this.prisma.notification.count({\n      where: {\n        userId,\n        isRead: false,\n      },\n    });\n  }\n\n  async getUnreadCountByType(\n    userId: string,\n    type: NotificationType,\n  ): Promise<number> {\n    return await this.prisma.notification.count({\n      where: {\n        userId,\n        type,\n        isRead: false,\n      },\n    });\n  }\n\n  async deleteOldNotifications(olderThanDays: number): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const result = await this.prisma.notification.deleteMany({\n      where: {\n        createdAt: {\n          lt: cutoffDate,\n        },\n      },\n    });\n\n    return result.count;\n  }\n\n  async deleteReadNotifications(\n    userId: string,\n    olderThanDays: number,\n  ): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const result = await this.prisma.notification.deleteMany({\n      where: {\n        userId,\n        isRead: true,\n        createdAt: {\n          lt: cutoffDate,\n        },\n      },\n    });\n\n    return result.count;\n  }\n\n  async findUserNotificationPreferences(userId: string): Promise<{\n    enabledTypes: NotificationType[];\n    mutedEntityIds: string[];\n  } | null> {\n    // This would typically be stored in a separate preferences table\n    // For now, return default preferences\n    return {\n      enabledTypes: Object.values(NotificationType),\n      mutedEntityIds: [],\n    };\n  }\n\n  async getLatestNotifications(\n    userId: string,\n    sinceTimestamp: Date,\n    limit: number = 50,\n  ): Promise<NotificationEntity[]> {\n    const notifications = await this.prisma.notification.findMany({\n      where: {\n        userId,\n        createdAt: {\n          gt: sinceTimestamp,\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n    });\n\n    return notifications.map((n) => this.mapToDomainEntity(n));\n  }\n\n  private mapToDomainEntity(prismaNotification: any): NotificationEntity {\n    return NotificationEntity.fromPersistence({\n      id: prismaNotification.id,\n      type: prismaNotification.type as NotificationType,\n      title: prismaNotification.title,\n      content: prismaNotification.content,\n      userId: prismaNotification.userId,\n      isRead: prismaNotification.isRead,\n      entityId: prismaNotification.entityId,\n      entityType: prismaNotification.entityType as NotificationEntityType,\n      createdAt: prismaNotification.createdAt,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\services\\email-notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'entityName' is assigned a value but never used.","line":81,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { NotificationType } from '../../domain';\n\nexport interface EmailNotificationPayload {\n  to: string;\n  subject: string;\n  content: string;\n  type: NotificationType;\n  metadata?: Record<string, any>;\n}\n\nexport interface IEmailNotificationService {\n  sendNotificationEmail(payload: EmailNotificationPayload): Promise<boolean>;\n  sendBulkNotificationEmails(\n    payloads: EmailNotificationPayload[],\n  ): Promise<boolean[]>;\n}\n\n/**\n * Mock implementation of email notification service\n * In production, this would integrate with services like SendGrid, AWS SES, etc.\n */\n@Injectable()\nexport class EmailNotificationService implements IEmailNotificationService {\n  async sendNotificationEmail(\n    payload: EmailNotificationPayload,\n  ): Promise<boolean> {\n    try {\n      console.log(`[EMAIL] Sending notification email to ${payload.to}`);\n      console.log(`[EMAIL] Subject: ${payload.subject}`);\n      console.log(`[EMAIL] Type: ${payload.type}`);\n      console.log(`[EMAIL] Content: ${payload.content}`);\n\n      // In production, integrate with actual email service\n      // await this.emailProvider.send(payload);\n\n      // Simulate email sending delay\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      return true;\n    } catch (error) {\n      console.error(\n        `[EMAIL] Failed to send notification email to ${payload.to}:`,\n        error,\n      );\n      return false;\n    }\n  }\n\n  async sendBulkNotificationEmails(\n    payloads: EmailNotificationPayload[],\n  ): Promise<boolean[]> {\n    console.log(\n      `[EMAIL] Sending bulk notification emails (${payloads.length} emails)`,\n    );\n\n    const results = await Promise.allSettled(\n      payloads.map((payload) => this.sendNotificationEmail(payload)),\n    );\n\n    return results.map((result) =>\n      result.status === 'fulfilled' ? result.value : false,\n    );\n  }\n\n  /**\n   * Generate email template based on notification type\n   */\n  generateEmailTemplate(\n    type: NotificationType,\n    context: {\n      recipientName?: string;\n      actorName?: string;\n      entityName?: string;\n      appUrl?: string;\n    },\n  ): { subject: string; content: string } {\n    const {\n      recipientName = 'User',\n      actorName = 'Someone',\n      entityName = 'item',\n      appUrl = '#',\n    } = context;\n\n    switch (type) {\n      case NotificationType.FRIEND_REQUEST:\n        return {\n          subject: `${actorName} sent you a friend request`,\n          content: `\n            Hi ${recipientName},\n            \n            ${actorName} has sent you a friend request on our platform.\n            \n            Click here to view and respond: ${appUrl}/friends/requests\n            \n            Best regards,\n            The Social Media Team\n          `,\n        };\n\n      case NotificationType.MESSAGE:\n        return {\n          subject: `New message from ${actorName}`,\n          content: `\n            Hi ${recipientName},\n            \n            You have received a new message from ${actorName}.\n            \n            Click here to read the message: ${appUrl}/messages\n            \n            Best regards,\n            The Social Media Team\n          `,\n        };\n\n      case NotificationType.SYSTEM:\n        return {\n          subject: 'Important system notification',\n          content: `\n            Hi ${recipientName},\n            \n            You have received an important system notification.\n            \n            Click here to view: ${appUrl}/notifications\n            \n            Best regards,\n            The Social Media Team\n          `,\n        };\n\n      default:\n        return {\n          subject: 'New notification',\n          content: `\n            Hi ${recipientName},\n            \n            You have a new notification on our platform.\n            \n            Click here to view: ${appUrl}/notifications\n            \n            Best regards,\n            The Social Media Team\n          `,\n        };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\services\\push-notification.service.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'registerDeviceToken' has no 'await' expression.","line":92,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":92,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2620,2751],"text":"registerDeviceToken(\n    userId: string,\n    deviceToken: string,\n    platform: 'ios' | 'android' | 'web',\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'unregisterDeviceToken' has no 'await' expression.","line":114,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":114,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3254,3346],"text":"unregisterDeviceToken(\n    userId: string,\n    deviceToken: string,\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'payload' is defined but never used.","line":133,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":12}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { NotificationType } from '../../domain';\n\nexport interface PushNotificationPayload {\n  userId: string;\n  title: string;\n  body: string;\n  type: NotificationType;\n  data?: Record<string, any>;\n  badge?: number;\n  sound?: string;\n  icon?: string;\n}\n\nexport interface IPushNotificationService {\n  sendPushNotification(payload: PushNotificationPayload): Promise<boolean>;\n  sendBulkPushNotifications(\n    payloads: PushNotificationPayload[],\n  ): Promise<boolean[]>;\n  registerDeviceToken(\n    userId: string,\n    deviceToken: string,\n    platform: 'ios' | 'android' | 'web',\n  ): Promise<void>;\n  unregisterDeviceToken(userId: string, deviceToken: string): Promise<void>;\n}\n\n/**\n * Mock implementation of push notification service\n * In production, this would integrate with Firebase Cloud Messaging, Apple Push Notification Service, etc.\n */\n@Injectable()\nexport class PushNotificationService implements IPushNotificationService {\n  private readonly deviceTokens = new Map<\n    string,\n    { token: string; platform: string }[]\n  >();\n\n  async sendPushNotification(\n    payload: PushNotificationPayload,\n  ): Promise<boolean> {\n    try {\n      const userTokens = this.deviceTokens.get(payload.userId) || [];\n\n      if (userTokens.length === 0) {\n        console.log(`[PUSH] No device tokens found for user ${payload.userId}`);\n        return true; // Not an error, just no devices to notify\n      }\n\n      console.log(\n        `[PUSH] Sending push notification to ${userTokens.length} devices for user ${payload.userId}`,\n      );\n      console.log(`[PUSH] Title: ${payload.title}`);\n      console.log(`[PUSH] Body: ${payload.body}`);\n      console.log(`[PUSH] Type: ${payload.type}`);\n\n      // In production, send to actual push notification services\n      for (const deviceToken of userTokens) {\n        await this.sendToDevice(\n          deviceToken.token,\n          deviceToken.platform,\n          payload,\n        );\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\n        `[PUSH] Failed to send push notification to user ${payload.userId}:`,\n        error,\n      );\n      return false;\n    }\n  }\n\n  async sendBulkPushNotifications(\n    payloads: PushNotificationPayload[],\n  ): Promise<boolean[]> {\n    console.log(\n      `[PUSH] Sending bulk push notifications (${payloads.length} notifications)`,\n    );\n\n    const results = await Promise.allSettled(\n      payloads.map((payload) => this.sendPushNotification(payload)),\n    );\n\n    return results.map((result) =>\n      result.status === 'fulfilled' ? result.value : false,\n    );\n  }\n\n  async registerDeviceToken(\n    userId: string,\n    deviceToken: string,\n    platform: 'ios' | 'android' | 'web',\n  ): Promise<void> {\n    const userTokens = this.deviceTokens.get(userId) || [];\n\n    // Remove existing token if it exists\n    const existingIndex = userTokens.findIndex((t) => t.token === deviceToken);\n    if (existingIndex >= 0) {\n      userTokens.splice(existingIndex, 1);\n    }\n\n    // Add new token\n    userTokens.push({ token: deviceToken, platform });\n    this.deviceTokens.set(userId, userTokens);\n\n    console.log(\n      `[PUSH] Registered device token for user ${userId}, platform: ${platform}`,\n    );\n  }\n\n  async unregisterDeviceToken(\n    userId: string,\n    deviceToken: string,\n  ): Promise<void> {\n    const userTokens = this.deviceTokens.get(userId) || [];\n    const filteredTokens = userTokens.filter((t) => t.token !== deviceToken);\n\n    if (filteredTokens.length === 0) {\n      this.deviceTokens.delete(userId);\n    } else {\n      this.deviceTokens.set(userId, filteredTokens);\n    }\n\n    console.log(`[PUSH] Unregistered device token for user ${userId}`);\n  }\n\n  private async sendToDevice(\n    deviceToken: string,\n    platform: string,\n    payload: PushNotificationPayload,\n  ): Promise<void> {\n    // Simulate different platform handling\n    console.log(\n      `[PUSH] Sending to ${platform} device: ${deviceToken.substring(0, 10)}...`,\n    );\n\n    // Simulate network delay\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    // In production, this would make actual API calls to:\n    // - Firebase Cloud Messaging for Android/Web\n    // - Apple Push Notification Service for iOS\n    // - Windows Notification Service for Windows\n  }\n\n  /**\n   * Get notification priority based on type\n   */\n  getNotificationPriority(type: NotificationType): 'high' | 'normal' | 'low' {\n    const highPriorityTypes = [\n      NotificationType.MESSAGE,\n      NotificationType.FRIEND_REQUEST,\n      NotificationType.SYSTEM,\n    ];\n\n    const normalPriorityTypes = [\n      NotificationType.COMMENT,\n      NotificationType.POST_MENTION,\n      NotificationType.COMMENT_MENTION,\n    ];\n\n    if (highPriorityTypes.includes(type)) {\n      return 'high';\n    }\n\n    if (normalPriorityTypes.includes(type)) {\n      return 'normal';\n    }\n\n    return 'low';\n  }\n\n  /**\n   * Generate push notification payload from notification data\n   */\n  generatePushPayload(\n    userId: string,\n    type: NotificationType,\n    title: string,\n    content: string,\n    metadata?: Record<string, any>,\n  ): PushNotificationPayload {\n    return {\n      userId,\n      title,\n      body: content,\n      type,\n      data: {\n        type,\n        ...metadata,\n      },\n      badge: 1, // This would typically be the actual unread count\n      sound: this.getNotificationSound(type),\n      icon: this.getNotificationIcon(type),\n    };\n  }\n\n  private getNotificationSound(type: NotificationType): string {\n    switch (type) {\n      case NotificationType.MESSAGE:\n        return 'message.wav';\n      case NotificationType.FRIEND_REQUEST:\n        return 'friend_request.wav';\n      case NotificationType.SYSTEM:\n        return 'system.wav';\n      default:\n        return 'default.wav';\n    }\n  }\n\n  private getNotificationIcon(type: NotificationType): string {\n    switch (type) {\n      case NotificationType.LIKE:\n        return 'ic_like';\n      case NotificationType.COMMENT:\n        return 'ic_comment';\n      case NotificationType.FOLLOW:\n        return 'ic_follow';\n      case NotificationType.MESSAGE:\n        return 'ic_message';\n      case NotificationType.FRIEND_REQUEST:\n        return 'ic_friend_request';\n      default:\n        return 'ic_notification';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\infrastructure\\services\\realtime-notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotificationType' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":26},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'unsubscribeUser' has no 'await' expression.","line":102,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":102,"endColumn":24,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3164,3234],"text":"unsubscribeUser(userId: string, socketId: string): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { NotificationResponseDto } from '../../application';\nimport { NotificationType } from '../../domain';\n\nexport interface RealTimeNotificationPayload {\n  userId: string;\n  notification: NotificationResponseDto;\n  type:\n    | 'notification_created'\n    | 'notification_updated'\n    | 'notification_deleted'\n    | 'bulk_read';\n  timestamp: Date;\n}\n\nexport interface IRealtimeNotificationService {\n  sendToUser(\n    userId: string,\n    payload: RealTimeNotificationPayload,\n  ): Promise<boolean>;\n  sendToMultipleUsers(\n    userIds: string[],\n    payload: Omit<RealTimeNotificationPayload, 'userId'>,\n  ): Promise<boolean[]>;\n  subscribeUser(userId: string, socketId: string): Promise<void>;\n  unsubscribeUser(userId: string, socketId: string): Promise<void>;\n  broadcastUnreadCount(userId: string, count: number): Promise<boolean>;\n}\n\n/**\n * Real-time notification service using WebSocket/Server-Sent Events\n * This service manages real-time communication with connected clients\n */\n@Injectable()\nexport class RealtimeNotificationService\n  implements IRealtimeNotificationService\n{\n  private readonly userConnections = new Map<string, Set<string>>();\n\n  async sendToUser(\n    userId: string,\n    payload: RealTimeNotificationPayload,\n  ): Promise<boolean> {\n    const userSockets = this.userConnections.get(userId);\n\n    if (!userSockets || userSockets.size === 0) {\n      console.log(`[REALTIME] No active connections for user ${userId}`);\n      return true; // Not an error, user is just offline\n    }\n\n    try {\n      console.log(\n        `[REALTIME] Sending notification to ${userSockets.size} connections for user ${userId}`,\n      );\n      console.log(`[REALTIME] Type: ${payload.type}`);\n      console.log(`[REALTIME] Notification ID: ${payload.notification.id}`);\n\n      // In production, this would emit to actual WebSocket connections\n      for (const socketId of userSockets) {\n        await this.emitToSocket(socketId, 'notification', payload);\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\n        `[REALTIME] Failed to send notification to user ${userId}:`,\n        error,\n      );\n      return false;\n    }\n  }\n\n  async sendToMultipleUsers(\n    userIds: string[],\n    payload: Omit<RealTimeNotificationPayload, 'userId'>,\n  ): Promise<boolean[]> {\n    console.log(\n      `[REALTIME] Broadcasting notification to ${userIds.length} users`,\n    );\n\n    const results = await Promise.allSettled(\n      userIds.map((userId) => this.sendToUser(userId, { ...payload, userId })),\n    );\n\n    return results.map((result) =>\n      result.status === 'fulfilled' ? result.value : false,\n    );\n  }\n\n  async subscribeUser(userId: string, socketId: string): Promise<void> {\n    const userSockets = this.userConnections.get(userId) || new Set();\n    userSockets.add(socketId);\n    this.userConnections.set(userId, userSockets);\n\n    console.log(`[REALTIME] User ${userId} connected with socket ${socketId}`);\n    console.log(`[REALTIME] Total connections for user: ${userSockets.size}`);\n\n    // Send initial data when user connects\n    await this.sendInitialData(userId, socketId);\n  }\n\n  async unsubscribeUser(userId: string, socketId: string): Promise<void> {\n    const userSockets = this.userConnections.get(userId);\n\n    if (userSockets) {\n      userSockets.delete(socketId);\n\n      if (userSockets.size === 0) {\n        this.userConnections.delete(userId);\n        console.log(`[REALTIME] User ${userId} fully disconnected`);\n      } else {\n        console.log(\n          `[REALTIME] User ${userId} disconnected socket ${socketId}. Remaining connections: ${userSockets.size}`,\n        );\n      }\n    }\n  }\n\n  async broadcastUnreadCount(userId: string, count: number): Promise<boolean> {\n    const userSockets = this.userConnections.get(userId);\n\n    if (!userSockets || userSockets.size === 0) {\n      return true; // User is offline\n    }\n\n    try {\n      console.log(\n        `[REALTIME] Broadcasting unread count ${count} to user ${userId}`,\n      );\n\n      for (const socketId of userSockets) {\n        await this.emitToSocket(socketId, 'unread_count', {\n          count,\n          timestamp: new Date(),\n        });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\n        `[REALTIME] Failed to broadcast unread count to user ${userId}:`,\n        error,\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Send typing indicator for message notifications\n   */\n  async sendTypingIndicator(\n    userId: string,\n    conversationId: string,\n    isTyping: boolean,\n  ): Promise<boolean> {\n    const userSockets = this.userConnections.get(userId);\n\n    if (!userSockets || userSockets.size === 0) {\n      return true;\n    }\n\n    try {\n      for (const socketId of userSockets) {\n        await this.emitToSocket(socketId, 'typing_indicator', {\n          conversationId,\n          isTyping,\n          timestamp: new Date(),\n        });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(`[REALTIME] Failed to send typing indicator:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Send presence update (online/offline status)\n   */\n  async broadcastPresenceUpdate(\n    userId: string,\n    status: 'online' | 'offline' | 'away',\n    toUserIds: string[],\n  ): Promise<boolean[]> {\n    console.log(\n      `[REALTIME] Broadcasting presence update for user ${userId} to ${toUserIds.length} users`,\n    );\n\n    const results = await Promise.allSettled(\n      toUserIds.map(async (targetUserId) => {\n        const userSockets = this.userConnections.get(targetUserId);\n\n        if (!userSockets || userSockets.size === 0) {\n          return true;\n        }\n\n        for (const socketId of userSockets) {\n          await this.emitToSocket(socketId, 'presence_update', {\n            userId,\n            status,\n            timestamp: new Date(),\n          });\n        }\n\n        return true;\n      }),\n    );\n\n    return results.map((result) =>\n      result.status === 'fulfilled' ? result.value : false,\n    );\n  }\n\n  /**\n   * Get currently connected users count\n   */\n  getConnectedUsersCount(): number {\n    return this.userConnections.size;\n  }\n\n  /**\n   * Get connection count for a specific user\n   */\n  getUserConnectionCount(userId: string): number {\n    const userSockets = this.userConnections.get(userId);\n    return userSockets ? userSockets.size : 0;\n  }\n\n  /**\n   * Check if user is currently connected\n   */\n  isUserConnected(userId: string): boolean {\n    const userSockets = this.userConnections.get(userId);\n    return userSockets ? userSockets.size > 0 : false;\n  }\n\n  private async emitToSocket(\n    socketId: string,\n    event: string,\n    data: any,\n  ): Promise<void> {\n    // In production, this would emit to actual WebSocket connection\n    console.log(`[REALTIME] Emit to socket ${socketId}: ${event}`, data);\n\n    // Simulate network delay\n    await new Promise((resolve) => setTimeout(resolve, 10));\n  }\n\n  private async sendInitialData(\n    userId: string,\n    socketId: string,\n  ): Promise<void> {\n    try {\n      // Send unread count when user connects\n      // This would typically fetch from the notification service\n      await this.emitToSocket(socketId, 'initial_data', {\n        userId,\n        connected: true,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      console.error(\n        `[REALTIME] Failed to send initial data to user ${userId}:`,\n        error,\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\notification.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\presentation\\controllers\\notification.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiBearerAuth' is defined but never used.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CleanupResult' is defined but never used.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  Query,\n  HttpCode,\n  HttpStatus,\n  ValidationPipe,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiParam,\n  ApiQuery,\n  ApiBearerAuth,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { NotificationApplicationService } from '../../application/notification-application.service';\nimport { CleanupResult } from '../../application/use-cases/notification-cleanup.use-case';\nimport {\n  CreateNotificationRequestDto,\n  UpdateNotificationRequestDto,\n  NotificationResponseDto,\n  NotificationListResponseDto,\n  NotificationQueryRequestDto,\n  NotificationStatsResponseDto,\n  BulkNotificationActionRequestDto,\n  CleanupStatsResponseDto,\n  CleanupResultResponseDto,\n} from '../dto/notification-request.dto';\n\n/**\n * Presentation layer controller for notification operations\n * Maps HTTP requests to application services\n */\n@ApiTags('notifications')\n@Controller('notifications')\nexport class NotificationController {\n  constructor(\n    private readonly notificationApplicationService: NotificationApplicationService,\n  ) {}\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new notification' })\n  @ApiBody({ type: CreateNotificationRequestDto })\n  @ApiResponse({\n    status: 201,\n    description: 'Notification created successfully',\n    type: NotificationResponseDto,\n  })\n  @ApiResponse({ status: 400, description: 'Bad request' })\n  async create(\n    @Body(ValidationPipe) createNotificationDto: CreateNotificationRequestDto,\n  ): Promise<NotificationResponseDto> {\n    return await this.notificationApplicationService.createNotification(\n      createNotificationDto,\n    );\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: 'Get user notifications with pagination and filtering',\n  })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiQuery({ name: 'isRead', required: false, type: Boolean })\n  @ApiQuery({\n    name: 'type',\n    required: false,\n    enum: ['like', 'comment', 'follow', 'message'],\n  })\n  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })\n  @ApiQuery({ name: 'limit', required: false, type: Number, example: 20 })\n  @ApiQuery({ name: 'sortBy', required: false, enum: ['newest', 'oldest'] })\n  @ApiResponse({\n    status: 200,\n    description: 'Notifications retrieved successfully',\n    type: NotificationListResponseDto,\n  })\n  async findAll(\n    @Query('userId') userId: string,\n    @Query(ValidationPipe) query: NotificationQueryRequestDto,\n  ): Promise<NotificationListResponseDto> {\n    return await this.notificationApplicationService.getNotifications(\n      userId,\n      query,\n    );\n  }\n\n  @Get('stats/:userId')\n  @ApiOperation({ summary: 'Get notification statistics for user' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiResponse({\n    status: 200,\n    description: 'Notification statistics retrieved successfully',\n    type: NotificationStatsResponseDto,\n  })\n  async getStats(\n    @Param('userId') userId: string,\n  ): Promise<NotificationStatsResponseDto> {\n    return await this.notificationApplicationService.getNotificationStats(\n      userId,\n    );\n  }\n\n  @Get('unread-count/:userId')\n  @ApiOperation({ summary: 'Get unread notifications count' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiResponse({\n    status: 200,\n    description: 'Unread count retrieved successfully',\n    schema: {\n      type: 'object',\n      properties: {\n        count: { type: 'number', example: 5 },\n        userId: { type: 'string', example: 'user-123' },\n      },\n    },\n  })\n  async getUnreadCount(\n    @Param('userId') userId: string,\n  ): Promise<{ count: number; userId: string }> {\n    const count =\n      await this.notificationApplicationService.getUnreadCount(userId);\n    return { count, userId };\n  }\n\n  @Get('realtime/:userId')\n  @ApiOperation({ summary: 'Get real-time notifications since timestamp' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiQuery({\n    name: 'since',\n    required: true,\n    type: String,\n    description: 'ISO timestamp to get notifications since',\n    example: '2024-01-01T00:00:00.000Z',\n  })\n  @ApiQuery({ name: 'limit', required: false, type: Number, example: 50 })\n  @ApiResponse({\n    status: 200,\n    description: 'Real-time notifications retrieved successfully',\n    type: [NotificationResponseDto],\n  })\n  async getRealtimeNotifications(\n    @Param('userId') userId: string,\n    @Query('since') sinceTimestamp: string,\n    @Query('limit') limit?: number,\n  ): Promise<NotificationResponseDto[]> {\n    const since = new Date(sinceTimestamp);\n    return await this.notificationApplicationService.getLatestNotifications(\n      userId,\n      since,\n      limit || 50,\n    );\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a specific notification by ID' })\n  @ApiParam({ name: 'id', description: 'Notification ID' })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Notification retrieved successfully',\n    type: NotificationResponseDto,\n  })\n  @ApiResponse({ status: 404, description: 'Notification not found' })\n  @ApiResponse({ status: 403, description: 'Access denied' })\n  async findOne(\n    @Param('id') id: string,\n    @Query('userId') userId: string,\n  ): Promise<NotificationResponseDto> {\n    return await this.notificationApplicationService.getNotification(\n      id,\n      userId,\n    );\n  }\n\n  @Patch(':id')\n  @ApiOperation({ summary: 'Update a notification' })\n  @ApiParam({ name: 'id', description: 'Notification ID' })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiBody({ type: UpdateNotificationRequestDto })\n  @ApiResponse({\n    status: 200,\n    description: 'Notification updated successfully',\n    type: NotificationResponseDto,\n  })\n  @ApiResponse({ status: 404, description: 'Notification not found' })\n  @ApiResponse({ status: 403, description: 'Access denied' })\n  async update(\n    @Param('id') id: string,\n    @Query('userId') userId: string,\n    @Body(ValidationPipe) updateNotificationDto: UpdateNotificationRequestDto,\n  ): Promise<NotificationResponseDto> {\n    return await this.notificationApplicationService.updateNotification(\n      id,\n      userId,\n      updateNotificationDto,\n    );\n  }\n\n  @Post(':id/read')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Mark notification as read' })\n  @ApiParam({ name: 'id', description: 'Notification ID' })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiResponse({ status: 204, description: 'Notification marked as read' })\n  @ApiResponse({ status: 404, description: 'Notification not found' })\n  @ApiResponse({ status: 403, description: 'Access denied' })\n  async markAsRead(\n    @Param('id') id: string,\n    @Query('userId') userId: string,\n  ): Promise<void> {\n    await this.notificationApplicationService.markAsRead(id, userId);\n  }\n\n  @Post(':id/unread')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Mark notification as unread' })\n  @ApiParam({ name: 'id', description: 'Notification ID' })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiResponse({ status: 204, description: 'Notification marked as unread' })\n  @ApiResponse({ status: 404, description: 'Notification not found' })\n  @ApiResponse({ status: 403, description: 'Access denied' })\n  async markAsUnread(\n    @Param('id') id: string,\n    @Query('userId') userId: string,\n  ): Promise<void> {\n    await this.notificationApplicationService.markAsUnread(id, userId);\n  }\n\n  @Post('mark-read-bulk')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Mark multiple notifications as read' })\n  @ApiBody({ type: BulkNotificationActionRequestDto })\n  @ApiResponse({ status: 204, description: 'Notifications marked as read' })\n  @ApiResponse({ status: 400, description: 'Bad request' })\n  async markAsReadBulk(\n    @Query('userId') userId: string,\n    @Body(ValidationPipe) dto: BulkNotificationActionRequestDto,\n  ): Promise<void> {\n    await this.notificationApplicationService.markAsReadBulk(\n      dto.notificationIds,\n      userId,\n    );\n  }\n\n  @Post('mark-unread-bulk')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Mark multiple notifications as unread' })\n  @ApiBody({ type: BulkNotificationActionRequestDto })\n  @ApiResponse({ status: 204, description: 'Notifications marked as unread' })\n  @ApiResponse({ status: 400, description: 'Bad request' })\n  async markAsUnreadBulk(\n    @Query('userId') userId: string,\n    @Body(ValidationPipe) dto: BulkNotificationActionRequestDto,\n  ): Promise<void> {\n    await this.notificationApplicationService.markAsUnreadBulk(\n      dto.notificationIds,\n      userId,\n    );\n  }\n\n  @Post('mark-all-read/:userId')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Mark all notifications as read' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiResponse({ status: 204, description: 'All notifications marked as read' })\n  async markAllAsRead(@Param('userId') userId: string): Promise<void> {\n    await this.notificationApplicationService.markAllAsRead(userId);\n  }\n\n  @Delete(':id')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete a notification' })\n  @ApiParam({ name: 'id', description: 'Notification ID' })\n  @ApiQuery({\n    name: 'userId',\n    required: true,\n    type: String,\n    description: 'User ID',\n  })\n  @ApiResponse({\n    status: 204,\n    description: 'Notification deleted successfully',\n  })\n  @ApiResponse({ status: 404, description: 'Notification not found' })\n  @ApiResponse({ status: 403, description: 'Access denied' })\n  async remove(\n    @Param('id') id: string,\n    @Query('userId') userId: string,\n  ): Promise<void> {\n    await this.notificationApplicationService.deleteNotification(id, userId);\n  }\n\n  @Post('delete-bulk')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete multiple notifications' })\n  @ApiBody({ type: BulkNotificationActionRequestDto })\n  @ApiResponse({\n    status: 204,\n    description: 'Notifications deleted successfully',\n  })\n  @ApiResponse({ status: 400, description: 'Bad request' })\n  async deleteBulk(\n    @Query('userId') userId: string,\n    @Body(ValidationPipe) dto: BulkNotificationActionRequestDto,\n  ): Promise<void> {\n    await this.notificationApplicationService.deleteNotificationsBulk(\n      dto.notificationIds,\n      userId,\n    );\n  }\n\n  @Get('cleanup/stats/:userId')\n  @ApiOperation({ summary: 'Get cleanup statistics' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiQuery({\n    name: 'olderThanDays',\n    required: false,\n    type: Number,\n    example: 30,\n    description: 'Calculate stats for notifications older than specified days',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Cleanup statistics retrieved successfully',\n    type: CleanupStatsResponseDto,\n  })\n  async getCleanupStats(\n    @Param('userId') userId: string,\n    @Query('olderThanDays') olderThanDays?: number,\n  ): Promise<CleanupStatsResponseDto> {\n    const stats = await this.notificationApplicationService.getCleanupStats(\n      userId,\n      olderThanDays || 30,\n    );\n\n    return {\n      userId,\n      totalEligibleForCleanup: stats.estimatedCleanupCount,\n      readEligibleForCleanup: stats.readNotifications,\n      unreadEligibleForCleanup:\n        stats.totalNotifications - stats.readNotifications,\n      olderThanDays: olderThanDays || 30,\n      oldestEligibleDate: new Date(\n        Date.now() - (olderThanDays || 30) * 24 * 60 * 60 * 1000,\n      ),\n      generatedAt: new Date(),\n    };\n  }\n\n  @Post('cleanup/read/:userId')\n  @ApiOperation({ summary: 'Cleanup old read notifications' })\n  @ApiParam({ name: 'userId', description: 'User ID' })\n  @ApiQuery({\n    name: 'olderThanDays',\n    required: false,\n    type: Number,\n    example: 30,\n    description: 'Delete read notifications older than specified days',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Cleanup completed',\n    type: CleanupResultResponseDto,\n  })\n  async cleanupRead(\n    @Param('userId') userId: string,\n    @Query('olderThanDays') olderThanDays?: number,\n  ): Promise<CleanupResultResponseDto> {\n    const result =\n      await this.notificationApplicationService.cleanupUserReadNotifications(\n        userId,\n        olderThanDays || 30,\n      );\n    return {\n      userId,\n      deletedCount: result.deletedCount,\n      olderThanDays: olderThanDays || 30,\n      cleanupDate: new Date(),\n      success: true,\n    };\n  }\n\n  @Post('cleanup/system')\n  @ApiOperation({\n    summary: 'System-wide cleanup of old notifications (Admin only)',\n  })\n  @ApiQuery({\n    name: 'olderThanDays',\n    required: false,\n    type: Number,\n    example: 90,\n    description: 'Delete notifications older than specified days',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'System cleanup completed',\n    type: CleanupResultResponseDto,\n  })\n  async cleanupSystem(\n    @Query('olderThanDays') olderThanDays?: number,\n  ): Promise<CleanupResultResponseDto> {\n    const result =\n      await this.notificationApplicationService.cleanupSystemOldNotifications(\n        olderThanDays || 90,\n      );\n    return {\n      userId: 'system',\n      deletedCount: result.deletedCount,\n      olderThanDays: olderThanDays || 90,\n      cleanupDate: new Date(),\n      success: true,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\presentation\\dto\\notification-request.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":116,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":116,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":132,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":132,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":145,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":145,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsOptional,\n  IsString,\n  IsBoolean,\n  IsEnum,\n  IsArray,\n  IsInt,\n  Min,\n  Max,\n} from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform } from 'class-transformer';\nimport {\n  NotificationType,\n  NotificationEntityType,\n} from '../../domain/notification.entity';\n\nexport enum NotificationTypeDto {\n  LIKE = 'like',\n  COMMENT = 'comment',\n  FOLLOW = 'follow',\n  MESSAGE = 'message',\n}\n\nexport enum SortByDto {\n  NEWEST = 'newest',\n  OLDEST = 'oldest',\n}\n\n/**\n * Request DTOs for Notification endpoints\n */\nexport class CreateNotificationRequestDto {\n  @ApiProperty({\n    description: 'ID of the user receiving the notification',\n    example: 'user-123',\n  })\n  @IsString()\n  userId: string;\n\n  @ApiProperty({\n    description: 'Type of notification',\n    enum: NotificationType,\n    example: 'like',\n  })\n  @IsEnum(NotificationType)\n  type: NotificationType;\n\n  @ApiProperty({\n    description: 'Notification title',\n    example: 'New like on your post',\n  })\n  @IsString()\n  title: string;\n\n  @ApiProperty({\n    description: 'Notification content',\n    example: 'John Doe liked your post about clean architecture',\n  })\n  @IsString()\n  content: string;\n\n  @ApiPropertyOptional({\n    description: 'Related entity ID (post, comment, etc.)',\n    example: 'post-789',\n  })\n  @IsOptional()\n  @IsString()\n  entityId?: string;\n\n  @ApiPropertyOptional({\n    enum: NotificationEntityType,\n    description: 'Related entity type',\n    example: 'post',\n  })\n  @IsOptional()\n  @IsEnum(NotificationEntityType)\n  entityType?: NotificationEntityType;\n\n  @ApiPropertyOptional({\n    description: 'Additional metadata',\n    example: { postTitle: 'My first post' },\n  })\n  @IsOptional()\n  metadata?: Record<string, any>;\n}\n\nexport class UpdateNotificationRequestDto {\n  @ApiPropertyOptional({ description: 'Updated notification title' })\n  @IsOptional()\n  @IsString()\n  title?: string;\n\n  @ApiPropertyOptional({ description: 'Updated notification content' })\n  @IsOptional()\n  @IsString()\n  content?: string;\n\n  @ApiPropertyOptional({ description: 'Mark as read/unread' })\n  @IsOptional()\n  @IsBoolean()\n  isRead?: boolean;\n\n  @ApiPropertyOptional({ description: 'Updated metadata' })\n  @IsOptional()\n  metadata?: Record<string, any>;\n}\n\nexport class NotificationQueryRequestDto {\n  @ApiPropertyOptional({ description: 'Filter by read status' })\n  @IsOptional()\n  @IsBoolean()\n  @Transform(({ value }) => {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  })\n  isRead?: boolean;\n\n  @ApiPropertyOptional({\n    description: 'Filter by notification type',\n    enum: NotificationType,\n  })\n  @IsOptional()\n  @IsEnum(NotificationType)\n  type?: NotificationType;\n\n  @ApiPropertyOptional({ description: 'Page number', example: 1, minimum: 1 })\n  @IsOptional()\n  @IsInt()\n  @Min(1)\n  @Transform(({ value }) => parseInt(value) || 1)\n  page?: number = 1;\n\n  @ApiPropertyOptional({\n    description: 'Items per page',\n    example: 20,\n    minimum: 1,\n    maximum: 100,\n  })\n  @IsOptional()\n  @IsInt()\n  @Min(1)\n  @Max(100)\n  @Transform(({ value }) => parseInt(value) || 20)\n  limit?: number = 20;\n\n  @ApiPropertyOptional({\n    description: 'Sort order',\n    enum: SortByDto,\n    example: 'newest',\n  })\n  @IsOptional()\n  @IsEnum(SortByDto)\n  sortBy?: SortByDto = SortByDto.NEWEST;\n}\n\nexport class BulkNotificationActionRequestDto {\n  @ApiProperty({\n    description: 'Array of notification IDs',\n    type: [String],\n    example: ['notif-1', 'notif-2', 'notif-3'],\n  })\n  @IsArray()\n  @IsString({ each: true })\n  notificationIds: string[];\n}\n\n/**\n * Response DTOs for Notification endpoints\n */\nexport class NotificationResponseDto {\n  @ApiProperty({ description: 'Notification ID', example: 'notif-123' })\n  id: string;\n\n  @ApiProperty({\n    description: 'Notification type',\n    enum: NotificationType,\n    example: 'like',\n  })\n  type: NotificationType;\n\n  @ApiProperty({\n    description: 'Notification title',\n    example: 'New like on your post',\n  })\n  title: string;\n\n  @ApiProperty({\n    description: 'Notification content',\n    example: 'John Doe liked your post',\n  })\n  content: string;\n\n  @ApiProperty({\n    description: 'User ID receiving the notification',\n    example: 'user-123',\n  })\n  userId: string;\n\n  @ApiProperty({ description: 'Read status', example: false })\n  isRead: boolean;\n\n  @ApiPropertyOptional({\n    description: 'Related entity ID',\n    example: 'post-789',\n  })\n  entityId?: string;\n\n  @ApiPropertyOptional({\n    enum: NotificationEntityType,\n    description: 'Related entity type',\n    example: 'post',\n  })\n  entityType?: NotificationEntityType;\n\n  @ApiProperty({\n    description: 'Creation timestamp',\n    example: '2024-01-01T00:00:00.000Z',\n  })\n  createdAt: Date;\n\n  @ApiPropertyOptional({\n    description: 'Notification priority',\n    example: 'medium',\n  })\n  priority?: 'high' | 'medium' | 'low';\n}\n\nexport class NotificationListResponseDto {\n  @ApiProperty({\n    type: [NotificationResponseDto],\n    description: 'List of notifications',\n  })\n  notifications: NotificationResponseDto[];\n\n  @ApiProperty({ description: 'Total count of notifications' })\n  total: number;\n\n  @ApiProperty({ description: 'Count of unread notifications' })\n  unreadCount: number;\n\n  @ApiProperty({ description: 'Current page number' })\n  page: number;\n\n  @ApiProperty({ description: 'Number of items per page' })\n  limit: number;\n\n  @ApiProperty({ description: 'Total number of pages' })\n  totalPages: number;\n}\n\nexport class NotificationStatsResponseDto {\n  @ApiProperty({ description: 'Total count of notifications' })\n  totalCount: number;\n\n  @ApiProperty({ description: 'Count of unread notifications' })\n  unreadCount: number;\n\n  @ApiProperty({\n    description: 'Breakdown by notification type',\n  })\n  typeBreakdown: Record<NotificationType, number>;\n\n  @ApiProperty({\n    description: 'Breakdown by priority',\n  })\n  priorityBreakdown: Record<'high' | 'medium' | 'low', number>;\n}\n\nexport class CleanupStatsResponseDto {\n  @ApiProperty({ description: 'User ID', example: 'user-123' })\n  userId: string;\n\n  @ApiProperty({\n    description: 'Total notifications eligible for cleanup',\n    example: 50,\n  })\n  totalEligibleForCleanup: number;\n\n  @ApiProperty({\n    description: 'Read notifications eligible for cleanup',\n    example: 45,\n  })\n  readEligibleForCleanup: number;\n\n  @ApiProperty({\n    description: 'Unread notifications eligible for cleanup',\n    example: 5,\n  })\n  unreadEligibleForCleanup: number;\n\n  @ApiProperty({ description: 'Cleanup criteria (days)', example: 30 })\n  olderThanDays: number;\n\n  @ApiProperty({\n    description: 'Oldest eligible notification date',\n    example: '2023-12-01T00:00:00.000Z',\n  })\n  oldestEligibleDate: Date;\n\n  @ApiProperty({\n    description: 'Statistics generation timestamp',\n    example: '2024-01-01T12:00:00.000Z',\n  })\n  generatedAt: Date;\n}\n\nexport class CleanupResultResponseDto {\n  @ApiProperty({ description: 'User ID or system', example: 'user-123' })\n  userId: string;\n\n  @ApiProperty({ description: 'Number of notifications deleted', example: 45 })\n  deletedCount: number;\n\n  @ApiProperty({ description: 'Cleanup criteria (days)', example: 30 })\n  olderThanDays: number;\n\n  @ApiProperty({\n    description: 'Cleanup operation timestamp',\n    example: '2024-01-01T12:00:00.000Z',\n  })\n  cleanupDate: Date;\n\n  @ApiProperty({ description: 'Operation success status', example: true })\n  success: boolean;\n\n  @ApiPropertyOptional({ description: 'Error message if cleanup failed' })\n  error?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\presentation\\gateways\\notification.gateway.ts","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":38,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":47,"endColumn":8,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1147,1147],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1147,1147],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":53,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":53,"endColumn":69},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":60,"column":11,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":60,"endColumn":55,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1853,1853],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1853,1853],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":60,"column":27,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":60,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":70,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":70,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":71,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":72,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .token on an `any` value.","line":72,"column":14,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":72,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":83,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":83,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":85,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":85,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sub on an `any` value.","line":85,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":86,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":86,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .email on an `any` value.","line":86,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":86,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":87,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":19},{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":93,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":93,"endColumn":37,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[2867,2867],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[2867,2867],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'client' is defined but never used.","line":114,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'client' is defined but never used.","line":139,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":139,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'client' is defined but never used.","line":170,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":30},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyUser' has no 'await' expression.","line":190,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":190,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5579,5640],"text":"notifyUser(userId: string, payload: any): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyUsers' has no 'await' expression.","line":203,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":203,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5986,6051],"text":"notifyUsers(userIds: string[], payload: any): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'broadcast' has no 'await' expression.","line":257,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":257,"endColumn":18,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7614,7658],"text":"broadcast(payload: any): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'sendUnreadCountUpdate' has no 'await' expression.","line":269,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":269,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7960,8033],"text":"sendUnreadCountUpdate(userId: string, count: number): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'sendStatsUpdate' has no 'await' expression.","line":285,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":285,"endColumn":24,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8442,8506],"text":"sendStatsUpdate(userId: string, stats: any): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  WebSocketGateway,\n  WebSocketServer,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  SubscribeMessage,\n  MessageBody,\n  ConnectedSocket,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\nimport { Injectable, Logger } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport Redis from 'ioredis';\nimport { NotificationApplicationService } from '../../application/notification-application.service';\n\n/**\n * Presentation layer WebSocket Gateway for real-time notifications\n * Handles WebSocket connections and real-time notification delivery\n */\n@Injectable()\n@WebSocketGateway({ namespace: '/notifications', cors: true })\nexport class NotificationGateway\n  implements OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer()\n  server: Server;\n\n  private readonly redisSubscriber = new Redis(process.env.REDIS_URL as string);\n  private logger = new Logger('NotificationGateway');\n\n  constructor(\n    private readonly notificationApplicationService: NotificationApplicationService,\n    private readonly jwtService: JwtService,\n  ) {}\n\n  afterInit(server: Server) {\n    this.server = server;\n    this.redisSubscriber.subscribe('notifications', (err) => {\n      if (err) {\n        this.logger.error(\n          'Failed to subscribe to Redis channel: notifications',\n          err,\n        );\n      } else {\n        this.logger.log('Subscribed to Redis channel: notifications');\n      }\n    });\n\n    this.redisSubscriber.on('message', (channel, message) => {\n      this.logger.debug(`Received message from ${channel}: ${message}`);\n      if (channel === 'notifications') {\n        try {\n          const { targetUserId, notification } = JSON.parse(message);\n\n          if (!this.server) {\n            this.logger.warn('Socket server not ready; skipping notify');\n            return;\n          }\n\n          this.notifyUser(targetUserId, notification);\n        } catch (error) {\n          this.logger.error('Failed to parse notification message', error);\n        }\n      }\n    });\n  }\n\n  handleConnection(client: Socket) {\n    // Authenticate websocket handshake via token in query or headers\n    const query = client.handshake.query as any;\n    const token =\n      query?.token || client.handshake.headers?.authorization || null;\n\n    let userId: string | null = null;\n    let email: string | null = null;\n\n    if (token) {\n      try {\n        // support 'Bearer <token>' or raw token\n        const raw = (token as string).startsWith('Bearer')\n          ? (token as string).split(' ')[1]\n          : (token as string);\n        const payload = this.jwtService.verify(raw);\n        // assume payload.sub contains user id\n        userId = payload?.sub;\n        email = payload?.email;\n      } catch (err) {\n        this.logger.warn(`Invalid token on websocket connect: ${client.id}`);\n      }\n    }\n\n    if (userId) {\n      client.join(`user:${userId}`);\n      this.logger.log(\n        `Client ${email} authenticated and joined room user:${userId} (socket ${client.id})`,\n      );\n    } else {\n      this.logger.log(\n        `Client connected without valid auth (socket ${client.id})`,\n      );\n    }\n  }\n\n  handleDisconnect(client: Socket) {\n    this.logger.log(`Client disconnected: ${client.id}`);\n  }\n\n  /**\n   * Client can acknowledge notification (mark as read)\n   */\n  @SubscribeMessage('ack')\n  async handleAck(\n    @MessageBody() data: { notificationId: string; userId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { notificationId, userId } = data || {};\n    if (!notificationId || !userId) {\n      return { success: false, error: 'Missing notificationId or userId' };\n    }\n\n    try {\n      await this.notificationApplicationService.markAsRead(\n        notificationId,\n        userId,\n      );\n      return { success: true };\n    } catch (err) {\n      this.logger.error('Failed to ack notification', err);\n      return { success: false, error: 'Failed to mark notification as read' };\n    }\n  }\n\n  /**\n   * Client requests real-time notifications\n   */\n  @SubscribeMessage('getNotifications')\n  async handleGetNotifications(\n    @MessageBody() data: { userId: string; since?: string; limit?: number },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { userId, since, limit = 50 } = data || {};\n    if (!userId) {\n      return { success: false, error: 'Missing userId' };\n    }\n\n    try {\n      const sinceDate = since\n        ? new Date(since)\n        : new Date(Date.now() - 24 * 60 * 60 * 1000); // Last 24 hours\n      const notifications =\n        await this.notificationApplicationService.getLatestNotifications(\n          userId,\n          sinceDate,\n          limit,\n        );\n\n      return { success: true, notifications };\n    } catch (err) {\n      this.logger.error('Failed to get notifications', err);\n      return { success: false, error: 'Failed to retrieve notifications' };\n    }\n  }\n\n  /**\n   * Client requests unread count\n   */\n  @SubscribeMessage('getUnreadCount')\n  async handleGetUnreadCount(\n    @MessageBody() data: { userId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { userId } = data || {};\n    if (!userId) {\n      return { success: false, error: 'Missing userId' };\n    }\n\n    try {\n      const count =\n        await this.notificationApplicationService.getUnreadCount(userId);\n      return { success: true, count };\n    } catch (err) {\n      this.logger.error('Failed to get unread count', err);\n      return { success: false, error: 'Failed to retrieve unread count' };\n    }\n  }\n\n  /**\n   * Emit notification to a specific user by userId\n   */\n  async notifyUser(userId: string, payload: any): Promise<void> {\n    try {\n      const room = `user:${userId}`;\n      this.server.to(room).emit('notification', payload);\n      this.logger.debug(`Notification sent to user ${userId}`);\n    } catch (error) {\n      this.logger.error(`Failed to notify user ${userId}`, error);\n    }\n  }\n\n  /**\n   * Emit notification to multiple users (array of userIds)\n   */\n  async notifyUsers(userIds: string[], payload: any): Promise<void> {\n    if (!Array.isArray(userIds) || userIds.length === 0) return;\n\n    try {\n      // Emit to each user's room. Looping is simple and reliable.\n      for (const uid of userIds) {\n        const room = `user:${uid}`;\n        this.server.to(room).emit('notification', payload);\n      }\n      this.logger.debug(`Notification sent to ${userIds.length} users`);\n    } catch (error) {\n      this.logger.error('Failed to notify multiple users', error);\n    }\n  }\n\n  /**\n   * Notify users in parallel with limited concurrency to avoid blocking\n   */\n  async notifyUsersParallel(\n    userIds: string[],\n    payload: any,\n    concurrency = 20,\n  ): Promise<void> {\n    if (!Array.isArray(userIds) || userIds.length === 0) return;\n\n    try {\n      const chunks: string[][] = [];\n      for (let i = 0; i < userIds.length; i += concurrency) {\n        chunks.push(userIds.slice(i, i + concurrency));\n      }\n\n      for (const chunk of chunks) {\n        // emit for this chunk in parallel\n        await Promise.all(\n          chunk.map((uid) =>\n            this.server.to(`user:${uid}`).emit('notification', payload),\n          ),\n        );\n        // Small pause to prevent overwhelming the system\n        if (chunks.length > 1) {\n          await new Promise((resolve) => setTimeout(resolve, 10));\n        }\n      }\n      this.logger.debug(\n        `Notification sent to ${userIds.length} users in parallel`,\n      );\n    } catch (error) {\n      this.logger.error('Failed to notify users in parallel', error);\n    }\n  }\n\n  /**\n   * Broadcast to all connected clients\n   */\n  async broadcast(payload: any): Promise<void> {\n    try {\n      this.server.emit('notification', payload);\n      this.logger.debug('Notification broadcasted to all connected clients');\n    } catch (error) {\n      this.logger.error('Failed to broadcast notification', error);\n    }\n  }\n\n  /**\n   * Send unread count update to specific user\n   */\n  async sendUnreadCountUpdate(userId: string, count: number): Promise<void> {\n    try {\n      const room = `user:${userId}`;\n      this.server.to(room).emit('unreadCountUpdate', { count });\n      this.logger.debug(`Unread count update sent to user ${userId}: ${count}`);\n    } catch (error) {\n      this.logger.error(\n        `Failed to send unread count update to user ${userId}`,\n        error,\n      );\n    }\n  }\n\n  /**\n   * Send notification stats update to specific user\n   */\n  async sendStatsUpdate(userId: string, stats: any): Promise<void> {\n    try {\n      const room = `user:${userId}`;\n      this.server.to(room).emit('statsUpdate', stats);\n      this.logger.debug(`Stats update sent to user ${userId}`);\n    } catch (error) {\n      this.logger.error(`Failed to send stats update to user ${userId}`, error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\presentation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\notification\\presentation\\processors\\notification.processor.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":79,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":79,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stack on an `any` value.","line":80,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":80,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'actorUserId' is assigned a value but never used.","line":99,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'relatedEntityId' is assigned a value but never used.","line":100,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'relatedEntityType' is assigned a value but never used.","line":101,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'metadata' is assigned a value but never used.","line":102,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":116,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":116,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":163,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":163,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'content' is assigned a value but never used.","line":217,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":217,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":238,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":238,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'content' is assigned a value but never used.","line":255,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":255,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'actorUserId' is assigned a value but never used.","line":296,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":296,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'relatedEntityId' is assigned a value but never used.","line":297,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":297,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'relatedEntityType' is assigned a value but never used.","line":298,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":298,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'metadata' is assigned a value but never used.","line":299,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":324,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":324,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":355,"column":40,"nodeType":"Property","messageId":"anyAssignment","endLine":355,"endColumn":52}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Processor, WorkerHost } from '@nestjs/bullmq';\nimport { Logger } from '@nestjs/common';\nimport { Job } from 'bullmq';\nimport Redis from 'ioredis';\nimport { NotificationApplicationService } from '../../application/notification-application.service';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport { NotificationType } from '../../domain/notification.entity';\n\ninterface NotificationJobData {\n  reactorId: string;\n  targetUserId: string;\n  type: string;\n  content?: string;\n  entityId?: string;\n  entityType?: string;\n  actorUserId?: string;\n  relatedEntityId?: string;\n  relatedEntityType?: string;\n  title?: string;\n  message?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Presentation layer processor for handling notification queue jobs\n * Processes background notification tasks and publishes real-time events\n */\n@Processor('notification-queue')\nexport class NotificationProcessor extends WorkerHost {\n  private readonly logger = new Logger(NotificationProcessor.name);\n  private readonly redisClient = new Redis(\n    process.env.REDIS_URL || 'redis://localhost:6379',\n  );\n\n  constructor(\n    private readonly notificationApplicationService: NotificationApplicationService,\n    private readonly prismaService: PrismaService,\n  ) {\n    super();\n  }\n\n  async process(job: Job<NotificationJobData, any, string>): Promise<any> {\n    this.logger.log(\n      `[Job ${job.id}] Started processing job with name: ${job.name}`,\n    );\n\n    try {\n      const jobData = job.data;\n\n      const jobId = job.id || 'unknown';\n\n      switch (job.name) {\n        case 'create-notification':\n          await this.processCreateNotification(jobId, jobData);\n          break;\n        case 'reaction-notification':\n          await this.processReactionNotification(jobId, jobData);\n          break;\n        case 'follow-notification':\n          await this.processFollowNotification(jobId, jobData);\n          break;\n        case 'comment-notification':\n          await this.processCommentNotification(jobId, jobData);\n          break;\n        case 'message-notification':\n          await this.processMessageNotification(jobId, jobData);\n          break;\n        case 'bulk-notification':\n          await this.processBulkNotification(jobId, jobData);\n          break;\n        default:\n          this.logger.warn(`[Job ${jobId}] Unknown job name: ${job.name}`);\n          break;\n      }\n\n      this.logger.log(`[Job ${job.id}] Successfully processed`);\n    } catch (error) {\n      this.logger.error(\n        `[Job ${job.id}] Failed with error: ${error.message}`,\n        error.stack,\n      );\n      // Ném lỗi để BullMQ có thể thử lại job nếu cần\n      throw error;\n    }\n  }\n\n  /**\n   * Process generic notification creation\n   */\n  private async processCreateNotification(\n    jobId: string | number,\n    data: NotificationJobData,\n  ): Promise<void> {\n    const {\n      targetUserId,\n      type,\n      title,\n      message,\n      actorUserId,\n      relatedEntityId,\n      relatedEntityType,\n      metadata,\n    } = data;\n\n    if (!targetUserId || !type || !title || !message) {\n      this.logger.warn(\n        `[Job ${jobId}] Missing required fields for notification creation`,\n      );\n      return;\n    }\n\n    // Tạo thông báo trong database\n    const notification =\n      await this.notificationApplicationService.createNotification({\n        userId: targetUserId,\n        type: type as any,\n        title,\n        content: message,\n      });\n\n    // Publish sự kiện qua Redis cho real-time updates\n    await this.publishNotificationEvent(targetUserId, notification);\n\n    this.logger.log(\n      `[Job ${jobId}] Generic notification created for user ${targetUserId}`,\n    );\n  }\n\n  /**\n   * Process reaction notification (like, heart, etc.)\n   */\n  private async processReactionNotification(\n    jobId: string | number,\n    data: NotificationJobData,\n  ): Promise<void> {\n    const { reactorId, targetUserId, type, entityId, entityType } = data;\n\n    // Tìm nạp thông tin cần thiết từ cơ sở dữ liệu để đảm bảo tính nhất quán\n    const reactor = await this.prismaService.user.findUnique({\n      where: { id: reactorId },\n      select: { id: true, fullName: true, username: true },\n    });\n\n    if (!reactor) {\n      this.logger.warn(\n        `[Job ${jobId}] Reactor with ID ${reactorId} not found. Skipping notification.`,\n      );\n      return;\n    }\n\n    // Xây dựng tiêu đề và nội dung thông báo\n    const title = `New ${type} on your ${entityType}`;\n    const message = `${reactor.fullName} reacted to your ${entityType}`;\n\n    // Tạo thông báo trong database\n    const notification =\n      await this.notificationApplicationService.createNotification({\n        userId: targetUserId,\n        type: NotificationType.LIKE,\n        title,\n        content: message,\n        entityId,\n        entityType: entityType as any,\n      });\n\n    // Publish sự kiện qua Redis\n    await this.publishNotificationEvent(targetUserId, notification);\n\n    this.logger.log(\n      `[Job ${jobId}] Reaction notification created for user ${targetUserId}`,\n    );\n  }\n\n  /**\n   * Process follow notification\n   */\n  private async processFollowNotification(\n    jobId: string | number,\n    data: NotificationJobData,\n  ): Promise<void> {\n    const { actorUserId, targetUserId } = data;\n\n    const follower = await this.prismaService.user.findUnique({\n      where: { id: actorUserId },\n      select: { id: true, fullName: true, username: true },\n    });\n\n    if (!follower) {\n      this.logger.warn(\n        `[Job ${jobId}] Follower with ID ${actorUserId} not found`,\n      );\n      return;\n    }\n\n    const notification =\n      await this.notificationApplicationService.createNotification({\n        userId: targetUserId,\n        type: NotificationType.FOLLOW,\n        title: 'New follower',\n        content: `${follower.fullName} started following you`,\n      });\n\n    await this.publishNotificationEvent(targetUserId, notification);\n\n    this.logger.log(\n      `[Job ${jobId}] Follow notification created for user ${targetUserId}`,\n    );\n  }\n\n  /**\n   * Process comment notification\n   */\n  private async processCommentNotification(\n    jobId: string | number,\n    data: NotificationJobData,\n  ): Promise<void> {\n    const { actorUserId, targetUserId, entityId, entityType, content } = data;\n\n    const commenter = await this.prismaService.user.findUnique({\n      where: { id: actorUserId },\n      select: { id: true, fullName: true, username: true },\n    });\n\n    if (!commenter) {\n      this.logger.warn(\n        `[Job ${jobId}] Commenter with ID ${actorUserId} not found`,\n      );\n      return;\n    }\n\n    const notification =\n      await this.notificationApplicationService.createNotification({\n        userId: targetUserId,\n        type: NotificationType.COMMENT,\n        title: 'New comment',\n        content: `${commenter.fullName} commented on your ${entityType}`,\n        entityId,\n        entityType: entityType as any,\n      });\n\n    await this.publishNotificationEvent(targetUserId, notification);\n\n    this.logger.log(\n      `[Job ${jobId}] Comment notification created for user ${targetUserId}`,\n    );\n  }\n\n  /**\n   * Process message notification\n   */\n  private async processMessageNotification(\n    jobId: string | number,\n    data: NotificationJobData,\n  ): Promise<void> {\n    const { actorUserId, targetUserId, content } = data;\n\n    const sender = await this.prismaService.user.findUnique({\n      where: { id: actorUserId },\n      select: { id: true, fullName: true, username: true },\n    });\n\n    if (!sender) {\n      this.logger.warn(\n        `[Job ${jobId}] Sender with ID ${actorUserId} not found`,\n      );\n      return;\n    }\n\n    const notification =\n      await this.notificationApplicationService.createNotification({\n        userId: targetUserId,\n        type: NotificationType.MESSAGE,\n        title: 'New message',\n        content: `${sender.fullName} sent you a message`,\n      });\n\n    await this.publishNotificationEvent(targetUserId, notification);\n\n    this.logger.log(\n      `[Job ${jobId}] Message notification created for user ${targetUserId}`,\n    );\n  }\n\n  /**\n   * Process bulk notifications\n   */\n  private async processBulkNotification(\n    jobId: string | number,\n    data: NotificationJobData & { targetUserIds?: string[] },\n  ): Promise<void> {\n    const {\n      targetUserIds,\n      type,\n      title,\n      message,\n      actorUserId,\n      relatedEntityId,\n      relatedEntityType,\n      metadata,\n    } = data;\n\n    if (\n      !targetUserIds ||\n      !Array.isArray(targetUserIds) ||\n      targetUserIds.length === 0\n    ) {\n      this.logger.warn(\n        `[Job ${jobId}] No target users provided for bulk notification`,\n      );\n      return;\n    }\n\n    // Process in batches to avoid overwhelming the database\n    const batchSize = 50;\n    for (let i = 0; i < targetUserIds.length; i += batchSize) {\n      const batch = targetUserIds.slice(i, i + batchSize);\n\n      await Promise.all(\n        batch.map(async (userId) => {\n          try {\n            const notification =\n              await this.notificationApplicationService.createNotification({\n                userId,\n                type: type as any,\n                title: title || 'New notification',\n                content: message || 'You have a new notification',\n              });\n\n            await this.publishNotificationEvent(userId, notification);\n          } catch (error) {\n            this.logger.error(\n              `[Job ${jobId}] Failed to create notification for user ${userId}`,\n              error,\n            );\n          }\n        }),\n      );\n    }\n\n    this.logger.log(\n      `[Job ${jobId}] Bulk notifications created for ${targetUserIds.length} users`,\n    );\n  }\n\n  /**\n   * Publish notification event to Redis for real-time updates\n   */\n  private async publishNotificationEvent(\n    targetUserId: string,\n    notification: any,\n  ): Promise<void> {\n    try {\n      await this.redisClient.publish(\n        'notifications',\n        JSON.stringify({ targetUserId, notification }),\n      );\n      this.logger.debug(\n        `Published notification event for user ${targetUserId}`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to publish notification event for user ${targetUserId}`,\n        error,\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\dto\\post-media.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\interfaces\\post-media-application.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\mappers\\post-media.mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\post-media-application.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\delete-post-media.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\generate-cloudinary-signature.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\get-all-post-medias.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\get-post-media-by-id.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\get-post-medias-by-post-id.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\reorder-post-medias.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\update-post-media.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\application\\use-cases\\upload-post-medias.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":51,"column":9,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":51,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":51,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":51,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { PostMediaRepository } from '../../domain/repositories/post-media.repository';\nimport { PostMediaDomainService } from '../../domain/services/post-media-domain.service';\nimport { PostMediaFactory } from '../../domain/factories/post-media.factory';\nimport { PostMediaEntity } from '../../domain/post-media.entity';\nimport { PostMediaUploadFailedException } from '../../domain/post-media.exceptions';\n\nexport interface UploadPostMediasCommand {\n  files: Express.Multer.File[];\n  postId: string;\n  userId: string;\n  maxMediaPerPost?: number;\n}\n\n@Injectable()\nexport class UploadPostMediasUseCase {\n  constructor(\n    @Inject('POST_MEDIA_REPOSITORY')\n    private readonly postMediaRepository: PostMediaRepository,\n    private readonly postMediaDomainService: PostMediaDomainService,\n  ) {}\n\n  async execute(command: UploadPostMediasCommand): Promise<PostMediaEntity[]> {\n    try {\n      // Validate files\n      if (!command.files || command.files.length === 0) {\n        throw new PostMediaUploadFailedException(\n          'At least one file is required',\n        );\n      }\n\n      // Validate file types\n      for (const file of command.files) {\n        PostMediaFactory.validateAndGetTypeFromMimetype(file.mimetype);\n      }\n\n      // Use domain service to handle the upload logic\n      const uploadedMedias = await this.postMediaDomainService.uploadPostMedias(\n        command.files,\n        command.postId,\n        command.userId,\n        command.maxMediaPerPost || 10,\n      );\n\n      return uploadedMedias;\n    } catch (error) {\n      if (error instanceof PostMediaUploadFailedException) {\n        throw error;\n      }\n      throw new PostMediaUploadFailedException(\n        error.message || 'Unknown upload error',\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\factories\\post-media.factory.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":110,"column":9,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":111,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":113,"column":9,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":114,"endColumn":38},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":124,"column":64,"nodeType":"Identifier","messageId":"invalidType","endLine":124,"endColumn":68}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  PostMediaEntity,\n  PostMediaType,\n  PostMediaProps,\n} from '../post-media.entity';\nimport {\n  InvalidPostMediaException,\n  InvalidMediaTypeException,\n} from '../post-media.exceptions';\n\nexport interface CreatePostMediaParams {\n  url: string;\n  type: PostMediaType | string;\n  postId: string;\n  order: number;\n}\n\nexport interface PostMediaFromPersistenceParams extends PostMediaProps {\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport class PostMediaFactory {\n  /**\n   * Create a new post media entity\n   */\n  static create(params: CreatePostMediaParams): PostMediaEntity {\n    // Validate and normalize type\n    const normalizedType = this.normalizeMediaType(params.type);\n\n    // Validate required fields\n    if (!params.url?.trim()) {\n      throw new InvalidPostMediaException('URL is required');\n    }\n\n    if (!params.postId?.trim()) {\n      throw new InvalidPostMediaException('Post ID is required');\n    }\n\n    if (params.order < 1) {\n      throw new InvalidPostMediaException('Order must be greater than 0');\n    }\n\n    return PostMediaEntity.create({\n      url: params.url.trim(),\n      type: normalizedType,\n      postId: params.postId.trim(),\n      order: params.order,\n    });\n  }\n\n  /**\n   * Create multiple post media entities from uploaded files\n   */\n  static createFromUploadedFiles(\n    uploadedFiles: Array<{ url: string; type: string; resourceType?: string }>,\n    postId: string,\n    startOrder: number = 1,\n  ): PostMediaEntity[] {\n    return uploadedFiles.map((file, index) => {\n      const type = this.normalizeMediaType(file.resourceType || file.type);\n\n      return this.create({\n        url: file.url,\n        type,\n        postId,\n        order: startOrder + index,\n      });\n    });\n  }\n\n  /**\n   * Reconstruct entity from database data\n   */\n  static fromPersistence(\n    data: PostMediaFromPersistenceParams,\n  ): PostMediaEntity {\n    return PostMediaEntity.fromPersistence({\n      id: data.id,\n      url: data.url,\n      type: this.normalizeMediaType(data.type),\n      postId: data.postId,\n      order: data.order,\n      createdAt: data.createdAt,\n      updatedAt: data.updatedAt,\n    });\n  }\n\n  /**\n   * Create entities from array of persistence data\n   */\n  static fromPersistenceArray(\n    dataArray: PostMediaFromPersistenceParams[],\n  ): PostMediaEntity[] {\n    return dataArray.map((data) => this.fromPersistence(data));\n  }\n\n  /**\n   * Normalize media type string to enum\n   */\n  private static normalizeMediaType(\n    type: PostMediaType | string,\n  ): PostMediaType {\n    if (typeof type === 'string') {\n      const normalizedType = type.toLowerCase();\n\n      switch (normalizedType) {\n        case 'image':\n        case PostMediaType.IMAGE:\n          return PostMediaType.IMAGE;\n        case 'video':\n        case PostMediaType.VIDEO:\n          return PostMediaType.VIDEO;\n        default:\n          throw new InvalidMediaTypeException(`Invalid media type: ${type}`);\n      }\n    }\n\n    if (Object.values(PostMediaType).includes(type)) {\n      return type;\n    }\n\n    throw new InvalidMediaTypeException(`Invalid media type: ${type}`);\n  }\n\n  /**\n   * Validate file type from mimetype\n   */\n  static validateAndGetTypeFromMimetype(mimetype: string): PostMediaType {\n    if (mimetype.startsWith('image/')) {\n      return PostMediaType.IMAGE;\n    }\n\n    if (mimetype.startsWith('video/')) {\n      return PostMediaType.VIDEO;\n    }\n\n    throw new InvalidMediaTypeException(`Unsupported file type: ${mimetype}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\post-media.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":86,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":109,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":134,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":153,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":153,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._url on an `any` value.","line":155,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._type on an `any` value.","line":156,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":156,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._postId on an `any` value.","line":157,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":157,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._order on an `any` value.","line":158,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":158,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._createdAt on an `any` value.","line":159,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ._updatedAt on an `any` value.","line":160,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":160,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":161,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":161,"endColumn":19}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Entity } from '../../../shared/domain/entity.base';\nimport { randomUUID } from 'crypto';\n\nimport {\n  PostMediaCreatedEvent,\n  PostMediaDeletedEvent,\n  PostMediaUpdatedEvent,\n} from './post-media.events';\nimport {\n  InvalidMediaOrderException,\n  InvalidMediaTypeException,\n  InvalidPostMediaException,\n} from './post-media.exceptions';\n\nexport enum PostMediaType {\n  IMAGE = 'image',\n  VIDEO = 'video',\n}\n\nexport interface PostMediaProps {\n  id?: string;\n  url: string;\n  type: PostMediaType;\n  postId: string;\n  order: number;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport class PostMediaEntity extends Entity<string> {\n  private _url: string;\n  private _type: PostMediaType;\n  private _postId: string;\n  private _order: number;\n  private _createdAt: Date;\n  private _updatedAt: Date;\n\n  constructor(props: PostMediaProps) {\n    super(props.id || randomUUID());\n    this._url = props.url;\n    this._type = props.type;\n    this._postId = props.postId;\n    this._order = props.order;\n    this._createdAt = props.createdAt || new Date();\n    this._updatedAt = props.updatedAt || new Date();\n\n    this.validate();\n    this.addDomainEvent(\n      new PostMediaCreatedEvent({\n        id: this._id,\n        postId: this._postId,\n        url: this._url,\n        type: this._type,\n        order: this._order,\n      }),\n    );\n  }\n\n  // Getters - id is inherited from base Entity class\n\n  get url(): string {\n    return this._url;\n  }\n\n  get type(): PostMediaType {\n    return this._type;\n  }\n\n  get postId(): string {\n    return this._postId;\n  }\n\n  get order(): number {\n    return this._order;\n  }\n\n  get createdAt(): Date {\n    return this._createdAt;\n  }\n\n  get updatedAt(): Date {\n    return this._updatedAt;\n  }\n\n  // Business methods\n  public updateUrl(newUrl: string, userId: string): void {\n    if (!newUrl || newUrl.trim() === '') {\n      throw new InvalidPostMediaException('Media URL cannot be empty');\n    }\n\n    const oldUrl = this._url;\n    this._url = newUrl;\n    this._updatedAt = new Date();\n\n    this.addDomainEvent(\n      new PostMediaUpdatedEvent(\n        {\n          id: this.id,\n          postId: this._postId,\n          url: this._url,\n          type: this._type,\n          order: this._order,\n        },\n        { oldUrl, newUrl },\n      ),\n    );\n  }\n\n  public updateOrder(newOrder: number, userId: string): void {\n    if (newOrder < 1) {\n      throw new InvalidMediaOrderException(\n        'Media order must be greater than 0',\n      );\n    }\n\n    const oldOrder = this._order;\n    this._order = newOrder;\n    this._updatedAt = new Date();\n\n    this.addDomainEvent(\n      new PostMediaUpdatedEvent(\n        {\n          id: this.id,\n          postId: this._postId,\n          url: this._url,\n          type: this._type,\n          order: this._order,\n        },\n        { oldOrder, newOrder },\n      ),\n    );\n  }\n\n  public delete(userId: string): void {\n    this.addDomainEvent(\n      new PostMediaDeletedEvent({\n        id: this.id,\n        postId: this._postId,\n        url: this._url,\n        type: this._type,\n        order: this._order,\n      }),\n    );\n  }\n\n  public static create(\n    props: Omit<PostMediaProps, 'id' | 'createdAt' | 'updatedAt'>,\n  ): PostMediaEntity {\n    return new PostMediaEntity(props);\n  }\n\n  public static fromPersistence(props: PostMediaProps): PostMediaEntity {\n    const entity = Object.create(PostMediaEntity.prototype);\n    Entity.call(entity, props.id);\n    entity._url = props.url;\n    entity._type = props.type;\n    entity._postId = props.postId;\n    entity._order = props.order;\n    entity._createdAt = props.createdAt;\n    entity._updatedAt = props.updatedAt;\n    return entity;\n  }\n\n  public toPlainObject(): PostMediaProps {\n    return {\n      id: this.id,\n      url: this._url,\n      type: this._type,\n      postId: this._postId,\n      order: this._order,\n      createdAt: this._createdAt,\n      updatedAt: this._updatedAt,\n    };\n  }\n\n  private validate(): void {\n    if (!this._url || this._url.trim() === '') {\n      throw new InvalidPostMediaException('Media URL is required');\n    }\n\n    if (!this._postId || this._postId.trim() === '') {\n      throw new InvalidPostMediaException('Post ID is required');\n    }\n\n    if (!Object.values(PostMediaType).includes(this._type)) {\n      throw new InvalidMediaTypeException(`Invalid media type: ${this._type}`);\n    }\n\n    if (this._order < 1) {\n      throw new InvalidMediaOrderException(\n        'Media order must be greater than 0',\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\post-media.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\post-media.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\repositories\\post-media.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\domain\\services\\post-media-domain.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'POST_MEDIA_REPOSITORY' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'POST_SERVICE' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":15}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { PostMediaEntity, PostMediaType } from '../post-media.entity';\nimport { PostMediaRepository } from '../repositories/post-media.repository';\nimport {\n  PostMediaLimitExceededException,\n  PostMediaDuplicateException,\n  InvalidMediaTypeException,\n} from '../post-media.exceptions';\nimport {\n  POST_MEDIA_REPOSITORY,\n  CLOUDINARY_SERVICE,\n  POST_SERVICE,\n} from '../../tokens';\n\nexport interface UploadedFile {\n  url: string;\n  type: string;\n  resourceType: string;\n}\n\nexport interface CloudinaryService {\n  uploadMultipleFiles(\n    files: Express.Multer.File[],\n    folder: string,\n  ): Promise<UploadedFile[]>;\n  generateSignature(params: any): Promise<string>;\n}\n\nexport interface PostService {\n  exists(postId: string): Promise<boolean>;\n  belongsToUser(postId: string, userId: string): Promise<boolean>;\n}\n\n@Injectable()\nexport class PostMediaDomainService {\n  constructor(\n    @Inject('POST_MEDIA_REPOSITORY')\n    private readonly postMediaRepository: PostMediaRepository,\n    @Inject(CLOUDINARY_SERVICE)\n    private readonly cloudinaryService: CloudinaryService,\n    @Inject('POST_SERVICE')\n    private readonly postService: PostService,\n  ) {}\n\n  async uploadPostMedias(\n    files: Express.Multer.File[],\n    postId: string,\n    userId: string,\n    maxMediaPerPost: number = 10,\n  ): Promise<PostMediaEntity[]> {\n    // Validate post exists and user has permission\n    const postExists = await this.postService.exists(postId);\n    if (!postExists) {\n      throw new Error('Post not found');\n    }\n\n    const userOwnsPost = await this.postService.belongsToUser(postId, userId);\n    if (!userOwnsPost) {\n      throw new Error('You can only add media to your own posts');\n    }\n\n    // Check media limit\n    const currentMediaCount =\n      await this.postMediaRepository.countByPostId(postId);\n    if (currentMediaCount + files.length > maxMediaPerPost) {\n      throw new PostMediaLimitExceededException(maxMediaPerPost);\n    }\n\n    // Upload files to cloud storage\n    const uploadedFiles = await this.cloudinaryService.uploadMultipleFiles(\n      files,\n      `SocialMedia/posts/${postId}`,\n    );\n\n    // Create post media entities\n    const postMediaEntities = uploadedFiles.map((file, index) => {\n      const mediaType = this.mapResourceTypeToPostMediaType(\n        file.resourceType || file.type,\n      );\n\n      return PostMediaEntity.create({\n        url: file.url,\n        type: mediaType,\n        postId: postId,\n        order: currentMediaCount + index + 1,\n      });\n    });\n\n    // Check for duplicate URLs\n    const urls = postMediaEntities.map((media) => media.url);\n    const existingMedias = await this.postMediaRepository.findByUrls(urls);\n    if (existingMedias.length > 0) {\n      throw new PostMediaDuplicateException(existingMedias[0].url);\n    }\n\n    // Save to repository\n    return await this.postMediaRepository.saveMany(postMediaEntities);\n  }\n\n  async reorderPostMedias(\n    postId: string,\n    userId: string,\n    newOrders: Array<{ id: string; order: number }>,\n  ): Promise<void> {\n    // Validate post ownership\n    const userOwnsPost = await this.postService.belongsToUser(postId, userId);\n    if (!userOwnsPost) {\n      throw new Error('You can only reorder media on your own posts');\n    }\n\n    // Validate all media belong to the post\n    const postMedias = await this.postMediaRepository.findByPostId(postId);\n    const postMediaIds = postMedias.map((media) => media.id);\n\n    for (const orderItem of newOrders) {\n      if (!postMediaIds.includes(orderItem.id)) {\n        throw new Error(\n          `Media with id ${orderItem.id} does not belong to post ${postId}`,\n        );\n      }\n    }\n\n    // Update orders\n    await this.postMediaRepository.updateOrdersByPostId(postId, newOrders);\n  }\n\n  async generateCloudinarySignature(\n    folder: string = 'SocialMedia/posts',\n  ): Promise<{\n    signature: string;\n    timestamp: number;\n    folder: string;\n    apiKey: string;\n    cloudName: string;\n  }> {\n    const timestamp = Math.floor(Date.now() / 1000);\n    const signature = await this.cloudinaryService.generateSignature({\n      timestamp,\n      folder,\n    });\n\n    return {\n      signature,\n      timestamp,\n      folder,\n      apiKey: process.env.CLOUDINARY_API_KEY || '',\n      cloudName: process.env.CLOUDINARY_CLOUD_NAME || '',\n    };\n  }\n\n  private mapResourceTypeToPostMediaType(resourceType: string): PostMediaType {\n    switch (resourceType.toLowerCase()) {\n      case 'image':\n        return PostMediaType.IMAGE;\n      case 'video':\n        return PostMediaType.VIDEO;\n      default:\n        throw new InvalidMediaTypeException(\n          `Unsupported resource type: ${resourceType}`,\n        );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\infrastructure\\cloudinary.adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `Record<string, any>`.","line":29,"column":59,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":29,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { CloudinaryService } from '../../cloudinary/cloudinary.service';\nimport {\n  CloudinaryService as DomainCloudinaryService,\n  UploadedFile,\n} from '../domain/services/post-media-domain.service';\n\n@Injectable()\nexport class CloudinaryAdapter implements DomainCloudinaryService {\n  constructor(private readonly cloudinaryService: CloudinaryService) {}\n\n  async uploadMultipleFiles(\n    files: Express.Multer.File[],\n    folder: string,\n  ): Promise<UploadedFile[]> {\n    const uploadedFiles = await this.cloudinaryService.uploadMultipleFiles(\n      files,\n      folder,\n    );\n\n    return uploadedFiles.map((file) => ({\n      url: file.secure_url,\n      type: file.resource_type,\n      resourceType: file.resource_type,\n    }));\n  }\n\n  async generateSignature(params: any): Promise<string> {\n    return await this.cloudinaryService.generateSignature(params);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\infrastructure\\post-media.prisma.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\infrastructure\\post.adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\postMedias.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\presentation\\post-medias.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ParseIntPipe' is defined but never used.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  UseGuards,\n  UseInterceptors,\n  UploadedFiles,\n  BadRequestException,\n  Query,\n  UseFilters,\n  ParseIntPipe,\n  HttpCode,\n  HttpStatus,\n  Inject,\n} from '@nestjs/common';\nimport { FilesInterceptor } from '@nestjs/platform-express';\nimport { JwtAuthGuard } from '../../../shared/guards/jwt.guard';\nimport { CurrentUser } from '../../../shared/decorators/currentUser.decorator';\nimport { MulterExceptionFilter } from '../../../shared/filters/multer-exception.filter';\nimport { PostMediaApplicationService } from '../application/interfaces/post-media-application.interface';\nimport {\n  UploadPostMediaDto,\n  UpdatePostMediaDto,\n  ReorderPostMediaDto,\n  GetPostMediasDto,\n} from '../application/dto/post-media.dto';\n\n@Controller('post-medias')\n@UseGuards(JwtAuthGuard)\nexport class PostMediasController {\n  constructor(\n    @Inject('POST_MEDIA_APPLICATION_SERVICE')\n    private readonly postMediaApplicationService: PostMediaApplicationService,\n  ) {}\n\n  @Post('upload/:postId')\n  @UseFilters(MulterExceptionFilter)\n  @UseInterceptors(\n    FilesInterceptor('files', 10, {\n      fileFilter: (req, file, callback) => {\n        if (\n          file.mimetype.startsWith('image/') ||\n          file.mimetype.startsWith('video/')\n        ) {\n          callback(null, true);\n        } else {\n          callback(\n            new BadRequestException('Only images and videos are allowed'),\n            false,\n          );\n        }\n      },\n      limits: {\n        fileSize: 50 * 1024 * 1024, // 50MB\n      },\n    }),\n  )\n  async uploadMultiple(\n    @UploadedFiles() files: Express.Multer.File[],\n    @Param('postId') postId: string,\n    @CurrentUser('id') userId: string,\n  ) {\n    if (!files || files.length === 0) {\n      throw new BadRequestException('At least one file is required');\n    }\n\n    const uploadDto = new UploadPostMediaDto();\n    uploadDto.postId = postId;\n\n    const results = await this.postMediaApplicationService.uploadPostMedias(\n      files,\n      uploadDto,\n      userId,\n    );\n\n    return {\n      message: 'Media uploaded successfully',\n      data: results,\n    };\n  }\n\n  @Get()\n  async findAll(@Query() query: GetPostMediasDto) {\n    const result =\n      await this.postMediaApplicationService.getAllPostMedias(query);\n\n    return {\n      message: 'Post medias retrieved successfully',\n      data: result.items,\n      pagination: result.pagination,\n    };\n  }\n\n  @Get('post/:postId')\n  async findByPost(@Param('postId') postId: string) {\n    const medias =\n      await this.postMediaApplicationService.getPostMediasByPostId(postId);\n\n    return {\n      message: 'Post medias retrieved successfully',\n      data: medias,\n    };\n  }\n\n  @Get('signature')\n  async getSignature(@Query('folder') folder?: string) {\n    const signature =\n      await this.postMediaApplicationService.generateCloudinarySignature(\n        folder,\n      );\n\n    return {\n      message: 'Signature generated successfully',\n      data: signature,\n    };\n  }\n\n  @Get(':id')\n  async findOne(@Param('id') id: string) {\n    const media = await this.postMediaApplicationService.getPostMediaById(id);\n\n    return {\n      message: 'Post media retrieved successfully',\n      data: media,\n    };\n  }\n\n  @Patch(':id')\n  async update(\n    @Param('id') id: string,\n    @Body() updatePostMediaDto: UpdatePostMediaDto,\n    @CurrentUser('id') userId: string,\n  ) {\n    const result = await this.postMediaApplicationService.updatePostMedia(\n      id,\n      updatePostMediaDto,\n      userId,\n    );\n\n    return {\n      message: 'Media updated successfully',\n      data: result,\n    };\n  }\n\n  @Post('reorder')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  async reorderMedias(\n    @Body() reorderDto: ReorderPostMediaDto,\n    @CurrentUser('id') userId: string,\n  ) {\n    await this.postMediaApplicationService.reorderPostMedias(\n      reorderDto,\n      userId,\n    );\n  }\n\n  @Delete(':id')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  async remove(@Param('id') id: string, @CurrentUser('id') userId: string) {\n    await this.postMediaApplicationService.deletePostMedia(id, userId);\n  }\n\n  @Delete('post/:postId/all')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  async removeAllFromPost(\n    @Param('postId') postId: string,\n    @CurrentUser('id') userId: string,\n  ) {\n    const medias =\n      await this.postMediaApplicationService.getPostMediasByPostId(postId);\n\n    // Delete each media (this will trigger proper authorization checks)\n    await Promise.all(\n      medias.map((media) =>\n        this.postMediaApplicationService.deletePostMedia(media.id, userId),\n      ),\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\post-medias\\tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\dto\\post.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Transform' is defined but never used.","line":15,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsOptional,\n  IsEnum,\n  IsArray,\n  IsUUID,\n  ValidateNested,\n  IsNumber,\n  Min,\n  Max,\n  IsUrl,\n  IsNotEmpty,\n  MaxLength,\n} from 'class-validator';\nimport { Type, Transform } from 'class-transformer';\nimport { PostPrivacy, ReactionType } from '../../domain/post.entity';\n\n// ===== CREATE POST DTOs =====\n\nexport class CreatePostMediaDto {\n  @IsString()\n  @IsUrl()\n  url: string;\n\n  @IsEnum(['image', 'video'])\n  type: 'image' | 'video';\n\n  @IsNumber()\n  @Min(0)\n  order: number;\n}\n\nexport class CreatePostDto {\n  @IsOptional()\n  @IsString()\n  @MaxLength(2000, { message: 'Post content cannot exceed 2000 characters' })\n  content?: string;\n\n  @IsEnum(PostPrivacy)\n  @IsOptional()\n  privacy: PostPrivacy = PostPrivacy.PUBLIC;\n\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => CreatePostMediaDto)\n  media?: CreatePostMediaDto[];\n\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  hashtags?: string[];\n}\n\n// ===== UPDATE POST DTOs =====\n\nexport class UpdatePostDto {\n  @IsOptional()\n  @IsString()\n  @MaxLength(2000, { message: 'Post content cannot exceed 2000 characters' })\n  content?: string;\n\n  @IsOptional()\n  @IsEnum(PostPrivacy)\n  privacy?: PostPrivacy;\n\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => CreatePostMediaDto)\n  media?: CreatePostMediaDto[];\n\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  hashtags?: string[];\n}\n\n// ===== QUERY DTOs =====\n\nexport class GetPostsQueryDto {\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  page?: number = 1;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  @Max(50)\n  limit?: number = 10;\n\n  @IsOptional()\n  @IsUUID()\n  authorId?: string;\n\n  @IsOptional()\n  @IsEnum(PostPrivacy)\n  privacy?: PostPrivacy;\n\n  @IsOptional()\n  @IsString()\n  hashtag?: string;\n\n  @IsOptional()\n  @IsString()\n  search?: string;\n\n  @IsOptional()\n  @IsEnum(['newest', 'oldest', 'most_liked', 'most_commented'])\n  sortBy?: 'newest' | 'oldest' | 'most_liked' | 'most_commented' = 'newest';\n}\n\nexport class GetUserPostsDto {\n  @IsUUID()\n  userId: string;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  page?: number = 1;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  @Max(50)\n  limit?: number = 10;\n}\n\n// ===== REACTION DTOs =====\n\nexport class CreateReactionDto {\n  @IsEnum(ReactionType)\n  type: ReactionType;\n}\n\nexport class RemoveReactionDto {\n  // No additional fields needed - postId and userId from params/auth\n}\n\n// ===== COMMENT DTOs =====\n\nexport class CreateCommentDto {\n  @IsString()\n  @IsNotEmpty()\n  @MaxLength(500, { message: 'Comment cannot exceed 500 characters' })\n  content: string;\n\n  @IsOptional()\n  @IsUUID()\n  parentId?: string;\n}\n\nexport class UpdateCommentDto {\n  @IsString()\n  @IsNotEmpty()\n  @MaxLength(500, { message: 'Comment cannot exceed 500 characters' })\n  content: string;\n}\n\n// ===== RESPONSE DTOs =====\n\nexport class PostMediaResponseDto {\n  id: string;\n  url: string;\n  type: 'image' | 'video';\n  order: number;\n}\n\nexport class PostReactionResponseDto {\n  id: string;\n  type: ReactionType;\n  userId: string;\n  userFullName: string;\n  userAvatar?: string;\n  createdAt: Date;\n}\n\nexport class PostCommentResponseDto {\n  id: string;\n  content: string;\n  authorId: string;\n  authorFullName: string;\n  authorAvatar?: string;\n  parentId?: string;\n  repliesCount: number;\n  likesCount: number;\n  isLikedByCurrentUser?: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport class PostAuthorResponseDto {\n  id: string;\n  fullName: string;\n  username: string;\n  avatar?: string;\n  isFollowedByCurrentUser?: boolean;\n}\n\nexport class PostResponseDto {\n  id: string;\n  content?: string;\n  privacy: PostPrivacy;\n  author: PostAuthorResponseDto;\n  media: PostMediaResponseDto[];\n  hashtags: string[];\n  likesCount: number;\n  commentsCount: number;\n  isLikedByCurrentUser?: boolean;\n  currentUserReaction?: ReactionType;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport class PostDetailResponseDto extends PostResponseDto {\n  comments: PostCommentResponseDto[];\n  reactions: PostReactionResponseDto[];\n}\n\nexport class PostListResponseDto {\n  posts: PostResponseDto[];\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\n// ===== STATISTICS DTOs =====\n\nexport class PostStatsResponseDto {\n  totalPosts: number;\n  totalLikes: number;\n  totalComments: number;\n  postsThisMonth: number;\n  topHashtags: Array<{\n    hashtag: string;\n    count: number;\n  }>;\n  engagementRate: number;\n}\n\n// ===== FEED DTOs =====\n\nexport class GetFeedDto {\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  page?: number = 1;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsNumber()\n  @Min(1)\n  @Max(20)\n  limit?: number = 10;\n\n  @IsOptional()\n  @IsEnum(['timeline', 'following', 'trending'])\n  feedType?: 'timeline' | 'following' | 'trending' = 'timeline';\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\interfaces\\post-repository.interface.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PostListResponseDto' is defined but never used.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PostResponseDto' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PostEntity } from '../../domain/post.entity';\nimport {\n  GetPostsQueryDto,\n  PostListResponseDto,\n  PostResponseDto,\n} from '../dto/post.dto';\n\nexport interface IPostRepository {\n  // Create & Update\n  save(post: PostEntity): Promise<PostEntity>;\n\n  // Read operations\n  findById(id: string): Promise<PostEntity | null>;\n  findByAuthorId(\n    authorId: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    posts: PostEntity[];\n    total: number;\n  }>;\n  findAll(query: GetPostsQueryDto): Promise<{\n    posts: PostEntity[];\n    total: number;\n  }>;\n  findByHashtag(\n    hashtag: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    posts: PostEntity[];\n    total: number;\n  }>;\n\n  // Delete\n  delete(id: string): Promise<void>;\n\n  // Reactions\n  addReaction(\n    postId: string,\n    userId: string,\n    reactionType: string,\n  ): Promise<void>;\n  removeReaction(postId: string, userId: string): Promise<void>;\n  getUserReaction(postId: string, userId: string): Promise<string | null>;\n\n  // Comments\n  addComment(\n    postId: string,\n    commentId: string,\n    content: string,\n    authorId: string,\n    parentId?: string,\n  ): Promise<void>;\n  removeComment(postId: string, commentId: string): Promise<void>;\n  updateComment(commentId: string, content: string): Promise<void>;\n\n  // Statistics\n  getPostStats(postId: string): Promise<{\n    likesCount: number;\n    commentsCount: number;\n    sharesCount: number;\n  }>;\n\n  // Feed operations\n  getUserFeed(\n    userId: string,\n    page: number,\n    limit: number,\n  ): Promise<{\n    posts: PostEntity[];\n    total: number;\n  }>;\n  getTrendingPosts(\n    page: number,\n    limit: number,\n  ): Promise<{\n    posts: PostEntity[];\n    total: number;\n  }>;\n\n  // Existence checks\n  exists(id: string): Promise<boolean>;\n\n  // Bulk operations\n  findByIds(ids: string[]): Promise<PostEntity[]>;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\post-application.service.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'enrichPostResponse' has no 'await' expression.","line":213,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":213,"endColumn":35,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5474,5556],"text":"enrichPostResponse(\n    post: PostResponseDto,\n  ): PostResponseDto"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'enrichPostDetailResponse' has no 'await' expression.","line":231,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":231,"endColumn":41,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5999,6099],"text":"enrichPostDetailResponse(\n    post: PostDetailResponseDto,\n  ): PostDetailResponseDto"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'enrichCommentResponse' has no 'await' expression.","line":260,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":260,"endColumn":38,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6915,7017],"text":"enrichCommentResponse(\n    comment: PostCommentResponseDto,\n  ): PostCommentResponseDto"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { CreatePostUseCase } from './use-cases/create-post.use-case';\nimport { UpdatePostUseCase } from './use-cases/update-post.use-case';\nimport { DeletePostUseCase } from './use-cases/delete-post.use-case';\nimport {\n  GetPostByIdUseCase,\n  GetPostsUseCase,\n  GetUserFeedUseCase,\n} from './use-cases/get-post.use-case';\nimport {\n  AddReactionUseCase,\n  RemoveReactionUseCase,\n  ToggleReactionUseCase,\n} from './use-cases/react-post.use-case';\nimport {\n  AddCommentUseCase,\n  UpdateCommentUseCase,\n  DeleteCommentUseCase,\n} from './use-cases/comment-post.use-case';\nimport {\n  CreatePostDto,\n  UpdatePostDto,\n  GetPostsQueryDto,\n  CreateReactionDto,\n  CreateCommentDto,\n  UpdateCommentDto,\n  GetFeedDto,\n  PostResponseDto,\n  PostDetailResponseDto,\n  PostListResponseDto,\n  PostCommentResponseDto,\n} from './dto/post.dto';\n\n/**\n * Application Service for Post domain\n * Coordinates use cases and provides a clean interface for controllers\n */\n@Injectable()\nexport class PostApplicationService {\n  constructor(\n    // Post management use cases\n    private readonly createPostUseCase: CreatePostUseCase,\n    private readonly updatePostUseCase: UpdatePostUseCase,\n    private readonly deletePostUseCase: DeletePostUseCase,\n\n    // Post retrieval use cases\n    private readonly getPostByIdUseCase: GetPostByIdUseCase,\n    private readonly getPostsUseCase: GetPostsUseCase,\n    private readonly getUserFeedUseCase: GetUserFeedUseCase,\n\n    // Reaction use cases\n    private readonly addReactionUseCase: AddReactionUseCase,\n    private readonly removeReactionUseCase: RemoveReactionUseCase,\n    private readonly toggleReactionUseCase: ToggleReactionUseCase,\n\n    // Comment use cases\n    private readonly addCommentUseCase: AddCommentUseCase,\n    private readonly updateCommentUseCase: UpdateCommentUseCase,\n    private readonly deleteCommentUseCase: DeleteCommentUseCase,\n  ) {}\n\n  // ===== POST MANAGEMENT =====\n\n  async createPost(\n    authorId: string,\n    dto: CreatePostDto,\n  ): Promise<PostResponseDto> {\n    const result = await this.createPostUseCase.execute(authorId, dto);\n    return this.enrichPostResponse(result);\n  }\n\n  async updatePost(\n    postId: string,\n    userId: string,\n    dto: UpdatePostDto,\n  ): Promise<PostResponseDto> {\n    const result = await this.updatePostUseCase.execute(postId, userId, dto);\n    return this.enrichPostResponse(result);\n  }\n\n  async deletePost(\n    postId: string,\n    userId: string,\n    userRole?: string,\n  ): Promise<void> {\n    return this.deletePostUseCase.execute(postId, userId, userRole);\n  }\n\n  // ===== POST RETRIEVAL =====\n\n  async getPostById(\n    postId: string,\n    viewerId?: string,\n    isFollowing?: boolean,\n  ): Promise<PostDetailResponseDto> {\n    const result = await this.getPostByIdUseCase.execute(\n      postId,\n      viewerId,\n      isFollowing,\n    );\n    return this.enrichPostDetailResponse(result);\n  }\n\n  async getPosts(\n    query: GetPostsQueryDto,\n    viewerId?: string,\n  ): Promise<PostListResponseDto> {\n    const result = await this.getPostsUseCase.execute(query, viewerId);\n\n    // Enrich each post with user information\n    const enrichedPosts = await Promise.all(\n      result.posts.map((post) => this.enrichPostResponse(post)),\n    );\n\n    return {\n      ...result,\n      posts: enrichedPosts,\n    };\n  }\n\n  async getUserFeed(\n    userId: string,\n    dto: GetFeedDto,\n  ): Promise<PostListResponseDto> {\n    const result = await this.getUserFeedUseCase.execute(\n      userId,\n      dto.page || 1,\n      dto.limit || 10,\n    );\n\n    // Enrich each post with user information\n    const enrichedPosts = await Promise.all(\n      result.posts.map((post) => this.enrichPostResponse(post)),\n    );\n\n    return {\n      ...result,\n      posts: enrichedPosts,\n    };\n  }\n\n  // ===== REACTIONS =====\n\n  async addReaction(\n    postId: string,\n    userId: string,\n    dto: CreateReactionDto,\n  ): Promise<void> {\n    return this.addReactionUseCase.execute(postId, userId, dto);\n  }\n\n  async removeReaction(postId: string, userId: string): Promise<void> {\n    return this.removeReactionUseCase.execute(postId, userId);\n  }\n\n  async toggleReaction(\n    postId: string,\n    userId: string,\n    dto: CreateReactionDto,\n  ): Promise<{\n    action: 'added' | 'removed' | 'changed';\n    reactionType?: string;\n  }> {\n    return this.toggleReactionUseCase.execute(postId, userId, dto);\n  }\n\n  // ===== COMMENTS =====\n\n  async addComment(\n    postId: string,\n    authorId: string,\n    dto: CreateCommentDto,\n  ): Promise<PostCommentResponseDto> {\n    const result = await this.addCommentUseCase.execute(postId, authorId, dto);\n    return this.enrichCommentResponse(result);\n  }\n\n  async updateComment(\n    postId: string,\n    commentId: string,\n    userId: string,\n    dto: UpdateCommentDto,\n  ): Promise<PostCommentResponseDto> {\n    const result = await this.updateCommentUseCase.execute(\n      postId,\n      commentId,\n      userId,\n      dto,\n    );\n    return this.enrichCommentResponse(result);\n  }\n\n  async deleteComment(\n    postId: string,\n    commentId: string,\n    userId: string,\n    userRole?: string,\n  ): Promise<void> {\n    return this.deleteCommentUseCase.execute(\n      postId,\n      commentId,\n      userId,\n      userRole,\n    );\n  }\n\n  // ===== PRIVATE HELPER METHODS =====\n\n  /**\n   * Enriches post response with additional user information\n   * In a real implementation, this would fetch user data from UserApplicationService\n   */\n  private async enrichPostResponse(\n    post: PostResponseDto,\n  ): Promise<PostResponseDto> {\n    // TODO: Integrate with UserApplicationService to fetch user details\n    // For now, return the post as-is\n    return {\n      ...post,\n      author: {\n        ...post.author,\n        fullName: 'User ' + post.author.id.substring(0, 8), // Placeholder\n        username: '@user' + post.author.id.substring(0, 4), // Placeholder\n      },\n    };\n  }\n\n  /**\n   * Enriches post detail response with additional user information\n   */\n  private async enrichPostDetailResponse(\n    post: PostDetailResponseDto,\n  ): Promise<PostDetailResponseDto> {\n    // TODO: Integrate with UserApplicationService to fetch user details\n    const enrichedComments = post.comments.map((comment) => ({\n      ...comment,\n      authorFullName: 'User ' + comment.authorId.substring(0, 8), // Placeholder\n    }));\n\n    const enrichedReactions = post.reactions.map((reaction) => ({\n      ...reaction,\n      userFullName: 'User ' + reaction.userId.substring(0, 8), // Placeholder\n    }));\n\n    return {\n      ...post,\n      author: {\n        ...post.author,\n        fullName: 'User ' + post.author.id.substring(0, 8), // Placeholder\n        username: '@user' + post.author.id.substring(0, 4), // Placeholder\n      },\n      comments: enrichedComments,\n      reactions: enrichedReactions,\n    };\n  }\n\n  /**\n   * Enriches comment response with additional user information\n   */\n  private async enrichCommentResponse(\n    comment: PostCommentResponseDto,\n  ): Promise<PostCommentResponseDto> {\n    // TODO: Integrate with UserApplicationService to fetch user details\n    return {\n      ...comment,\n      authorFullName: 'User ' + comment.authorId.substring(0, 8), // Placeholder\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\comment-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\create-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\delete-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\get-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\react-post.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\application\\use-cases\\update-post.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ForbiddenException' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  Inject,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { randomUUID } from 'crypto';\nimport { PostEntity } from '../../domain/post.entity';\nimport { PostDomainService } from '../../domain/services/post-domain.service';\nimport { IPostDomainRepository } from '../../domain/repositories/post-domain-repository.interface';\nimport { UpdatePostDto, PostResponseDto } from '../dto/post.dto';\nimport { POST_REPOSITORY_TOKEN } from './create-post.use-case';\n\n/**\n * Use case for updating an existing post\n */\n@Injectable()\nexport class UpdatePostUseCase {\n  constructor(\n    private readonly postDomainService: PostDomainService,\n    @Inject(POST_REPOSITORY_TOKEN)\n    private readonly postRepository: IPostDomainRepository,\n  ) {}\n\n  async execute(\n    postId: string,\n    userId: string,\n    dto: UpdatePostDto,\n  ): Promise<PostResponseDto> {\n    // Find existing post\n    const post = await this.postRepository.findById(postId);\n    if (!post) {\n      throw new NotFoundException(`Post with ID ${postId} not found`);\n    }\n\n    // Validate user permissions\n    this.postDomainService.validatePostEdit(post, userId);\n\n    // Update post content if provided\n    if (dto.content !== undefined) {\n      const hashtags =\n        dto.hashtags || this.postDomainService.extractHashtags(dto.content);\n      post.updateContent(dto.content, hashtags);\n    }\n\n    // Update privacy if provided\n    if (dto.privacy !== undefined) {\n      post.changePrivacy(dto.privacy);\n    }\n\n    // Update media if provided\n    if (dto.media !== undefined) {\n      // Clear existing media and add new ones\n      post.clearMedia();\n      dto.media.forEach((mediaData) => {\n        const media = {\n          id: randomUUID(),\n          url: mediaData.url,\n          type: mediaData.type,\n          order: mediaData.order,\n        };\n        post.addMedia(media);\n      });\n    }\n\n    // Save updated post\n    const updatedPost = await this.postRepository.save(post);\n\n    // Convert to response DTO\n    return this.mapToResponseDto(updatedPost);\n  }\n\n  private mapToResponseDto(post: PostEntity): PostResponseDto {\n    return {\n      id: post.id,\n      content: post.content,\n      privacy: post.privacy,\n      author: {\n        id: post.authorId,\n        fullName: '', // Will be populated by application service\n        username: '',\n        avatar: undefined,\n      },\n      media: post.media.map((m) => ({\n        id: m.id,\n        url: m.url,\n        type: m.type,\n        order: m.order,\n      })),\n      hashtags: post.hashtags,\n      likesCount: post.reactions.length,\n      commentsCount: post.comments.length,\n      createdAt: post.createdAt,\n      updatedAt: post.updatedAt,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\factories\\post.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\post.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PostNotFoundException' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnauthorizedPostActionException' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DomainException' is defined but never used.","line":21,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any[]`.","line":326,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":326,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":326,"column":34,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":326,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":326,"column":34,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":326,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":326,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":326,"endColumn":49}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Entity } from '../../../shared/domain/entity.base';\nimport { randomUUID } from 'crypto';\nimport {\n  PostCreatedEvent,\n  PostUpdatedEvent,\n  PostDeletedEvent,\n  PostLikedEvent,\n  PostUnlikedEvent,\n  PostCommentedEvent,\n} from './post.events';\nimport {\n  InvalidPostContentException,\n  PostNotFoundException,\n  UnauthorizedPostActionException,\n  PostAlreadyLikedException,\n  PostNotLikedException,\n  EmptyPostContentException,\n} from './post.exceptions';\n\n// Simple DomainException class for now\nclass DomainException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DomainException';\n  }\n}\n\nexport enum PostPrivacy {\n  PUBLIC = 'public',\n  FOLLOWERS = 'followers',\n  PRIVATE = 'private',\n}\n\nexport enum ReactionType {\n  LIKE = 'like',\n  LOVE = 'love',\n  LAUGH = 'laugh',\n  ANGRY = 'angry',\n  SAD = 'sad',\n}\n\nexport interface PostMedia {\n  id: string;\n  url: string;\n  type: 'image' | 'video';\n  order: number;\n}\n\nexport interface PostReaction {\n  id: string;\n  type: ReactionType;\n  userId: string;\n  createdAt: Date;\n}\n\nexport interface PostComment {\n  id: string;\n  content: string;\n  authorId: string;\n  parentId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface PostProps {\n  id?: string;\n  content?: string;\n  privacy: PostPrivacy;\n  authorId: string;\n  media?: PostMedia[];\n  reactions?: PostReaction[];\n  comments?: PostComment[];\n  hashtags?: string[];\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport class PostEntity extends Entity<string> {\n  private _content?: string;\n  private _privacy: PostPrivacy;\n  private _authorId: string;\n  private _media: PostMedia[] = [];\n  private _reactions: PostReaction[] = [];\n  private _comments: PostComment[] = [];\n  private _hashtags: string[] = [];\n  private _createdAt: Date;\n  private _updatedAt: Date;\n\n  constructor(props: PostProps) {\n    super(props.id || randomUUID());\n    this._content = props.content;\n    this._privacy = props.privacy;\n    this._authorId = props.authorId;\n    this._media = props.media || [];\n    this._reactions = props.reactions || [];\n    this._comments = props.comments || [];\n    this._hashtags = props.hashtags || [];\n    this._createdAt = props.createdAt || new Date();\n    this._updatedAt = props.updatedAt || new Date();\n\n    this.validate();\n\n    if (!props.id) {\n      this.addDomainEvent(\n        new PostCreatedEvent(\n          this.id,\n          this._authorId,\n          this._content,\n          this._privacy,\n        ),\n      );\n    }\n  }\n\n  // Getters\n  get content(): string | undefined {\n    return this._content;\n  }\n\n  get privacy(): PostPrivacy {\n    return this._privacy;\n  }\n\n  get authorId(): string {\n    return this._authorId;\n  }\n\n  get media(): PostMedia[] {\n    return [...this._media];\n  }\n\n  get reactions(): PostReaction[] {\n    return [...this._reactions];\n  }\n\n  get comments(): PostComment[] {\n    return [...this._comments];\n  }\n\n  get hashtags(): string[] {\n    return [...this._hashtags];\n  }\n\n  get createdAt(): Date {\n    return this._createdAt;\n  }\n\n  get updatedAt(): Date {\n    return this._updatedAt;\n  }\n\n  get likesCount(): number {\n    return this._reactions.filter((r) => r.type === ReactionType.LIKE).length;\n  }\n\n  get commentsCount(): number {\n    return this._comments.length;\n  }\n\n  // Domain methods\n  updateContent(newContent?: string, hashtags?: string[]): void {\n    if (\n      newContent !== undefined &&\n      newContent.trim() === '' &&\n      (!this._media || this._media.length === 0)\n    ) {\n      throw new EmptyPostContentException();\n    }\n\n    const oldContent = this._content;\n    this._content = newContent;\n    this._hashtags = hashtags || this.extractHashtags(newContent);\n    this._updatedAt = new Date();\n\n    this.validate();\n\n    this.addDomainEvent(\n      new PostUpdatedEvent(this.id, this._authorId, oldContent, newContent),\n    );\n  }\n\n  changePrivacy(newPrivacy: PostPrivacy): void {\n    if (this._privacy !== newPrivacy) {\n      this._privacy = newPrivacy;\n      this.validate();\n    }\n  }\n\n  addMedia(media: PostMedia): void {\n    const exists = this._media.find((m) => m.id === media.id);\n    if (!exists) {\n      this._media.push(media);\n      this._media.sort((a, b) => a.order - b.order);\n    }\n  }\n\n  removeMedia(mediaId: string): void {\n    this._media = this._media.filter((m) => m.id !== mediaId);\n  }\n\n  clearMedia(): void {\n    this._media = [];\n  }\n\n  addReaction(userId: string, type: ReactionType): void {\n    const existingReaction = this._reactions.find((r) => r.userId === userId);\n\n    if (existingReaction) {\n      if (existingReaction.type === type) {\n        throw new PostAlreadyLikedException();\n      }\n      // Update existing reaction type\n      existingReaction.type = type;\n    } else {\n      const reaction: PostReaction = {\n        id: this.generateId(),\n        type,\n        userId,\n        createdAt: new Date(),\n      };\n      this._reactions.push(reaction);\n    }\n\n    this.addDomainEvent(new PostLikedEvent(this.id, userId, type));\n  }\n\n  removeReaction(userId: string): void {\n    const reactionIndex = this._reactions.findIndex((r) => r.userId === userId);\n\n    if (reactionIndex === -1) {\n      throw new PostNotLikedException();\n    }\n\n    const reaction = this._reactions[reactionIndex];\n    this._reactions.splice(reactionIndex, 1);\n\n    this.addDomainEvent(new PostUnlikedEvent(this.id, userId, reaction.type));\n  }\n\n  addComment(\n    commentId: string,\n    content: string,\n    authorId: string,\n    parentId?: string,\n  ): void {\n    const comment: PostComment = {\n      id: commentId,\n      content,\n      authorId,\n      parentId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this._comments.push(comment);\n\n    this.addDomainEvent(\n      new PostCommentedEvent(this.id, commentId, authorId, content),\n    );\n  }\n\n  removeComment(commentId: string): void {\n    this._comments = this._comments.filter((c) => c.id !== commentId);\n  }\n\n  updateComment(commentId: string, content: string): void {\n    const comment = this._comments.find((c) => c.id === commentId);\n    if (comment) {\n      comment.content = content;\n      comment.updatedAt = new Date();\n      this._updatedAt = new Date();\n    }\n  }\n\n  canBeViewedBy(viewerId: string): boolean {\n    switch (this._privacy) {\n      case PostPrivacy.PUBLIC:\n        return true;\n      case PostPrivacy.PRIVATE:\n        return this._authorId === viewerId;\n      case PostPrivacy.FOLLOWERS:\n        // This would need to check if viewer follows author\n        // For now, just check if viewer is author\n        return this._authorId === viewerId;\n      default:\n        return false;\n    }\n  }\n\n  canBeEditedBy(userId: string): boolean {\n    return this._authorId === userId;\n  }\n\n  canBeDeletedBy(userId: string): boolean {\n    return this._authorId === userId;\n  }\n\n  delete(): void {\n    this.addDomainEvent(new PostDeletedEvent(this.id, this._authorId));\n  }\n\n  private validate(): void {\n    if (!this._authorId) {\n      throw new InvalidPostContentException('Author ID is required');\n    }\n\n    if (!this._content && (!this._media || this._media.length === 0)) {\n      throw new EmptyPostContentException();\n    }\n\n    if (this._content && this._content.length > 2000) {\n      throw new InvalidPostContentException(\n        'Post content exceeds maximum length',\n      );\n    }\n\n    if (!Object.values(PostPrivacy).includes(this._privacy)) {\n      throw new InvalidPostContentException('Invalid privacy setting');\n    }\n  }\n\n  private extractHashtags(content?: string): string[] {\n    if (!content) return [];\n\n    const hashtags = content.match(/#\\w+/g) || [];\n    return hashtags.map((tag) => tag.toLowerCase());\n  }\n\n  private generateId(): string {\n    return randomUUID();\n  }\n\n  // Static factory methods\n  static createNew(\n    props: Omit<PostProps, 'id' | 'createdAt' | 'updatedAt'>,\n  ): PostEntity {\n    return new PostEntity(props);\n  }\n\n  static fromPersistence(props: PostProps): PostEntity {\n    return new PostEntity(props);\n  }\n\n  // Convert to persistence format\n  toPersistence() {\n    return {\n      id: this.id,\n      content: this._content,\n      privacy: this._privacy,\n      authorId: this._authorId,\n      media: this._media,\n      reactions: this._reactions,\n      comments: this._comments,\n      hashtags: this._hashtags,\n      createdAt: this._createdAt,\n      updatedAt: this._updatedAt,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\post.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\post.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\repositories\\post-domain-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\repositories\\post.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\domain\\services\\post-domain.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\infrastructure\\post.prisma.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'savedPost' is assigned a value but never used.","line":29,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .authorId on an `any` value.","line":225,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":225,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .privacy on an `any` value.","line":229,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":229,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .hashtags on an `any` value.","line":233,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":233,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":243,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":243,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":265,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":265,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":289,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":289,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":293,"column":32,"nodeType":"Property","messageId":"anyAssignment","endLine":293,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":533,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":533,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":533,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":533,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":534,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":534,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":534,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":534,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":535,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":535,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .authorId on an `any` value.","line":535,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":535,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .privacy on an `any` value.","line":536,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":536,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":537,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":537,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":537,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":537,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .hashtags on an `any` value.","line":537,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":537,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":537,"column":47,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":537,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .hashtag on an `any` value.","line":537,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":537,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":538,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":543,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":538,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":538,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postMedia on an `any` value.","line":538,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":538,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":539,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":539,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":539,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":539,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":540,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":540,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .url on an `any` value.","line":540,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":540,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":541,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":541,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":542,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":542,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .order on an `any` value.","line":542,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":542,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":544,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":549,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":544,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":544,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .reactions on an `any` value.","line":544,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":544,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":545,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":545,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":545,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":545,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":546,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":546,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .reactorId on an `any` value.","line":546,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":546,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":547,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":547,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":548,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":548,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":548,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":548,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":550,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":557,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":550,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":550,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .comments on an `any` value.","line":550,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":550,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":551,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":551,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":551,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":551,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":552,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":552,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":552,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":552,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":553,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":553,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .authorId on an `any` value.","line":553,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":553,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":554,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":554,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":554,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":554,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":555,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":555,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":555,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":555,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":556,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":556,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":556,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":556,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":558,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":558,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":558,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":558,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":559,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":559,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":559,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":559,"endColumn":32}],"suppressedMessages":[],"errorCount":59,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport { PostEntity, PostPrivacy, ReactionType } from '../domain/post.entity';\nimport { PostFactory } from '../domain/factories/post.factory';\nimport { IPostDomainRepository } from '../domain/repositories/post-domain-repository.interface';\n\n/**\n * Prisma implementation of Post repository\n * Handles persistence operations using Prisma ORM\n */\n@Injectable()\nexport class PostPrismaRepository implements IPostDomainRepository {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly postFactory: PostFactory,\n  ) {}\n\n  async save(post: PostEntity): Promise<PostEntity> {\n    const data = {\n      id: post.id,\n      content: post.content,\n      privacy: post.privacy,\n      authorId: post.authorId,\n      createdAt: post.createdAt,\n      updatedAt: post.updatedAt,\n    };\n\n    // Upsert the post\n    const savedPost = await this.prisma.post.upsert({\n      where: { id: post.id },\n      create: data,\n      update: {\n        content: data.content,\n        privacy: data.privacy,\n        updatedAt: data.updatedAt,\n      },\n      include: {\n        author: true,\n        reactions: true,\n        comments: {\n          include: {\n            author: true,\n          },\n        },\n        postMedia: true,\n        hashtags: {\n          include: {\n            hashtag: true,\n          },\n        },\n      },\n    });\n\n    // Handle media - delete existing and create new ones\n    await this.prisma.postMedia.deleteMany({\n      where: { postId: post.id },\n    });\n\n    if (post.media.length > 0) {\n      await this.prisma.postMedia.createMany({\n        data: post.media.map((media) => ({\n          id: media.id,\n          postId: post.id,\n          url: media.url,\n          type: media.type,\n          order: media.order,\n        })),\n      });\n    }\n\n    // Handle hashtags - delete existing relationships and create new ones\n    await this.prisma.postHashtag.deleteMany({\n      where: { postId: post.id },\n    });\n\n    if (post.hashtags.length > 0) {\n      for (const hashtagName of post.hashtags) {\n        // Ensure hashtag exists\n        const hashtag = await this.prisma.hashtag.upsert({\n          where: { name: hashtagName },\n          create: { name: hashtagName },\n          update: {},\n        });\n\n        // Create relationship\n        await this.prisma.postHashtag.create({\n          data: {\n            postId: post.id,\n            hashtagId: hashtag.id,\n          },\n        });\n      }\n    }\n\n    // Handle reactions - sync reactions\n    const existingReactions = await this.prisma.reaction.findMany({\n      where: { postId: post.id },\n    });\n\n    const currentReactionIds = post.reactions.map((r) => r.id);\n    const existingReactionIds = existingReactions.map((r) => r.id);\n\n    // Delete removed reactions\n    const reactionsToDelete = existingReactionIds.filter(\n      (id) => !currentReactionIds.includes(id),\n    );\n    if (reactionsToDelete.length > 0) {\n      await this.prisma.reaction.deleteMany({\n        where: { id: { in: reactionsToDelete } },\n      });\n    }\n\n    // Create new reactions\n    const newReactions = post.reactions.filter(\n      (r) => !existingReactionIds.includes(r.id),\n    );\n    if (newReactions.length > 0) {\n      await this.prisma.reaction.createMany({\n        data: newReactions.map((reaction) => ({\n          id: reaction.id,\n          type: reaction.type,\n          postId: post.id,\n          reactorId: reaction.userId,\n          createdAt: reaction.createdAt,\n        })),\n      });\n    }\n\n    // Handle comments - sync comments\n    const existingComments = await this.prisma.comment.findMany({\n      where: { postId: post.id },\n    });\n\n    const currentCommentIds = post.comments.map((c) => c.id);\n    const existingCommentIds = existingComments.map((c) => c.id);\n\n    // Delete removed comments\n    const commentsToDelete = existingCommentIds.filter(\n      (id) => !currentCommentIds.includes(id),\n    );\n    if (commentsToDelete.length > 0) {\n      await this.prisma.comment.deleteMany({\n        where: { id: { in: commentsToDelete } },\n      });\n    }\n\n    // Upsert comments\n    for (const comment of post.comments) {\n      await this.prisma.comment.upsert({\n        where: { id: comment.id },\n        create: {\n          id: comment.id,\n          content: comment.content,\n          postId: post.id,\n          authorId: comment.authorId,\n          parentId: comment.parentId,\n          createdAt: comment.createdAt,\n          updatedAt: comment.updatedAt,\n        },\n        update: {\n          content: comment.content,\n          updatedAt: comment.updatedAt,\n        },\n      });\n    }\n\n    // Return reconstructed entity\n    const savedEntity = await this.findById(post.id);\n    if (!savedEntity) {\n      throw new Error('Failed to retrieve saved post');\n    }\n    return savedEntity;\n  }\n\n  async findById(id: string): Promise<PostEntity | null> {\n    const post = await this.prisma.post.findUnique({\n      where: { id },\n      include: {\n        author: true,\n        reactions: {\n          include: {\n            reactor: true,\n          },\n        },\n        comments: {\n          include: {\n            author: true,\n          },\n          orderBy: {\n            createdAt: 'asc',\n          },\n        },\n        postMedia: {\n          orderBy: {\n            order: 'asc',\n          },\n        },\n        hashtags: {\n          include: {\n            hashtag: true,\n          },\n        },\n      },\n    });\n\n    if (!post) {\n      return null;\n    }\n\n    return this.mapToEntity(post);\n  }\n\n  async findAll(filters: {\n    authorId?: string;\n    privacy?: string;\n    hashtag?: string;\n    search?: string;\n    page: number;\n    limit: number;\n    sortBy?: 'newest' | 'oldest' | 'most_liked' | 'most_commented';\n  }): Promise<{ posts: PostEntity[]; total: number }> {\n    const where: any = {};\n\n    if (filters.authorId) {\n      where.authorId = filters.authorId;\n    }\n\n    if (filters.privacy) {\n      where.privacy = filters.privacy;\n    }\n\n    if (filters.hashtag) {\n      where.hashtags = {\n        some: {\n          hashtag: {\n            name: filters.hashtag,\n          },\n        },\n      };\n    }\n\n    if (filters.search) {\n      where.content = {\n        contains: filters.search,\n        mode: 'insensitive',\n      };\n    }\n\n    // Calculate sorting\n    let orderBy: any = { createdAt: 'desc' };\n    switch (filters.sortBy) {\n      case 'oldest':\n        orderBy = { createdAt: 'asc' };\n        break;\n      case 'most_liked':\n        orderBy = { reactions: { _count: 'desc' } };\n        break;\n      case 'most_commented':\n        orderBy = { comments: { _count: 'desc' } };\n        break;\n    }\n\n    const [posts, total] = await Promise.all([\n      this.prisma.post.findMany({\n        where,\n        include: {\n          author: true,\n          reactions: {\n            include: {\n              reactor: true,\n            },\n          },\n          comments: {\n            include: {\n              author: true,\n            },\n          },\n          postMedia: {\n            orderBy: {\n              order: 'asc',\n            },\n          },\n          hashtags: {\n            include: {\n              hashtag: true,\n            },\n          },\n        },\n        orderBy,\n        skip: (filters.page - 1) * filters.limit,\n        take: filters.limit,\n      }),\n      this.prisma.post.count({ where }),\n    ]);\n\n    return {\n      posts: posts.map((post) => this.mapToEntity(post)),\n      total,\n    };\n  }\n\n  async findByAuthorId(\n    authorId: string,\n    page: number,\n    limit: number,\n  ): Promise<{ posts: PostEntity[]; total: number }> {\n    return this.findAll({\n      authorId,\n      page,\n      limit,\n    });\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.prisma.post.delete({\n      where: { id },\n    });\n  }\n\n  async exists(id: string): Promise<boolean> {\n    const post = await this.prisma.post.findUnique({\n      where: { id },\n      select: { id: true },\n    });\n    return !!post;\n  }\n\n  async findByIds(ids: string[]): Promise<PostEntity[]> {\n    const posts = await this.prisma.post.findMany({\n      where: {\n        id: { in: ids },\n      },\n      include: {\n        author: true,\n        reactions: {\n          include: {\n            reactor: true,\n          },\n        },\n        comments: {\n          include: {\n            author: true,\n          },\n        },\n        postMedia: {\n          orderBy: {\n            order: 'asc',\n          },\n        },\n        hashtags: {\n          include: {\n            hashtag: true,\n          },\n        },\n      },\n    });\n\n    return posts.map((post) => this.mapToEntity(post));\n  }\n\n  async getUserFeed(\n    userId: string,\n    page: number,\n    limit: number,\n  ): Promise<{ posts: PostEntity[]; total: number }> {\n    // Get posts from followed users + user's own posts\n    const [posts, total] = await Promise.all([\n      this.prisma.post.findMany({\n        where: {\n          OR: [\n            { authorId: userId },\n            {\n              author: {\n                followers: {\n                  some: {\n                    followerId: userId,\n                  },\n                },\n              },\n            },\n          ],\n          privacy: {\n            in: ['public', 'followers'],\n          },\n        },\n        include: {\n          author: true,\n          reactions: {\n            include: {\n              reactor: true,\n            },\n          },\n          comments: {\n            include: {\n              author: true,\n            },\n          },\n          postMedia: {\n            orderBy: {\n              order: 'asc',\n            },\n          },\n          hashtags: {\n            include: {\n              hashtag: true,\n            },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.prisma.post.count({\n        where: {\n          OR: [\n            { authorId: userId },\n            {\n              author: {\n                followers: {\n                  some: {\n                    followerId: userId,\n                  },\n                },\n              },\n            },\n          ],\n          privacy: {\n            in: ['public', 'followers'],\n          },\n        },\n      }),\n    ]);\n\n    return {\n      posts: posts.map((post) => this.mapToEntity(post)),\n      total,\n    };\n  }\n\n  async getTrendingPosts(\n    page: number,\n    limit: number,\n  ): Promise<{ posts: PostEntity[]; total: number }> {\n    // Get posts with high engagement in the last 24 hours\n    const oneDayAgo = new Date();\n    oneDayAgo.setDate(oneDayAgo.getDate() - 1);\n\n    const [posts, total] = await Promise.all([\n      this.prisma.post.findMany({\n        where: {\n          privacy: 'public',\n          createdAt: {\n            gte: oneDayAgo,\n          },\n        },\n        include: {\n          author: true,\n          reactions: {\n            include: {\n              reactor: true,\n            },\n          },\n          comments: {\n            include: {\n              author: true,\n            },\n          },\n          postMedia: {\n            orderBy: {\n              order: 'asc',\n            },\n          },\n          hashtags: {\n            include: {\n              hashtag: true,\n            },\n          },\n          _count: {\n            select: {\n              reactions: true,\n              comments: true,\n            },\n          },\n        },\n        orderBy: [\n          { reactions: { _count: 'desc' } },\n          { comments: { _count: 'desc' } },\n          { createdAt: 'desc' },\n        ],\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.prisma.post.count({\n        where: {\n          privacy: 'public',\n          createdAt: {\n            gte: oneDayAgo,\n          },\n        },\n      }),\n    ]);\n\n    return {\n      posts: posts.map((post) => this.mapToEntity(post)),\n      total,\n    };\n  }\n\n  async getPostStats(postId: string): Promise<{\n    likesCount: number;\n    commentsCount: number;\n  }> {\n    const stats = await this.prisma.post.findUnique({\n      where: { id: postId },\n      select: {\n        _count: {\n          select: {\n            reactions: true,\n            comments: true,\n          },\n        },\n      },\n    });\n\n    return {\n      likesCount: stats?._count.reactions || 0,\n      commentsCount: stats?._count.comments || 0,\n    };\n  }\n\n  private mapToEntity(data: any): PostEntity {\n    return this.postFactory.reconstitute({\n      id: data.id,\n      content: data.content,\n      authorId: data.authorId,\n      privacy: data.privacy as PostPrivacy,\n      hashtags: data.hashtags.map((h: any) => h.hashtag.name),\n      media: data.postMedia.map((m: any) => ({\n        id: m.id,\n        url: m.url,\n        type: m.type as 'image' | 'video',\n        order: m.order,\n      })),\n      reactions: data.reactions.map((r: any) => ({\n        id: r.id,\n        userId: r.reactorId,\n        type: r.type as ReactionType,\n        createdAt: r.createdAt,\n      })),\n      comments: data.comments.map((c: any) => ({\n        id: c.id,\n        content: c.content,\n        authorId: c.authorId,\n        parentId: c.parentId,\n        createdAt: c.createdAt,\n        updatedAt: c.updatedAt,\n      })),\n      createdAt: data.createdAt,\n      updatedAt: data.updatedAt,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\posts.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\posts\\presentation\\posts.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UseGuards' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":66,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":66,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":66,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":66,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":67,"column":51,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":67,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":85,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":85,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":85,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":86,"column":55,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":86,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":100,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":100,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":100,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":101,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":101,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":101,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":102,"column":55,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":102,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":102,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":102,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":120,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":120,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":120,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":122,"column":56,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":122,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":167,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":167,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":167,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":167,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":168,"column":56,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":168,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":184,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":184,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":184,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":184,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":185,"column":52,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":185,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":202,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":202,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":202,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":202,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":205,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":205,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":221,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":221,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":221,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":221,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":222,"column":59,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":222,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":249,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":249,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":249,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":249,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":252,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":252,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":274,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":274,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":274,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":274,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":277,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":277,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":299,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":299,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":299,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":299,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":303,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":303,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":321,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":321,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":321,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":322,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":322,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":322,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":322,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":326,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":326,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":327,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":327,"endColumn":15}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Request,\n  HttpCode,\n  HttpStatus,\n  ParseUUIDPipe,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiParam,\n  ApiQuery,\n} from '@nestjs/swagger';\nimport { PostApplicationService } from '../application/post-application.service';\nimport {\n  CreatePostDto,\n  UpdatePostDto,\n  GetPostsQueryDto,\n  CreateReactionDto,\n  CreateCommentDto,\n  UpdateCommentDto,\n  GetFeedDto,\n  PostResponseDto,\n  PostDetailResponseDto,\n  PostListResponseDto,\n  PostCommentResponseDto,\n} from '../application/dto/post.dto';\n\n// These would be imported from auth module\n// import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';\n// import { CurrentUser } from '../../auth/decorators/current-user.decorator';\n\n@ApiTags('Posts')\n@Controller('posts')\n// @UseGuards(JwtAuthGuard) // Uncomment when auth is ready\nexport class PostsController {\n  constructor(\n    private readonly postApplicationService: PostApplicationService,\n  ) {}\n\n  // ===== POST MANAGEMENT =====\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new post' })\n  @ApiResponse({\n    status: 201,\n    description: 'Post created successfully',\n    type: PostResponseDto,\n  })\n  @ApiBearerAuth()\n  async createPost(\n    @Body() createPostDto: CreatePostDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostResponseDto> {\n    // TODO: Get actual user ID from authentication\n    const authorId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.createPost(authorId, createPostDto);\n  }\n\n  @Put(':id')\n  @ApiOperation({ summary: 'Update a post' })\n  @ApiResponse({\n    status: 200,\n    description: 'Post updated successfully',\n    type: PostResponseDto,\n  })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async updatePost(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() updatePostDto: UpdatePostDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostResponseDto> {\n    // TODO: Get actual user ID and role from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.updatePost(id, userId, updatePostDto);\n  }\n\n  @Delete(':id')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete a post' })\n  @ApiResponse({ status: 204, description: 'Post deleted successfully' })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async deletePost(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<void> {\n    // TODO: Get actual user ID and role from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    const userRole = req.user?.role || 'USER';\n    return this.postApplicationService.deletePost(id, userId, userRole);\n  }\n\n  // ===== POST RETRIEVAL =====\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a post by ID' })\n  @ApiResponse({\n    status: 200,\n    description: 'Post retrieved successfully',\n    type: PostDetailResponseDto,\n  })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  async getPost(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostDetailResponseDto> {\n    // TODO: Get actual user ID and following status from authentication\n    const viewerId = req.user?.userId;\n    const isFollowing = false; // TODO: Implement following check\n    return this.postApplicationService.getPostById(id, viewerId, isFollowing);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get posts with filters' })\n  @ApiResponse({\n    status: 200,\n    description: 'Posts retrieved successfully',\n    type: PostListResponseDto,\n  })\n  @ApiQuery({\n    name: 'page',\n    required: false,\n    type: Number,\n    description: 'Page number',\n  })\n  @ApiQuery({\n    name: 'limit',\n    required: false,\n    type: Number,\n    description: 'Items per page',\n  })\n  @ApiQuery({\n    name: 'authorId',\n    required: false,\n    type: String,\n    description: 'Filter by author ID',\n  })\n  @ApiQuery({\n    name: 'hashtag',\n    required: false,\n    type: String,\n    description: 'Filter by hashtag',\n  })\n  @ApiQuery({\n    name: 'search',\n    required: false,\n    type: String,\n    description: 'Search in content',\n  })\n  async getPosts(\n    @Query() query: GetPostsQueryDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostListResponseDto> {\n    // TODO: Get actual user ID from authentication\n    const viewerId = req.user?.userId;\n    return this.postApplicationService.getPosts(query, viewerId);\n  }\n\n  @Get('feed/timeline')\n  @ApiOperation({ summary: 'Get user timeline/feed' })\n  @ApiResponse({\n    status: 200,\n    description: 'Feed retrieved successfully',\n    type: PostListResponseDto,\n  })\n  @ApiBearerAuth()\n  async getFeed(\n    @Query() query: GetFeedDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostListResponseDto> {\n    // TODO: Get actual user ID from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.getUserFeed(userId, query);\n  }\n\n  // ===== REACTIONS =====\n\n  @Post(':id/reactions')\n  @HttpCode(HttpStatus.CREATED)\n  @ApiOperation({ summary: 'Add reaction to a post' })\n  @ApiResponse({ status: 201, description: 'Reaction added successfully' })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async addReaction(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() createReactionDto: CreateReactionDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<void> {\n    // TODO: Get actual user ID from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.addReaction(\n      id,\n      userId,\n      createReactionDto,\n    );\n  }\n\n  @Delete(':id/reactions')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Remove reaction from a post' })\n  @ApiResponse({ status: 204, description: 'Reaction removed successfully' })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async removeReaction(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<void> {\n    // TODO: Get actual user ID from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.removeReaction(id, userId);\n  }\n\n  @Put(':id/reactions/toggle')\n  @ApiOperation({ summary: 'Toggle reaction on a post' })\n  @ApiResponse({\n    status: 200,\n    description: 'Reaction toggled successfully',\n    schema: {\n      type: 'object',\n      properties: {\n        action: { type: 'string', enum: ['added', 'removed', 'changed'] },\n        reactionType: { type: 'string', nullable: true },\n      },\n    },\n  })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async toggleReaction(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() createReactionDto: CreateReactionDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<{\n    action: 'added' | 'removed' | 'changed';\n    reactionType?: string;\n  }> {\n    // TODO: Get actual user ID from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.toggleReaction(\n      id,\n      userId,\n      createReactionDto,\n    );\n  }\n\n  // ===== COMMENTS =====\n\n  @Post(':id/comments')\n  @ApiOperation({ summary: 'Add comment to a post' })\n  @ApiResponse({\n    status: 201,\n    description: 'Comment added successfully',\n    type: PostCommentResponseDto,\n  })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiBearerAuth()\n  async addComment(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() createCommentDto: CreateCommentDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostCommentResponseDto> {\n    // TODO: Get actual user ID from authentication\n    const authorId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.addComment(\n      id,\n      authorId,\n      createCommentDto,\n    );\n  }\n\n  @Put(':id/comments/:commentId')\n  @ApiOperation({ summary: 'Update a comment' })\n  @ApiResponse({\n    status: 200,\n    description: 'Comment updated successfully',\n    type: PostCommentResponseDto,\n  })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiParam({ name: 'commentId', description: 'Comment ID', type: 'string' })\n  @ApiBearerAuth()\n  async updateComment(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Param('commentId', ParseUUIDPipe) commentId: string,\n    @Body() updateCommentDto: UpdateCommentDto,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<PostCommentResponseDto> {\n    // TODO: Get actual user ID from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    return this.postApplicationService.updateComment(\n      id,\n      commentId,\n      userId,\n      updateCommentDto,\n    );\n  }\n\n  @Delete(':id/comments/:commentId')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete a comment' })\n  @ApiResponse({ status: 204, description: 'Comment deleted successfully' })\n  @ApiParam({ name: 'id', description: 'Post ID', type: 'string' })\n  @ApiParam({ name: 'commentId', description: 'Comment ID', type: 'string' })\n  @ApiBearerAuth()\n  async deleteComment(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Param('commentId', ParseUUIDPipe) commentId: string,\n    @Request() req: any, // Replace with @CurrentUser() when auth is ready\n  ): Promise<void> {\n    // TODO: Get actual user ID and role from authentication\n    const userId = req.user?.userId || 'temp-user-id';\n    const userRole = req.user?.role || 'USER';\n    return this.postApplicationService.deleteComment(\n      id,\n      commentId,\n      userId,\n      userRole,\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\processors\\processors.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\dto\\reaction-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\dto\\reaction.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\interfaces\\external-services.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\interfaces\\tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\mappers\\reaction.mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\reaction-application.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\create-reaction.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ReactionType`.","line":77,"column":9,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":77,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { ReactionRepository } from '../../domain/repositories/reaction.repository';\nimport { ReactionFactory } from '../../domain/factories/reaction.factory';\nimport { ReactionDomainService } from '../../domain/services/reaction-domain.service';\nimport { CreateReactionDto } from '../dto/reaction.dto';\nimport { CreateReactionResponseDto } from '../dto/reaction-response.dto';\nimport { ReactionMapper } from '../mappers/reaction.mapper';\nimport {\n  ExternalPostService,\n  ExternalCommentService,\n  NotificationService,\n} from '../interfaces/external-services.interface';\nimport {\n  EXTERNAL_POST_SERVICE,\n  EXTERNAL_COMMENT_SERVICE,\n  NOTIFICATION_SERVICE,\n} from '../interfaces/tokens';\nimport {\n  InvalidReactionTargetException,\n  PostNotFoundException,\n  CommentNotFoundException,\n} from '../../domain/reaction.exceptions';\n\n@Injectable()\nexport class CreateReactionUseCase {\n  constructor(\n    private readonly reactionRepository: ReactionRepository,\n    private readonly reactionFactory: ReactionFactory,\n    private readonly reactionDomainService: ReactionDomainService,\n    @Inject(EXTERNAL_POST_SERVICE)\n    private readonly postService: ExternalPostService,\n    @Inject(EXTERNAL_COMMENT_SERVICE)\n    private readonly commentService: ExternalCommentService,\n    @Inject(NOTIFICATION_SERVICE)\n    private readonly notificationService: NotificationService,\n  ) {}\n\n  async execute(\n    dto: CreateReactionDto,\n    userId: string,\n  ): Promise<CreateReactionResponseDto> {\n    const { postId, commentId, type } = dto;\n\n    // Validate target\n    if (!postId && !commentId) {\n      throw new InvalidReactionTargetException();\n    }\n\n    let targetId: string;\n    let targetType: 'post' | 'comment';\n    let targetAuthorId: string;\n    let targetContent: string;\n\n    if (postId) {\n      const post = await this.postService.findById(postId);\n      if (!post) {\n        throw new PostNotFoundException(postId);\n      }\n      targetId = postId;\n      targetType = 'post';\n      targetAuthorId = post.authorId;\n      targetContent = post.content;\n    } else {\n      const comment = await this.commentService.findById(commentId!);\n      if (!comment) {\n        throw new CommentNotFoundException(commentId!);\n      }\n      targetId = commentId!;\n      targetType = 'comment';\n      targetAuthorId = comment.authorId;\n      targetContent = comment.content;\n    }\n\n    // Create or update reaction\n    const { reaction, isNew } =\n      await this.reactionDomainService.createOrUpdateReaction(\n        type.toUpperCase() as any,\n        userId,\n        targetId,\n        targetType,\n      );\n\n    // Send notification if it's a new reaction and not self-reaction\n    if (isNew && targetAuthorId !== userId) {\n      try {\n        await this.notificationService.createReactionNotification({\n          reactorId: userId,\n          targetUserId: targetAuthorId,\n          entityId: targetId,\n          entityType: targetType,\n          content: targetContent,\n        });\n      } catch (error) {\n        // Log error but don't fail the reaction creation\n        console.error('Failed to create reaction notification:', error);\n      }\n    }\n\n    return {\n      message: isNew\n        ? 'Reaction created successfully'\n        : 'Reaction updated successfully',\n      reacted: true,\n      reaction: ReactionMapper.toResponseDto(reaction),\n      isNew,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\delete-reaction.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\get-post-reactions.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\get-reaction-status.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\get-reaction.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\application\\use-cases\\get-reactions.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\factories\\reaction.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\reaction.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\reaction.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\reaction.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\repositories\\reaction.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\domain\\services\\reaction-domain.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'InvalidReactionTargetException' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PostNotFoundException' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CommentNotFoundException' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'targetId' is defined but never used.","line":97,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'targetType' is defined but never used.","line":98,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":15}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ReactionEntity, ReactionType } from '../reaction.entity';\nimport { ReactionRepository } from '../repositories/reaction.repository';\nimport {\n  InvalidReactionTargetException,\n  PostNotFoundException,\n  CommentNotFoundException,\n  ReactionNotFoundException,\n  UnauthorizedReactionException,\n} from '../reaction.exceptions';\n\n@Injectable()\nexport class ReactionDomainService {\n  constructor(private readonly reactionRepository: ReactionRepository) {}\n\n  async createOrUpdateReaction(\n    type: ReactionType,\n    reactorId: string,\n    targetId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<{ reaction: ReactionEntity; isNew: boolean }> {\n    // Check if user already has a reaction to this target\n    const existingReaction = await this.reactionRepository.findByUserAndTarget(\n      reactorId,\n      targetId,\n      targetType,\n    );\n\n    if (existingReaction) {\n      // Update existing reaction\n      existingReaction.updateType(type);\n      const updatedReaction =\n        await this.reactionRepository.save(existingReaction);\n      return { reaction: updatedReaction, isNew: false };\n    }\n\n    // Create new reaction\n    const newReaction = ReactionEntity.createNew(\n      type,\n      reactorId,\n      targetId,\n      targetType,\n    );\n    const savedReaction = await this.reactionRepository.save(newReaction);\n    return { reaction: savedReaction, isNew: true };\n  }\n\n  async validateReactionOwnership(\n    reactionId: string,\n    userId: string,\n  ): Promise<ReactionEntity> {\n    const reaction = await this.reactionRepository.findById(reactionId);\n\n    if (!reaction) {\n      throw new ReactionNotFoundException(reactionId);\n    }\n\n    if (!reaction.isOwnedBy(userId)) {\n      throw new UnauthorizedReactionException();\n    }\n\n    return reaction;\n  }\n\n  async deleteReaction(reactionId: string, userId: string): Promise<void> {\n    await this.validateReactionOwnership(reactionId, userId);\n    await this.reactionRepository.delete(reactionId);\n  }\n\n  async getUserReactionStatus(\n    targetId: string,\n    userId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<{\n    reacted: boolean;\n    reactionType?: ReactionType;\n    reactionId?: string;\n  }> {\n    const reaction = await this.reactionRepository.findByUserAndTarget(\n      userId,\n      targetId,\n      targetType,\n    );\n\n    if (!reaction) {\n      return { reacted: false };\n    }\n\n    return {\n      reacted: true,\n      reactionType: reaction.type,\n      reactionId: reaction.id,\n    };\n  }\n\n  async validateTargetExists(\n    targetId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<void> {\n    // This method should be implemented with proper validation\n    // For now, we'll assume the validation happens at the application layer\n    // through the use of external services\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\infrastructure\\external-services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\infrastructure\\prisma-reaction.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postId on an `any` value.","line":94,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":94,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .commentId on an `any` value.","line":95,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .reactorId on an `any` value.","line":96,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postId on an `any` value.","line":99,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .commentId on an `any` value.","line":101,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":105,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":105,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postId on an `any` value.","line":124,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":124,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .commentId on an `any` value.","line":125,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":125,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .reactorId on an `any` value.","line":126,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":126,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .postId on an `any` value.","line":129,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":129,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .commentId on an `any` value.","line":131,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":131,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":135,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":135,"endColumn":12}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport {\n  ReactionRepository,\n  FindReactionsOptions,\n  ReactionWithReactor,\n  PostReactionsResult,\n  ReactionStatusResult,\n} from '../domain/repositories/reaction.repository';\nimport { ReactionEntity } from '../domain/reaction.entity';\nimport { ReactionFactory } from '../domain/factories/reaction.factory';\n\n@Injectable()\nexport class PrismaReactionRepository implements ReactionRepository {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly reactionFactory: ReactionFactory,\n  ) {}\n\n  async save(reaction: ReactionEntity): Promise<ReactionEntity> {\n    const data = {\n      type: reaction.type,\n      reactorId: reaction.reactorId,\n      postId: reaction.postId,\n      commentId: reaction.commentId,\n    };\n\n    if (reaction.id) {\n      // Update existing\n      const updated = await this.prisma.reaction.update({\n        where: { id: reaction.id },\n        data,\n      });\n\n      return this.reactionFactory.createFromPrimitive({\n        ...updated,\n        updatedAt: updated.createdAt, // Fallback since Prisma model might not have updatedAt\n      });\n    } else {\n      // Create new\n      const created = await this.prisma.reaction.create({\n        data,\n      });\n\n      return this.reactionFactory.createFromPrimitive({\n        ...created,\n        updatedAt: created.createdAt,\n      });\n    }\n  }\n\n  async findById(id: string): Promise<ReactionEntity | null> {\n    const reaction = await this.prisma.reaction.findUnique({\n      where: { id },\n    });\n\n    if (!reaction) {\n      return null;\n    }\n\n    return this.reactionFactory.createFromPrimitive({\n      ...reaction,\n      updatedAt: reaction.createdAt,\n    });\n  }\n\n  async findByUserAndTarget(\n    userId: string,\n    targetId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<ReactionEntity | null> {\n    const where =\n      targetType === 'post'\n        ? { reactorId: userId, postId: targetId }\n        : { reactorId: userId, commentId: targetId };\n\n    const reaction = await this.prisma.reaction.findFirst({\n      where,\n    });\n\n    if (!reaction) {\n      return null;\n    }\n\n    return this.reactionFactory.createFromPrimitive({\n      ...reaction,\n      updatedAt: reaction.createdAt,\n    });\n  }\n\n  async findAll(options?: FindReactionsOptions): Promise<ReactionEntity[]> {\n    const where: any = {};\n\n    if (options?.postId) where.postId = options.postId;\n    if (options?.commentId) where.commentId = options.commentId;\n    if (options?.reactorId) where.reactorId = options.reactorId;\n\n    if (options?.targetType === 'post') {\n      where.postId = { not: null };\n    } else if (options?.targetType === 'comment') {\n      where.commentId = { not: null };\n    }\n\n    const reactions = await this.prisma.reaction.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: options?.limit,\n      skip: options?.offset,\n    });\n\n    return reactions.map((reaction) =>\n      this.reactionFactory.createFromPrimitive({\n        ...reaction,\n        updatedAt: reaction.createdAt,\n      }),\n    );\n  }\n\n  async findAllWithReactor(\n    options?: FindReactionsOptions,\n  ): Promise<ReactionWithReactor[]> {\n    const where: any = {};\n\n    if (options?.postId) where.postId = options.postId;\n    if (options?.commentId) where.commentId = options.commentId;\n    if (options?.reactorId) where.reactorId = options.reactorId;\n\n    if (options?.targetType === 'post') {\n      where.postId = { not: null };\n    } else if (options?.targetType === 'comment') {\n      where.commentId = { not: null };\n    }\n\n    const reactions = await this.prisma.reaction.findMany({\n      where,\n      include: {\n        reactor: {\n          select: {\n            id: true,\n            fullName: true,\n            avatar: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: options?.limit,\n      skip: options?.offset,\n    });\n\n    return reactions.map((reaction) => ({\n      reaction: this.reactionFactory.createFromPrimitive({\n        id: reaction.id,\n        type: reaction.type,\n        reactorId: reaction.reactorId,\n        postId: reaction.postId,\n        commentId: reaction.commentId,\n        createdAt: reaction.createdAt,\n        updatedAt: reaction.createdAt,\n      }),\n      reactor: reaction.reactor,\n    }));\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.prisma.reaction.delete({\n      where: { id },\n    });\n  }\n\n  async getPostReactions(postId: string): Promise<PostReactionsResult> {\n    const reactions = await this.prisma.reaction.findMany({\n      where: { postId },\n      include: {\n        reactor: {\n          select: {\n            id: true,\n            fullName: true,\n            avatar: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return {\n      postId,\n      totalReactions: reactions.length,\n      reactions: reactions.map((reaction) => ({\n        reaction: this.reactionFactory.createFromPrimitive({\n          id: reaction.id,\n          type: reaction.type,\n          reactorId: reaction.reactorId,\n          postId: reaction.postId,\n          commentId: reaction.commentId,\n          createdAt: reaction.createdAt,\n          updatedAt: reaction.createdAt,\n        }),\n        reactor: reaction.reactor,\n      })),\n    };\n  }\n\n  async getReactionStatus(\n    targetId: string,\n    userId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<ReactionStatusResult> {\n    const where =\n      targetType === 'post'\n        ? { reactorId: userId, postId: targetId }\n        : { reactorId: userId, commentId: targetId };\n\n    const reaction = await this.prisma.reaction.findFirst({\n      where,\n    });\n\n    return {\n      targetId,\n      userId,\n      reacted: !!reaction,\n      reactionId: reaction?.id || null,\n      reactionType: reaction?.type || null,\n    };\n  }\n\n  async countByTarget(\n    targetId: string,\n    targetType: 'post' | 'comment',\n  ): Promise<number> {\n    const where =\n      targetType === 'post' ? { postId: targetId } : { commentId: targetId };\n\n    return this.prisma.reaction.count({\n      where,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\infrastructure\\queue-notification.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\presentation\\reactions.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\reactions\\reactions.module.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ExternalPostService' is defined but never used.","line":29,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ExternalCommentService' is defined but never used.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotificationService' is defined but never used.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":22}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Module } from '@nestjs/common';\nimport { PrismaModule } from '../../database/prisma.module';\n\n// Presentation Layer\nimport { ReactionsController } from './presentation/reactions.controller';\n\n// Application Layer\nimport { ReactionApplicationService } from './application/reaction-application.service';\nimport { CreateReactionUseCase } from './application/use-cases/create-reaction.use-case';\nimport { DeleteReactionUseCase } from './application/use-cases/delete-reaction.use-case';\nimport { GetReactionUseCase } from './application/use-cases/get-reaction.use-case';\nimport { GetReactionsUseCase } from './application/use-cases/get-reactions.use-case';\nimport { GetPostReactionsUseCase } from './application/use-cases/get-post-reactions.use-case';\nimport { GetReactionStatusUseCase } from './application/use-cases/get-reaction-status.use-case';\n\n// Domain Layer\nimport { ReactionRepository } from './domain/repositories/reaction.repository';\nimport { ReactionFactory } from './domain/factories/reaction.factory';\nimport { ReactionDomainService } from './domain/services/reaction-domain.service';\n\n// Infrastructure Layer\nimport { PrismaReactionRepository } from './infrastructure/prisma-reaction.repository';\nimport { PrismaPostService } from './infrastructure/external-services';\nimport { PrismaCommentService } from './infrastructure/external-services';\nimport { QueueNotificationService } from './infrastructure/queue-notification.service';\n\n// Application Interfaces\nimport {\n  ExternalPostService,\n  ExternalCommentService,\n  NotificationService,\n} from './application/interfaces/external-services.interface';\nimport {\n  EXTERNAL_POST_SERVICE,\n  EXTERNAL_COMMENT_SERVICE,\n  NOTIFICATION_SERVICE,\n} from './application/interfaces/tokens';\n\n@Module({\n  imports: [PrismaModule],\n  controllers: [ReactionsController],\n  providers: [\n    // Application Layer\n    ReactionApplicationService,\n    CreateReactionUseCase,\n    DeleteReactionUseCase,\n    GetReactionUseCase,\n    GetReactionsUseCase,\n    GetPostReactionsUseCase,\n    GetReactionStatusUseCase,\n\n    // Domain Layer\n    ReactionFactory,\n    ReactionDomainService,\n\n    // Infrastructure Layer - Repository\n    {\n      provide: ReactionRepository,\n      useClass: PrismaReactionRepository,\n    },\n\n    // Infrastructure Layer - External Services\n    {\n      provide: EXTERNAL_POST_SERVICE,\n      useClass: PrismaPostService,\n    },\n    {\n      provide: EXTERNAL_COMMENT_SERVICE,\n      useClass: PrismaCommentService,\n    },\n    {\n      provide: NOTIFICATION_SERVICE,\n      useClass: QueueNotificationService,\n    },\n  ],\n  exports: [ReactionApplicationService, ReactionRepository],\n})\nexport class ReactionsModule {}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\dto\\search-history.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsOptional' is defined but never used.","line":1,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUrl' is defined but never used.","line":1,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiPropertyOptional' is defined but never used.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":42}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IsNotEmpty, IsString, IsOptional, IsUrl } from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class AddSearchEntryDto {\n  @ApiProperty({\n    description: 'ID of the user being searched',\n    example: 'user-uuid-123',\n  })\n  @IsNotEmpty()\n  @IsString()\n  searchedUserId: string;\n}\n\nexport class SearchHistoryEntryDto {\n  @ApiProperty({\n    description: 'Entry ID',\n    example: 'entry-uuid-123',\n  })\n  id: string;\n\n  @ApiProperty({\n    description: 'ID of the searched user',\n    example: 'user-uuid-123',\n  })\n  searchedUserId: string;\n\n  @ApiProperty({\n    description: 'When the search was performed',\n    example: '2023-10-01T10:00:00Z',\n  })\n  searchedAt: string;\n\n  @ApiProperty({\n    description: 'Profile information of the searched user',\n  })\n  user: {\n    id: string;\n    userName: string;\n    fullName: string;\n    avatar: string | null;\n  };\n}\n\nexport class SearchHistoryResponseDto {\n  @ApiProperty({\n    description: 'List of search history entries',\n    type: [SearchHistoryEntryDto],\n  })\n  history: SearchHistoryEntryDto[];\n\n  @ApiProperty({\n    description: 'Total number of search history entries',\n    example: 5,\n  })\n  total: number;\n}\n\nexport class SearchHistoryItemDto {\n  @ApiProperty({\n    description: 'ID of the searched user',\n    example: 'user-uuid-123',\n  })\n  userId: string;\n\n  @ApiProperty({\n    description: 'When the user was searched',\n    example: '2023-10-01T10:00:00Z',\n  })\n  searchedAt: string;\n\n  @ApiProperty({\n    description: 'Profile information of the searched user',\n  })\n  user: {\n    id: string;\n    userName: string;\n    fullName: string;\n    avatar: string | null;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\events\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\interfaces\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\search-history-application.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":123,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":154,"column":61,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":154,"endColumn":68}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { ApiResponse } from '../../../shared/common/interfaces/api-response.interface';\nimport {\n  GetSearchHistoryUseCase,\n  AddSearchEntryUseCase,\n  RemoveSearchEntryUseCase,\n  ClearSearchHistoryUseCase,\n} from './use-cases';\nimport {\n  SearchHistoryResponseDto,\n  SearchHistoryEntryDto,\n  AddSearchEntryDto,\n} from './dto/search-history.dto';\n\n@Injectable()\nexport class SearchHistoryApplicationService {\n  private readonly logger = new Logger(SearchHistoryApplicationService.name);\n\n  constructor(\n    private readonly getSearchHistoryUseCase: GetSearchHistoryUseCase,\n    private readonly addSearchEntryUseCase: AddSearchEntryUseCase,\n    private readonly removeSearchEntryUseCase: RemoveSearchEntryUseCase,\n    private readonly clearSearchHistoryUseCase: ClearSearchHistoryUseCase,\n  ) {}\n\n  /**\n   * Get search history for a user with populated user data\n   */\n  async getSearchHistory(\n    currentUserId: string,\n  ): Promise<ApiResponse<SearchHistoryResponseDto>> {\n    try {\n      const { searchHistory } = await this.getSearchHistoryUseCase.execute({\n        userId: currentUserId,\n      });\n\n      if (!searchHistory || searchHistory.isEmpty) {\n        return {\n          success: true,\n          message: 'Search history retrieved successfully',\n          data: {\n            history: [],\n            total: 0,\n          },\n        };\n      }\n\n      // Convert domain entities to DTOs\n      const historyItems: SearchHistoryEntryDto[] = searchHistory.entries.map(\n        (entry) => ({\n          id: entry.id,\n          searchedUserId: entry.searchedUserId,\n          searchedAt: entry.searchedAt.toISOString(),\n          user: {\n            id: entry.searchedUserProfile?.id || entry.searchedUserId,\n            userName: entry.searchedUserProfile?.userName || '',\n            fullName: entry.searchedUserProfile?.fullName || '',\n            avatar: entry.searchedUserProfile?.avatar || null,\n          },\n        }),\n      );\n\n      return {\n        success: true,\n        message: 'Search history retrieved successfully',\n        data: {\n          history: historyItems,\n          total: historyItems.length,\n        },\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to get search history for user ${currentUserId}:`,\n        error,\n      );\n      return {\n        success: false,\n        message: 'Failed to retrieve search history',\n        data: {\n          history: [],\n          total: 0,\n        },\n      };\n    }\n  }\n\n  /**\n   * Add a searched user to current user's search history\n   */\n  async addToSearchHistory(\n    currentUserId: string,\n    dto: AddSearchEntryDto,\n    searchedUserProfile?: {\n      id: string;\n      userName: string;\n      fullName: string;\n      avatar: string | null;\n    },\n  ): Promise<ApiResponse<null>> {\n    try {\n      // Don't add self to search history\n      if (currentUserId === dto.searchedUserId) {\n        return {\n          success: true,\n          message: 'Cannot add yourself to search history',\n          data: null,\n        };\n      }\n\n      await this.addSearchEntryUseCase.execute({\n        userId: currentUserId,\n        searchedUserId: dto.searchedUserId,\n        searchedUserProfile,\n      });\n\n      return {\n        success: true,\n        message: 'User added to search history successfully',\n        data: null,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to add user to search history: ${error.message}`,\n        error,\n      );\n      return {\n        success: false,\n        message: 'Failed to add user to search history',\n        data: null,\n      };\n    }\n  }\n\n  /**\n   * Remove a user from search history\n   */\n  async removeFromSearchHistory(\n    currentUserId: string,\n    searchedUserId: string,\n  ): Promise<ApiResponse<null>> {\n    try {\n      await this.removeSearchEntryUseCase.execute({\n        userId: currentUserId,\n        searchedUserId,\n      });\n\n      return {\n        success: true,\n        message: 'User removed from search history successfully',\n        data: null,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to remove user from search history: ${error.message}`,\n        error,\n      );\n      return {\n        success: false,\n        message: 'Failed to remove user from search history',\n        data: null,\n      };\n    }\n  }\n\n  /**\n   * Clear all search history for a user\n   */\n  async clearSearchHistory(currentUserId: string): Promise<ApiResponse<null>> {\n    try {\n      await this.clearSearchHistoryUseCase.execute({\n        userId: currentUserId,\n      });\n\n      return {\n        success: true,\n        message: 'Search history cleared successfully',\n        data: null,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to clear search history for user ${currentUserId}:`,\n        error,\n      );\n      return {\n        success: false,\n        message: 'Failed to clear search history',\n        data: null,\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\use-cases\\add-search-entry.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\use-cases\\clear-search-history.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\use-cases\\get-search-history.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\use-cases\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\application\\use-cases\\remove-search-entry.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\repositories\\search-history-domain-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\repositories\\search-history.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\search-history.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\search-history.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\search-history.exceptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\domain\\services\\search-history-domain.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'InvalidUserIdException' is defined but never used.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { SearchHistory } from '../search-history.entity';\nimport {\n  InvalidUserIdException,\n  SearchHistoryLimitExceededException,\n} from '../search-history.exceptions';\n\n/**\n * Domain service for SearchHistory business logic\n * Encapsulates complex domain rules that don't belong to a single entity\n */\n@Injectable()\nexport class SearchHistoryDomainService {\n  private readonly MAX_ENTRIES = 20;\n  private readonly DUPLICATE_THRESHOLD_MS = 1000 * 60 * 5; // 5 minutes\n\n  /**\n   * Validates if a user can add a search entry\n   */\n  canAddSearchEntry(\n    searchHistory: SearchHistory,\n    searchedUserId: string,\n  ): boolean {\n    // Cannot add self to search history\n    if (searchHistory.userId === searchedUserId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Validates if a user can view another user's search history\n   */\n  canViewSearchHistory(\n    searchHistory: SearchHistory,\n    viewerId: string,\n  ): boolean {\n    // Only the owner can view their search history\n    return searchHistory.userId === viewerId;\n  }\n\n  /**\n   * Validates if a user can modify search history\n   */\n  canModifySearchHistory(\n    searchHistory: SearchHistory,\n    userId: string,\n  ): boolean {\n    return searchHistory.userId === userId;\n  }\n\n  /**\n   * Checks if adding an entry would exceed the limit\n   */\n  wouldExceedLimit(searchHistory: SearchHistory): boolean {\n    return searchHistory.entriesCount >= this.MAX_ENTRIES;\n  }\n\n  /**\n   * Checks if a search entry is considered a duplicate within the threshold\n   */\n  isDuplicateWithinThreshold(\n    searchHistory: SearchHistory,\n    searchedUserId: string,\n    searchTime: Date,\n  ): boolean {\n    const existingEntry = searchHistory.entries.find(\n      (entry) => entry.searchedUserId === searchedUserId,\n    );\n\n    if (!existingEntry) {\n      return false;\n    }\n\n    const timeDiff = searchTime.getTime() - existingEntry.searchedAt.getTime();\n    return timeDiff < this.DUPLICATE_THRESHOLD_MS;\n  }\n\n  /**\n   * Gets the most frequently searched users from search history\n   */\n  getMostSearchedUsers(\n    searchHistory: SearchHistory,\n    limit: number = 5,\n  ): string[] {\n    const userCounts = new Map<string, number>();\n\n    // Count occurrences of each searched user\n    searchHistory.entries.forEach((entry) => {\n      const count = userCounts.get(entry.searchedUserId) || 0;\n      userCounts.set(entry.searchedUserId, count + 1);\n    });\n\n    // Sort by count and return top users\n    return Array.from(userCounts.entries())\n      .sort(([, countA], [, countB]) => countB - countA)\n      .slice(0, limit)\n      .map(([userId]) => userId);\n  }\n\n  /**\n   * Gets recent search patterns for analytics\n   */\n  getSearchPatterns(searchHistory: SearchHistory): {\n    totalSearches: number;\n    uniqueUsers: number;\n    averageSearchesPerDay: number;\n    mostActiveDay: string | null;\n  } {\n    const entries = searchHistory.entries;\n    const uniqueUsers = new Set(entries.map((e) => e.searchedUserId)).size;\n\n    if (entries.length === 0) {\n      return {\n        totalSearches: 0,\n        uniqueUsers: 0,\n        averageSearchesPerDay: 0,\n        mostActiveDay: null,\n      };\n    }\n\n    // Group searches by date\n    const searchesByDate = new Map<string, number>();\n    entries.forEach((entry) => {\n      const date = entry.searchedAt.toISOString().split('T')[0];\n      const count = searchesByDate.get(date) || 0;\n      searchesByDate.set(date, count + 1);\n    });\n\n    const days = searchesByDate.size;\n    const averageSearchesPerDay = days > 0 ? entries.length / days : 0;\n\n    // Find most active day\n    let mostActiveDay: string | null = null;\n    let maxSearches = 0;\n    searchesByDate.forEach((count, date) => {\n      if (count > maxSearches) {\n        maxSearches = count;\n        mostActiveDay = date;\n      }\n    });\n\n    return {\n      totalSearches: entries.length,\n      uniqueUsers,\n      averageSearchesPerDay: Math.round(averageSearchesPerDay * 100) / 100,\n      mostActiveDay,\n    };\n  }\n\n  /**\n   * Validates search history business rules\n   */\n  validateSearchHistory(searchHistory: SearchHistory): void {\n    if (searchHistory.entriesCount > this.MAX_ENTRIES) {\n      throw new SearchHistoryLimitExceededException(\n        `Search history cannot exceed ${this.MAX_ENTRIES} entries`,\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\infrastructure\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\infrastructure\\repositories\\prisma-search-history.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":153,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":165,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":153,"column":43,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":153,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entries on an `any` value.","line":153,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":153,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":154,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":154,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":154,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":154,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":155,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":155,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUserId on an `any` value.","line":155,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":156,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":156,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedAt on an `any` value.","line":156,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":156,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUser on an `any` value.","line":157,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":157,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":159,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":159,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUser on an `any` value.","line":159,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":160,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":160,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUser on an `any` value.","line":160,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":160,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":161,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":161,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUser on an `any` value.","line":161,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":162,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":162,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .searchedUser on an `any` value.","line":162,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":162,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":168,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":168,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":168,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":168,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":169,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":169,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":169,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":169,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":171,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":171,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":171,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":171,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":172,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":172,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":172,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":172,"endColumn":32}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../../database/prisma.service';\nimport {\n  SearchHistory,\n  SearchHistoryEntry,\n} from '../../domain/search-history.entity';\nimport { SearchHistoryRepository } from '../../domain/repositories/search-history.repository';\n\n@Injectable()\nexport class PrismaSearchHistoryRepository extends SearchHistoryRepository {\n  constructor(private readonly prisma: PrismaService) {\n    super();\n  }\n\n  async findByUserId(userId: string): Promise<SearchHistory | null> {\n    const searchHistoryData = await this.prisma.searchHistory.findUnique({\n      where: { userId },\n      include: {\n        entries: {\n          include: {\n            searchedUser: {\n              select: {\n                id: true,\n                username: true,\n                fullName: true,\n                avatar: true,\n              },\n            },\n          },\n          orderBy: {\n            searchedAt: 'desc',\n          },\n        },\n      },\n    });\n\n    if (!searchHistoryData) {\n      return null;\n    }\n\n    return this.toDomainEntity(searchHistoryData);\n  }\n\n  async save(searchHistory: SearchHistory): Promise<SearchHistory> {\n    const snapshot = searchHistory.toSnapshot();\n\n    // Use upsert to handle both create and update\n    const savedData = await this.prisma.searchHistory.upsert({\n      where: { userId: snapshot.userId },\n      create: {\n        id: snapshot.id!,\n        userId: snapshot.userId,\n        createdAt: snapshot.createdAt!,\n        updatedAt: snapshot.updatedAt!,\n        entries: {\n          create: snapshot.entries.map((entry) => ({\n            id: entry.id,\n            searchedUserId: entry.searchedUserId,\n            searchedAt: entry.searchedAt,\n          })),\n        },\n      },\n      update: {\n        updatedAt: snapshot.updatedAt!,\n        entries: {\n          // Delete existing entries and create new ones\n          deleteMany: {},\n          create: snapshot.entries.map((entry) => ({\n            id: entry.id,\n            searchedUserId: entry.searchedUserId,\n            searchedAt: entry.searchedAt,\n          })),\n        },\n      },\n      include: {\n        entries: {\n          include: {\n            searchedUser: {\n              select: {\n                id: true,\n                username: true,\n                fullName: true,\n                avatar: true,\n              },\n            },\n          },\n          orderBy: {\n            searchedAt: 'desc',\n          },\n        },\n      },\n    });\n\n    return this.toDomainEntity(savedData);\n  }\n\n  async deleteByUserId(userId: string): Promise<void> {\n    await this.prisma.searchHistory.delete({\n      where: { userId },\n    });\n  }\n\n  async existsByUserId(userId: string): Promise<boolean> {\n    const count = await this.prisma.searchHistory.count({\n      where: { userId },\n    });\n    return count > 0;\n  }\n\n  async getEntriesCountByUserId(userId: string): Promise<number> {\n    const searchHistory = await this.prisma.searchHistory.findUnique({\n      where: { userId },\n      include: {\n        _count: {\n          select: { entries: true },\n        },\n      },\n    });\n\n    return searchHistory?._count?.entries ?? 0;\n  }\n\n  async findManyByUserIds(userIds: string[]): Promise<SearchHistory[]> {\n    const searchHistories = await this.prisma.searchHistory.findMany({\n      where: {\n        userId: {\n          in: userIds,\n        },\n      },\n      include: {\n        entries: {\n          include: {\n            searchedUser: {\n              select: {\n                id: true,\n                username: true,\n                fullName: true,\n                avatar: true,\n              },\n            },\n          },\n          orderBy: {\n            searchedAt: 'desc',\n          },\n        },\n      },\n    });\n\n    return searchHistories.map((data) => this.toDomainEntity(data));\n  }\n\n  private toDomainEntity(data: any): SearchHistory {\n    const entries: SearchHistoryEntry[] = data.entries.map((entry: any) => ({\n      id: entry.id,\n      searchedUserId: entry.searchedUserId,\n      searchedAt: entry.searchedAt,\n      searchedUserProfile: entry.searchedUser\n        ? {\n            id: entry.searchedUser.id,\n            userName: entry.searchedUser.username,\n            fullName: entry.searchedUser.fullName,\n            avatar: entry.searchedUser.avatar,\n          }\n        : undefined,\n    }));\n\n    return SearchHistory.fromPersistence({\n      id: data.id,\n      userId: data.userId,\n      entries,\n      createdAt: data.createdAt,\n      updatedAt: data.updatedAt,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\presentation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\presentation\\search-history.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\search-history\\search-history.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\dto\\create-user.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\dto\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\dto\\update-profile.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\dto\\user-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\dto\\user.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":21,"column":29,"nodeType":"ChainExpression","messageId":"unsafeReturn","endLine":21,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":21,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":21,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":21,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":21,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":21,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":21,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .trim on an `any` value.","line":21,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":21,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":25,"column":29,"nodeType":"ChainExpression","messageId":"unsafeReturn","endLine":25,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":25,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":25,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":25,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":25,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":25,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":25,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .trim on an `any` value.","line":25,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":25,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":214,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":214,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":218,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":218,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":227,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":227,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":231,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":231,"endColumn":43}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsEmail,\n  IsString,\n  MinLength,\n  MaxLength,\n  IsOptional,\n  IsUrl,\n  IsPhoneNumber,\n  IsDateString,\n  IsIn,\n} from 'class-validator';\nimport { Transform } from 'class-transformer';\n\n/**\n * DTO for creating a new user\n */\nexport class CreateUserDto {\n  @IsString()\n  @MinLength(3, { message: 'Username must be at least 3 characters long' })\n  @MaxLength(30, { message: 'Username cannot exceed 30 characters' })\n  @Transform(({ value }) => value?.toLowerCase().trim())\n  username: string;\n\n  @IsEmail({}, { message: 'Please provide a valid email address' })\n  @Transform(({ value }) => value?.toLowerCase().trim())\n  email: string;\n\n  @IsString()\n  @MinLength(6, { message: 'Password must be at least 6 characters long' })\n  @MaxLength(128, { message: 'Password cannot exceed 128 characters' })\n  password: string;\n\n  @IsString()\n  @MinLength(2, { message: 'Full name must be at least 2 characters long' })\n  @MaxLength(100, { message: 'Full name cannot exceed 100 characters' })\n  fullName: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(500, { message: 'Bio cannot exceed 500 characters' })\n  bio?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(100, { message: 'Location cannot exceed 100 characters' })\n  location?: string;\n\n  @IsOptional()\n  @IsUrl({}, { message: 'Please provide a valid website URL' })\n  websiteUrl?: string;\n\n  @IsOptional()\n  @IsDateString({}, { message: 'Please provide a valid date of birth' })\n  dateOfBirth?: string;\n\n  @IsOptional()\n  @IsPhoneNumber(undefined, { message: 'Please provide a valid phone number' })\n  phoneNumber?: string;\n\n  @IsOptional()\n  @IsString()\n  @IsIn(['MALE', 'FEMALE', 'OTHER', 'PREFER_NOT_TO_SAY'])\n  gender?: string;\n}\n\n/**\n * DTO for Google OAuth user creation\n */\nexport class CreateGoogleUserDto {\n  @IsString()\n  googleId: string;\n\n  @IsEmail()\n  email: string;\n\n  @IsString()\n  @MinLength(3)\n  @MaxLength(30)\n  username: string;\n\n  @IsString()\n  @MinLength(2)\n  @MaxLength(100)\n  fullName: string;\n\n  @IsOptional()\n  @IsString()\n  avatar?: string;\n}\n\n/**\n * DTO for updating user profile\n */\nexport class UpdateProfileDto {\n  @IsOptional()\n  @IsString()\n  @MinLength(2, { message: 'Full name must be at least 2 characters long' })\n  @MaxLength(100, { message: 'Full name cannot exceed 100 characters' })\n  fullName?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(500, { message: 'Bio cannot exceed 500 characters' })\n  bio?: string;\n\n  @IsOptional()\n  @IsString()\n  avatar?: string;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(100, { message: 'Location cannot exceed 100 characters' })\n  location?: string;\n\n  @IsOptional()\n  @IsUrl({}, { message: 'Please provide a valid website URL' })\n  websiteUrl?: string;\n\n  @IsOptional()\n  @IsDateString({}, { message: 'Please provide a valid date of birth' })\n  dateOfBirth?: string;\n\n  @IsOptional()\n  @IsPhoneNumber(undefined, { message: 'Please provide a valid phone number' })\n  phoneNumber?: string;\n\n  @IsOptional()\n  @IsString()\n  @IsIn(['MALE', 'FEMALE', 'OTHER', 'PREFER_NOT_TO_SAY'])\n  gender?: string;\n}\n\n/**\n * DTO for user response (public data)\n */\nexport class UserResponseDto {\n  id: string;\n  username: string;\n  email: string;\n  fullName: string;\n  bio?: string;\n  avatar?: string;\n  location?: string;\n  websiteUrl?: string;\n  isEmailVerified: boolean;\n  followersCount: number;\n  followingCount: number;\n  isFollowing?: boolean; // Only present when viewed by another user\n  createdAt: Date;\n  updatedAt: Date;\n\n  constructor(partial: Partial<UserResponseDto>) {\n    Object.assign(this, partial);\n  }\n}\n\n/**\n * DTO for user profile response (private data for owner)\n */\nexport class UserProfileResponseDto extends UserResponseDto {\n  phoneNumber?: string;\n  gender?: string;\n  dateOfBirth?: Date;\n  emailVerifiedAt?: Date;\n  lastProfileUpdate?: Date;\n  role: string;\n  status: string;\n  canCreatePost: boolean;\n  canComment: boolean;\n  accountAge: number;\n  isProfileComplete: boolean;\n\n  constructor(partial: Partial<UserProfileResponseDto>) {\n    super(partial);\n    Object.assign(this, partial);\n  }\n}\n\n/**\n * DTO for user list (minimal data)\n */\nexport class UserListItemDto {\n  id: string;\n  username: string;\n  fullName: string;\n  avatar?: string;\n  bio?: string;\n  followersCount: number;\n  isFollowing?: boolean;\n\n  constructor(partial: Partial<UserListItemDto>) {\n    Object.assign(this, partial);\n  }\n}\n\n/**\n * DTO for follow/unfollow operations\n */\nexport class FollowUserDto {\n  @IsString()\n  targetUserId: string;\n}\n\n/**\n * DTO for user search query\n */\nexport class SearchUsersDto {\n  @IsString()\n  @MinLength(2, { message: 'Search query must be at least 2 characters long' })\n  @MaxLength(100, { message: 'Search query cannot exceed 100 characters' })\n  query: string;\n\n  @IsOptional()\n  @Transform(({ value }) => parseInt(value))\n  page?: number = 1;\n\n  @IsOptional()\n  @Transform(({ value }) => parseInt(value))\n  limit?: number = 20;\n}\n\n/**\n * DTO for getting user followers/following\n */\nexport class GetFollowersDto {\n  @IsOptional()\n  @Transform(({ value }) => parseInt(value))\n  page?: number = 1;\n\n  @IsOptional()\n  @Transform(({ value }) => parseInt(value))\n  limit?: number = 20;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\events\\user-event.handlers.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handle' has no 'await' expression.","line":22,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":22,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[733,788],"text":"handle(event: UserRegisteredEvent): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handle' has no 'await' expression.","line":67,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":67,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2168,2221],"text":"handle(event: UserFollowedEvent): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handle' has no 'await' expression.","line":113,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":113,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3748,3807],"text":"handle(event: UserProfileUpdatedEvent): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":150,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":150,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .changes on an `any` value.","line":150,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":150,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fullName on an `any` value.","line":151,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":151,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bio on an `any` value.","line":151,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":151,"endColumn":46},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handle' has no 'await' expression.","line":167,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":167,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5501,5559],"text":"handle(event: UserEmailVerifiedEvent): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { IEventHandler } from '../../../../shared/events/event-bus.interface';\nimport {\n  UserRegisteredEvent,\n  UserFollowedEvent,\n  UserProfileUpdatedEvent,\n  UserEmailVerifiedEvent,\n} from '../../domain/user.events';\n\n/**\n * Handler for user registration event\n * Sends welcome email and creates initial data\n */\n@Injectable()\nexport class UserRegisteredEventHandler\n  implements IEventHandler<UserRegisteredEvent>\n{\n  private readonly logger = new Logger(UserRegisteredEventHandler.name);\n\n  constructor() {} // private readonly emailService: IEmailService, // private readonly notificationService: INotificationService, // Inject notification service, email service, etc.\n\n  async handle(event: UserRegisteredEvent): Promise<void> {\n    this.logger.log(`Handling UserRegisteredEvent for user: ${event.userId}`);\n\n    try {\n      // Send welcome email\n      // await this.emailService.sendWelcomeEmail({\n      //   to: event.email,\n      //   username: event.username,\n      //   fullName: event.profile.fullName\n      // });\n\n      // Create welcome notification\n      // await this.notificationService.createNotification({\n      //   userId: event.userId,\n      //   type: NotificationType.WELCOME,\n      //   title: 'Welcome to Social Media Mini!',\n      //   message: 'Welcome to our community! Start by completing your profile.',\n      //   data: { isWelcome: true }\n      // });\n\n      this.logger.log(\n        `UserRegisteredEvent handled successfully for user: ${event.userId}`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to handle UserRegisteredEvent for user: ${event.userId}`,\n        error,\n      );\n      // In production, you might want to queue for retry\n    }\n  }\n}\n\n/**\n * Handler for user followed event\n * Creates notification for the followed user\n */\n@Injectable()\nexport class UserFollowedEventHandler\n  implements IEventHandler<UserFollowedEvent>\n{\n  private readonly logger = new Logger(UserFollowedEventHandler.name);\n\n  constructor() {} // private readonly userRepository: IUserRepository, // private readonly notificationService: INotificationService,\n\n  async handle(event: UserFollowedEvent): Promise<void> {\n    this.logger.log(\n      `Handling UserFollowedEvent: ${event.followerId} -> ${event.followeeId}`,\n    );\n\n    try {\n      // Get follower info for notification\n      // const follower = await this.userRepository.findById(event.followerId);\n      // if (!follower) return;\n\n      // Create notification for the followed user\n      // await this.notificationService.createNotification({\n      //   userId: event.followeeId,\n      //   type: NotificationType.NEW_FOLLOWER,\n      //   title: 'New Follower',\n      //   message: `${follower.username} started following you`,\n      //   data: {\n      //     followerId: event.followerId,\n      //     followerUsername: follower.username,\n      //     followerAvatar: follower.profile.avatar\n      //   }\n      // });\n\n      // Update user statistics cache\n      // await this.cacheService.invalidateUserStats(event.followeeId);\n      // await this.cacheService.invalidateUserStats(event.followerId);\n\n      this.logger.log(`UserFollowedEvent handled successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to handle UserFollowedEvent`, error);\n    }\n  }\n}\n\n/**\n * Handler for profile updated event\n * Invalidates caches and updates search indexes\n */\n@Injectable()\nexport class UserProfileUpdatedEventHandler\n  implements IEventHandler<UserProfileUpdatedEvent>\n{\n  private readonly logger = new Logger(UserProfileUpdatedEventHandler.name);\n\n  constructor() {} // private readonly searchService: ISearchService, // private readonly cacheService: ICacheService,\n\n  async handle(event: UserProfileUpdatedEvent): Promise<void> {\n    this.logger.log(\n      `Handling UserProfileUpdatedEvent for user: ${event.userId}`,\n    );\n\n    try {\n      // Invalidate user profile caches\n      // await this.cacheService.invalidateUserProfile(event.userId);\n\n      // Update search index if searchable fields changed\n      // const searchableChanges = this.hasSearchableChanges(event);\n      // if (searchableChanges) {\n      //   await this.searchService.updateUserIndex(event.userId, {\n      //     fullName: event.newProfile.fullName,\n      //     bio: event.newProfile.bio,\n      //     location: event.newProfile.location\n      //   });\n      // }\n\n      // If avatar changed, update all user's posts cache\n      // if (event.changes.avatar) {\n      //   await this.cacheService.invalidateUserPosts(event.userId);\n      // }\n\n      this.logger.log(\n        `UserProfileUpdatedEvent handled successfully for user: ${event.userId}`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to handle UserProfileUpdatedEvent for user: ${event.userId}`,\n        error,\n      );\n    }\n  }\n\n  private hasSearchableChanges(event: UserProfileUpdatedEvent): boolean {\n    const eventData = event.toJSON();\n    const changes = eventData.data.changes;\n    return !!(changes.fullName || changes.bio);\n  }\n}\n\n/**\n * Handler for email verified event\n * Updates user permissions and sends confirmation\n */\n@Injectable()\nexport class UserEmailVerifiedEventHandler\n  implements IEventHandler<UserEmailVerifiedEvent>\n{\n  private readonly logger = new Logger(UserEmailVerifiedEventHandler.name);\n\n  constructor() {} // private readonly emailService: IEmailService, // private readonly notificationService: INotificationService,\n\n  async handle(event: UserEmailVerifiedEvent): Promise<void> {\n    this.logger.log(\n      `Handling UserEmailVerifiedEvent for user: ${event.userId}`,\n    );\n\n    try {\n      // Send email verification confirmation\n      // await this.emailService.sendEmailVerificationConfirmation({\n      //   to: event.email,\n      //   verifiedAt: event.verifiedAt\n      // });\n\n      // Create notification\n      // await this.notificationService.createNotification({\n      //   userId: event.userId,\n      //   type: NotificationType.EMAIL_VERIFIED,\n      //   title: 'Email Verified',\n      //   message: 'Your email has been successfully verified! You can now create posts and interact with others.',\n      //   data: { verifiedAt: event.verifiedAt.toISOString() }\n      // });\n\n      // Update user permissions cache\n      // await this.cacheService.invalidateUserPermissions(event.userId);\n\n      this.logger.log(\n        `UserEmailVerifiedEvent handled successfully for user: ${event.userId}`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to handle UserEmailVerifiedEvent for user: ${event.userId}`,\n        error,\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\interfaces\\user-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\use-cases\\create-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\use-cases\\follow-user.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { User, UserDomainService, IUserRepository, UserId } from '../../domain';\nimport { IEventBus } from '../../../../shared/events/event-bus.interface';\nimport { EntityNotFoundException } from '../../../../shared/exceptions/domain.exception';\nimport { USER_REPOSITORY_TOKEN } from '../../users.module';\n\n/**\n * Use case for following a user\n * Implements Clean Architecture principles\n */\n@Injectable()\nexport class FollowUserUseCase {\n  private readonly logger = new Logger(FollowUserUseCase.name);\n\n  constructor(\n    @Inject(USER_REPOSITORY_TOKEN)\n    private readonly userRepository: IUserRepository,\n    private readonly userDomainService: UserDomainService,\n    private readonly eventBus: IEventBus,\n  ) {}\n\n  async execute(followerId: string, followeeId: string): Promise<void> {\n    this.logger.log(\n      `User ${followerId} attempting to follow user ${followeeId}`,\n    );\n\n    // Create value objects\n    const followerUserId = UserId.create(followerId);\n    const followeeUserId = UserId.create(followeeId);\n\n    // Load both users\n    const [follower, followee] = await Promise.all([\n      this.userRepository.findById(followerUserId),\n      this.userRepository.findById(followeeUserId),\n    ]);\n\n    if (!follower) {\n      throw new EntityNotFoundException('User', followerId);\n    }\n\n    if (!followee) {\n      throw new EntityNotFoundException('User', followeeId);\n    }\n\n    // Validate business rules using domain service\n    await this.userDomainService.validateFollowRules(follower, followee);\n\n    // Execute domain logic\n    follower.follow(followeeId, followee.username);\n    followee.addFollower(followerId);\n\n    // Update follow relationship\n    await this.userRepository.updateFollowRelationship(\n      followerUserId,\n      followeeUserId,\n      true,\n    );\n\n    // Save users\n    await Promise.all([\n      this.userRepository.save(follower),\n      this.userRepository.save(followee),\n    ]);\n\n    // Publish domain events\n    for (const event of follower.domainEvents) {\n      await this.eventBus.publish(event);\n    }\n    follower.clearEvents();\n\n    this.logger.log(\n      `User ${followerId} successfully followed user ${followeeId}`,\n    );\n  }\n}\n\n/**\n * Use case for unfollowing a user\n */\n@Injectable()\nexport class UnfollowUserUseCase {\n  private readonly logger = new Logger(UnfollowUserUseCase.name);\n\n  constructor(\n    private readonly userRepository: IUserRepository,\n    private readonly userDomainService: UserDomainService,\n    private readonly eventBus: IEventBus,\n  ) {}\n\n  async execute(followerId: string, followeeId: string): Promise<void> {\n    this.logger.log(\n      `User ${followerId} attempting to unfollow user ${followeeId}`,\n    );\n\n    // Create value objects\n    const followerUserId = UserId.create(followerId);\n    const followeeUserId = UserId.create(followeeId);\n\n    // Load both users\n    const [follower, followee] = await Promise.all([\n      this.userRepository.findById(followerUserId),\n      this.userRepository.findById(followeeUserId),\n    ]);\n\n    if (!follower) {\n      throw new EntityNotFoundException('User', followerId);\n    }\n\n    if (!followee) {\n      throw new EntityNotFoundException('User', followeeId);\n    }\n\n    // Validate business rules using domain service\n    this.userDomainService.validateUnfollowRules(follower, followee);\n\n    // Execute domain logic\n    follower.unfollow(followeeId, followee.username);\n    followee.removeFollower(followerId);\n\n    // Update follow relationship\n    await this.userRepository.updateFollowRelationship(\n      followerUserId,\n      followeeUserId,\n      false,\n    );\n\n    // Save users\n    await Promise.all([\n      this.userRepository.save(follower),\n      this.userRepository.save(followee),\n    ]);\n\n    // Publish domain events\n    for (const event of follower.domainEvents) {\n      await this.eventBus.publish(event);\n    }\n    follower.clearEvents();\n\n    this.logger.log(\n      `User ${followerId} successfully unfollowed user ${followeeId}`,\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\use-cases\\get-user.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { User } from '../../domain';\nimport { IUserRepository } from '../interfaces/user-repository.interface';\nimport {\n  UserResponseDto,\n  UserProfileResponseDto,\n  UserListItemDto,\n  SearchUsersDto,\n  GetFollowersDto,\n} from '../dto/user.dto';\nimport { EntityNotFoundException } from '../../../../shared/exceptions/domain.exception';\n\n/**\n * Use case for getting user profile by ID\n */\n@Injectable()\nexport class GetUserProfileUseCase {\n  private readonly logger = new Logger(GetUserProfileUseCase.name);\n\n  constructor(private readonly userRepository: IUserRepository) {}\n\n  async execute(\n    userId: string,\n    requesterId?: string,\n  ): Promise<UserResponseDto | UserProfileResponseDto> {\n    this.logger.log(\n      `Getting user profile for: ${userId}, requester: ${requesterId}`,\n    );\n\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new EntityNotFoundException('User', userId);\n    }\n\n    // If user is viewing their own profile, return full profile data\n    if (requesterId === userId) {\n      const stats = user.getStats();\n      return new UserProfileResponseDto({\n        id: user.id,\n        username: user.username,\n        email: user.email,\n        fullName: user.profile.fullName,\n        bio: user.profile.bio,\n        avatar: user.profile.avatar,\n        location: user.profile.location,\n        websiteUrl: user.profile.websiteUrl,\n        phoneNumber: user.profile.phoneNumber,\n        gender: user.profile.gender,\n        dateOfBirth: user.profile.dateOfBirth,\n        isEmailVerified: user.isEmailVerified,\n        emailVerifiedAt: user.emailVerifiedAt,\n        lastProfileUpdate: user.lastProfileUpdate,\n        role: user.role,\n        status: user.status,\n        followersCount: user.followersCount,\n        followingCount: user.followingCount,\n        createdAt: user.createdAt,\n        updatedAt: user.updatedAt,\n        canCreatePost: stats.canCreatePost,\n        canComment: stats.canComment,\n        accountAge: stats.accountAge,\n        isProfileComplete: stats.isProfileComplete,\n      });\n    }\n\n    // For other users, return public profile with follow status\n    let isFollowing: boolean | undefined;\n    if (requesterId) {\n      isFollowing = user.isFollowedBy(requesterId);\n    }\n\n    return new UserResponseDto({\n      id: user.id,\n      username: user.username,\n      email: user.email,\n      fullName: user.profile.fullName,\n      bio: user.profile.bio,\n      avatar: user.profile.avatar,\n      location: user.profile.location,\n      websiteUrl: user.profile.websiteUrl,\n      isEmailVerified: user.isEmailVerified,\n      followersCount: user.followersCount,\n      followingCount: user.followingCount,\n      isFollowing,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt,\n    });\n  }\n}\n\n/**\n * Use case for searching users\n */\n@Injectable()\nexport class SearchUsersUseCase {\n  private readonly logger = new Logger(SearchUsersUseCase.name);\n\n  constructor(private readonly userRepository: IUserRepository) {}\n\n  async execute(\n    dto: SearchUsersDto,\n    requesterId?: string,\n  ): Promise<{\n    users: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n    page: number;\n    limit: number;\n  }> {\n    this.logger.log(\n      `Searching users with query: ${dto.query}, page: ${dto.page}`,\n    );\n\n    const { users, total, hasMore } = await this.userRepository.searchUsers(\n      dto.query,\n      dto.page || 1,\n      dto.limit || 20,\n    );\n\n    // Convert to DTOs with follow status\n    const userDtos = users.map((user) => {\n      let isFollowing: boolean | undefined;\n      if (requesterId && user.id !== requesterId) {\n        isFollowing = user.isFollowedBy(requesterId);\n      }\n\n      return new UserListItemDto({\n        id: user.id,\n        username: user.username,\n        fullName: user.profile.fullName,\n        avatar: user.profile.avatar,\n        bio: user.profile.bio,\n        followersCount: user.followersCount,\n        isFollowing,\n      });\n    });\n\n    return {\n      users: userDtos,\n      total,\n      hasMore,\n      page: dto.page || 1,\n      limit: dto.limit || 20,\n    };\n  }\n}\n\n/**\n * Use case for getting user followers\n */\n@Injectable()\nexport class GetUserFollowersUseCase {\n  private readonly logger = new Logger(GetUserFollowersUseCase.name);\n\n  constructor(private readonly userRepository: IUserRepository) {}\n\n  async execute(\n    userId: string,\n    dto: GetFollowersDto,\n    requesterId?: string,\n  ): Promise<{\n    followers: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    this.logger.log(`Getting followers for user: ${userId}`);\n\n    // Check if user exists\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new EntityNotFoundException('User', userId);\n    }\n\n    const { followers, total, hasMore } =\n      await this.userRepository.getFollowers(\n        userId,\n        dto.page || 1,\n        dto.limit || 20,\n      );\n\n    // Convert to DTOs\n    const followerDtos = followers.map((follower) => {\n      let isFollowing: boolean | undefined;\n      if (requesterId && follower.id !== requesterId) {\n        isFollowing = follower.isFollowedBy(requesterId);\n      }\n\n      return new UserListItemDto({\n        id: follower.id,\n        username: follower.username,\n        fullName: follower.profile.fullName,\n        avatar: follower.profile.avatar,\n        bio: follower.profile.bio,\n        followersCount: follower.followersCount,\n        isFollowing,\n      });\n    });\n\n    return {\n      followers: followerDtos,\n      total,\n      hasMore,\n    };\n  }\n}\n\n/**\n * Use case for getting users that current user is following\n */\n@Injectable()\nexport class GetUserFollowingUseCase {\n  private readonly logger = new Logger(GetUserFollowingUseCase.name);\n\n  constructor(private readonly userRepository: IUserRepository) {}\n\n  async execute(\n    userId: string,\n    dto: GetFollowersDto,\n    requesterId?: string,\n  ): Promise<{\n    following: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    this.logger.log(`Getting following for user: ${userId}`);\n\n    // Check if user exists\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new EntityNotFoundException('User', userId);\n    }\n\n    const { following, total, hasMore } =\n      await this.userRepository.getFollowing(\n        userId,\n        dto.page || 1,\n        dto.limit || 20,\n      );\n\n    // Convert to DTOs\n    const followingDtos = following.map((followedUser) => {\n      let isFollowing: boolean | undefined;\n      if (requesterId && followedUser.id !== requesterId) {\n        isFollowing = followedUser.isFollowedBy(requesterId);\n      }\n\n      return new UserListItemDto({\n        id: followedUser.id,\n        username: followedUser.username,\n        fullName: followedUser.profile.fullName,\n        avatar: followedUser.profile.avatar,\n        bio: followedUser.profile.bio,\n        followersCount: followedUser.followersCount,\n        isFollowing,\n      });\n    });\n\n    return {\n      following: followingDtos,\n      total,\n      hasMore,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\use-cases\\update-profile.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { User, UserProfile } from '../../domain';\nimport { IUserRepository } from '../interfaces/user-repository.interface';\nimport { IEventBus } from '../../../../shared/events/event-bus.interface';\nimport { UpdateProfileDto, UserResponseDto } from '../dto/user.dto';\nimport { EntityNotFoundException } from '../../../../shared/exceptions/domain.exception';\n\n/**\n * Use case for updating user profile\n */\n@Injectable()\nexport class UpdateProfileUseCase {\n  private readonly logger = new Logger(UpdateProfileUseCase.name);\n\n  constructor(\n    private readonly userRepository: IUserRepository,\n    private readonly eventBus: IEventBus,\n  ) {}\n\n  async execute(\n    userId: string,\n    dto: UpdateProfileDto,\n  ): Promise<UserResponseDto> {\n    this.logger.log(`Updating profile for user: ${userId}`);\n\n    // Load user\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new EntityNotFoundException('User', userId);\n    }\n\n    // Create updated profile\n    const currentProfile = user.profile;\n    const updatedProfile = new UserProfile({\n      fullName: dto.fullName ?? currentProfile.fullName,\n      bio: dto.bio ?? currentProfile.bio,\n      avatar: dto.avatar ?? currentProfile.avatar,\n      location: dto.location ?? currentProfile.location,\n      websiteUrl: dto.websiteUrl ?? currentProfile.websiteUrl,\n      dateOfBirth: dto.dateOfBirth\n        ? new Date(dto.dateOfBirth)\n        : currentProfile.dateOfBirth,\n      phoneNumber: dto.phoneNumber ?? currentProfile.phoneNumber,\n      gender: dto.gender ?? currentProfile.gender,\n    });\n\n    // Execute domain logic\n    user.updateProfile(updatedProfile);\n\n    // Save changes\n    const updatedUser = await this.userRepository.save(user);\n\n    // Publish domain events\n    await this.eventBus.publishAll(updatedUser.domainEvents);\n    updatedUser.clearEvents();\n\n    this.logger.log(`Profile updated successfully for user: ${userId}`);\n\n    // Return response DTO\n    return new UserResponseDto({\n      id: updatedUser.id,\n      username: updatedUser.username,\n      email: updatedUser.email,\n      fullName: updatedUser.profile.fullName,\n      bio: updatedUser.profile.bio,\n      avatar: updatedUser.profile.avatar,\n      location: updatedUser.profile.location,\n      websiteUrl: updatedUser.profile.websiteUrl,\n      isEmailVerified: updatedUser.isEmailVerified,\n      followersCount: updatedUser.followersCount,\n      followingCount: updatedUser.followingCount,\n      createdAt: updatedUser.createdAt,\n      updatedAt: updatedUser.updatedAt,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\use-cases\\verify-email.use-case.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { User } from '../../domain';\nimport { IUserRepository } from '../interfaces/user-repository.interface';\nimport { IEventBus } from '../../../../shared/events/event-bus.interface';\nimport { EntityNotFoundException } from '../../../../shared/exceptions/domain.exception';\n\n/**\n * Use case for verifying user email\n */\n@Injectable()\nexport class VerifyEmailUseCase {\n  private readonly logger = new Logger(VerifyEmailUseCase.name);\n\n  constructor(\n    private readonly userRepository: IUserRepository,\n    private readonly eventBus: IEventBus,\n  ) {}\n\n  async execute(userId: string): Promise<void> {\n    this.logger.log(`Verifying email for user: ${userId}`);\n\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new EntityNotFoundException('User', userId);\n    }\n\n    // Execute domain logic\n    user.verifyEmail();\n\n    // Save changes\n    const updatedUser = await this.userRepository.save(user);\n\n    // Publish domain events\n    await this.eventBus.publishAll(updatedUser.domainEvents);\n    updatedUser.clearEvents();\n\n    this.logger.log(`Email verified successfully for user: ${userId}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\application\\user-application.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\factories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\factories\\user.factory.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `UserProfileProps`.","line":137,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":137,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { User, UserRole, UserStatus } from '../user.entity';\nimport {\n  UserId,\n  UserEmail,\n  Username,\n  Password,\n  UserProfile,\n} from '../value-objects';\n\nexport interface CreateUserRequest {\n  username: string;\n  email: string;\n  password?: string;\n  googleId?: string;\n  profile: {\n    fullName: string;\n    bio?: string;\n    dateOfBirth?: Date;\n    avatar?: string;\n    websiteUrl?: string;\n    location?: string;\n    phoneNumber?: string;\n    gender?: string;\n  };\n  role?: UserRole;\n}\n\nexport interface CreateUserFromGoogleRequest {\n  googleId: string;\n  email: string;\n  profile: {\n    fullName: string;\n    avatar?: string;\n  };\n}\n\n/**\n * User Factory\n * Handles complex user creation logic and ensures domain invariants\n */\nexport class UserFactory {\n  /**\n   * Create a new user with email/password\n   */\n  static async createUser(request: CreateUserRequest): Promise<User> {\n    // Create value objects\n    const userId = UserId.generate();\n    const email = UserEmail.create(request.email);\n    const username = Username.create(request.username);\n    const userProfile = new UserProfile(request.profile);\n\n    let password: Password | undefined;\n    if (request.password) {\n      password = await Password.createFromPlainText(request.password);\n    }\n\n    // Create user with proper encapsulation\n    const user = new User(\n      userId.getValue(),\n      username.getValue(),\n      email.getValue(),\n      userProfile,\n      {\n        passwordHash: password?.getValue(),\n        role: request.role || UserRole.USER,\n        status: UserStatus.ACTIVE,\n        isEmailVerified: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    );\n\n    return user;\n  }\n\n  /**\n   * Create user from Google OAuth\n   */\n  static createUserFromGoogle(request: CreateUserFromGoogleRequest): User {\n    // Create value objects\n    const userId = UserId.generate();\n    const email = UserEmail.create(request.email);\n\n    // Generate username from email local part\n    const emailLocal = email.getLocalPart();\n    const baseUsername = emailLocal.replace(/[^a-z0-9]/g, '');\n    const username = Username.create(baseUsername);\n\n    const userProfile = new UserProfile({\n      fullName: request.profile.fullName,\n      avatar: request.profile.avatar,\n    });\n\n    const user = new User(\n      userId.getValue(),\n      username.getValue(),\n      email.getValue(),\n      userProfile,\n      {\n        googleId: request.googleId,\n        role: UserRole.USER,\n        status: UserStatus.ACTIVE,\n        isEmailVerified: true, // Google accounts are pre-verified\n        emailVerifiedAt: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    );\n\n    return user;\n  }\n\n  /**\n   * Reconstruct user from database data\n   */\n  static reconstructUser(data: {\n    id: string;\n    username: string;\n    email: string;\n    passwordHash?: string;\n    googleId?: string;\n    role: UserRole;\n    status: UserStatus;\n    isEmailVerified: boolean;\n    emailVerifiedAt?: Date;\n    createdAt: Date;\n    updatedAt: Date;\n    lastProfileUpdate?: Date;\n    profile: any; // Raw profile data from DB\n    followingIds?: string[];\n    followerIds?: string[];\n  }): User {\n    // Validate and create value objects\n    const userId = UserId.create(data.id);\n    const email = UserEmail.create(data.email);\n    const username = Username.create(data.username);\n    const userProfile = new UserProfile(data.profile);\n\n    const user = new User(\n      userId.getValue(),\n      username.getValue(),\n      email.getValue(),\n      userProfile,\n      {\n        passwordHash: data.passwordHash,\n        googleId: data.googleId,\n        role: data.role,\n        status: data.status,\n        isEmailVerified: data.isEmailVerified,\n        emailVerifiedAt: data.emailVerifiedAt,\n        createdAt: data.createdAt,\n        updatedAt: data.updatedAt,\n        lastProfileUpdate: data.lastProfileUpdate,\n      },\n    );\n\n    // Set follow relationships\n    if (data.followingIds || data.followerIds) {\n      user.setFollowingAndFollowers(\n        data.followingIds || [],\n        data.followerIds || [],\n      );\n    }\n\n    return user;\n  }\n\n  /**\n   * Create admin user\n   */\n  static async createAdminUser(request: CreateUserRequest): Promise<User> {\n    const adminRequest = {\n      ...request,\n      role: UserRole.ADMIN,\n    };\n\n    const user = await UserFactory.createUser(adminRequest);\n\n    // Admin users are automatically verified\n    user.verifyEmail();\n\n    return user;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\repositories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\repositories\\user.repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\services\\user-domain.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserId' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validateFollowRules' has no 'await' expression.","line":40,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":40,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1091,1163],"text":"validateFollowRules(follower: User, followee: User): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":52,"column":9,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":52,"endColumn":37,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[1577,1585],"text":"UserStatus.ACTIVE"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { User } from '../user.entity';\nimport { IUserRepository } from '../repositories';\nimport { UserId, UserEmail, Username } from '../value-objects';\nimport {\n  UsernameAlreadyExistsException,\n  EmailAlreadyExistsException,\n} from '../user.exceptions';\n\n/**\n * User Domain Service\n * Handles complex business logic that doesn't belong to a single aggregate\n */\nexport class UserDomainService {\n  constructor(private readonly userRepository: IUserRepository) {}\n\n  /**\n   * Check if user can be created with given email and username\n   */\n  async validateUserUniqueness(\n    email: UserEmail,\n    username: Username,\n  ): Promise<void> {\n    const [existingUserByEmail, existingUserByUsername] = await Promise.all([\n      this.userRepository.findByEmail(email),\n      this.userRepository.findByUsername(username),\n    ]);\n\n    if (existingUserByEmail) {\n      throw new EmailAlreadyExistsException(email.getValue());\n    }\n\n    if (existingUserByUsername) {\n      throw new UsernameAlreadyExistsException(username.getValue());\n    }\n  }\n\n  /**\n   * Validate follow business rules\n   */\n  async validateFollowRules(follower: User, followee: User): Promise<void> {\n    // Business rule: User cannot follow themselves\n    if (follower.id === followee.id) {\n      throw new Error('User cannot follow themselves');\n    }\n\n    // Business rule: Check if already following\n    if (follower.isFollowing(followee.id)) {\n      throw new Error(`Already following user ${followee.username}`);\n    }\n\n    // Business rule: Check if followee account is active\n    if (followee.status !== 'ACTIVE') {\n      throw new Error('Cannot follow inactive user account');\n    }\n\n    // Business rule: Check follower limits (example: max 5000 following)\n    if (follower.followingCount >= 5000) {\n      throw new Error('Maximum following limit reached');\n    }\n  }\n\n  /**\n   * Validate unfollow business rules\n   */\n  validateUnfollowRules(follower: User, followee: User): void {\n    // Business rule: Cannot unfollow if not following\n    if (!follower.isFollowing(followee.id)) {\n      throw new Error(`Not following user ${followee.username}`);\n    }\n  }\n\n  /**\n   * Calculate user interaction score (for recommendations, etc.)\n   */\n  calculateUserInteractionScore(user1: User, user2: User): number {\n    let score = 0;\n\n    // Mutual followers boost\n    const mutualFollowersCount = this.calculateMutualFollowersCount(\n      user1,\n      user2,\n    );\n    score += mutualFollowersCount * 2;\n\n    // Same creation timeframe (users who joined around same time)\n    const daysDifference =\n      Math.abs(user1.createdAt.getTime() - user2.createdAt.getTime()) /\n      (1000 * 60 * 60 * 24);\n\n    if (daysDifference <= 30) {\n      score += 5;\n    }\n\n    return score;\n  }\n\n  /**\n   * Check if users have mutual followers\n   */\n  private calculateMutualFollowersCount(user1: User, user2: User): number {\n    const user1Followers = new Set(user1.followerIds);\n    const user2Followers = new Set(user2.followerIds);\n\n    let mutualCount = 0;\n    for (const followerId of user1Followers) {\n      if (user2Followers.has(followerId)) {\n        mutualCount++;\n      }\n    }\n\n    return mutualCount;\n  }\n\n  /**\n   * Generate username suggestions based on display name\n   */\n  async generateUsernameSuggestions(displayName: string): Promise<string[]> {\n    const baseUsername = this.sanitizeDisplayNameForUsername(displayName);\n    const suggestions: string[] = [];\n\n    // Try base username\n    if (\n      !(await this.userRepository.existsByUsername(\n        Username.create(baseUsername),\n      ))\n    ) {\n      suggestions.push(baseUsername);\n    }\n\n    // Generate variations\n    for (let i = 1; i <= 5; i++) {\n      const variation = `${baseUsername}${i}`;\n      if (\n        !(await this.userRepository.existsByUsername(\n          Username.create(variation),\n        ))\n      ) {\n        suggestions.push(variation);\n      }\n    }\n\n    // Generate with year\n    const currentYear = new Date().getFullYear();\n    const withYear = `${baseUsername}${currentYear}`;\n    if (\n      !(await this.userRepository.existsByUsername(Username.create(withYear)))\n    ) {\n      suggestions.push(withYear);\n    }\n\n    return suggestions.slice(0, 3); // Return top 3 suggestions\n  }\n\n  /**\n   * Sanitize display name to create a valid username\n   */\n  private sanitizeDisplayNameForUsername(displayName: string): string {\n    return displayName\n      .toLowerCase()\n      .replace(/[^a-z0-9]/g, '') // Remove special characters\n      .substring(0, 20); // Limit length\n  }\n\n  /**\n   * Check if user can update profile (rate limiting)\n   */\n  canUpdateProfile(user: User): boolean {\n    if (!user.lastProfileUpdate) {\n      return true;\n    }\n\n    // Allow profile update once per day\n    const daysSinceLastUpdate =\n      (Date.now() - user.lastProfileUpdate.getTime()) / (1000 * 60 * 60 * 24);\n    return daysSinceLastUpdate >= 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\user-profile.value-object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\user.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\user.exceptions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationException' is defined but never used.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  BusinessRuleException,\n  EntityAlreadyExistsException,\n  ValidationException,\n} from '../../../shared/exceptions/domain.exception';\n\n/**\n * Exception thrown when user tries to follow themselves\n */\nexport class CannotFollowSelfException extends BusinessRuleException {\n  constructor() {\n    super('User cannot follow themselves', 'CANNOT_FOLLOW_SELF');\n  }\n}\n\n/**\n * Exception thrown when user tries to follow someone they already follow\n */\nexport class AlreadyFollowingUserException extends BusinessRuleException {\n  constructor(followeeUsername: string) {\n    super(\n      `Already following user ${followeeUsername}`,\n      'ALREADY_FOLLOWING_USER',\n    );\n  }\n}\n\n/**\n * Exception thrown when user tries to unfollow someone they don't follow\n */\nexport class NotFollowingUserException extends BusinessRuleException {\n  constructor(followeeUsername: string) {\n    super(`Not following user ${followeeUsername}`, 'NOT_FOLLOWING_USER');\n  }\n}\n\n/**\n * Exception thrown when username is already taken\n */\nexport class UsernameAlreadyExistsException extends EntityAlreadyExistsException {\n  constructor(username: string) {\n    super('User', username);\n  }\n}\n\n/**\n * Exception thrown when email is already registered\n */\nexport class EmailAlreadyExistsException extends EntityAlreadyExistsException {\n  constructor(email: string) {\n    super('User email', email);\n  }\n}\n\n/**\n * Exception thrown when user account is not active\n */\nexport class UserAccountInactiveException extends BusinessRuleException {\n  constructor() {\n    super('User account is inactive', 'USER_ACCOUNT_INACTIVE');\n  }\n}\n\n/**\n * Exception thrown when user email is not verified for actions requiring verification\n */\nexport class EmailNotVerifiedException extends BusinessRuleException {\n  constructor() {\n    super(\n      'Email must be verified to perform this action',\n      'EMAIL_NOT_VERIFIED',\n    );\n  }\n}\n\n/**\n * Exception thrown when user tries to update profile too frequently\n */\nexport class ProfileUpdateTooFrequentException extends BusinessRuleException {\n  constructor(nextAllowedUpdate: Date) {\n    super(\n      `Profile can be updated again after ${nextAllowedUpdate.toISOString()}`,\n      'PROFILE_UPDATE_TOO_FREQUENT',\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\value-objects\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\value-objects\\password.value-object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\value-objects\\user-email.value-object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\value-objects\\user-id.value-object.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":41,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":41,"endColumn":45},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":41,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":41,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":42,"column":23,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":42,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":42,"column":23,"nodeType":"Identifier","messageId":"unsafeCall","endLine":42,"endColumn":33}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ValueObject } from '../../../../shared/domain/value-object.base';\nimport { ValidationException } from '../../../../shared/exceptions/domain.exception';\n\n/**\n * UserId Value Object\n * Ensures user ID validity and type safety\n */\nexport class UserId extends ValueObject<string> {\n  constructor(value: string) {\n    super(value);\n  }\n\n  protected validateInvariants(value: string): void {\n    if (!value || value.trim().length === 0) {\n      throw new ValidationException('User ID cannot be empty');\n    }\n\n    if (value.length > 36) {\n      throw new ValidationException('User ID cannot exceed 36 characters');\n    }\n\n    // UUID format validation (optional - depends on your ID strategy)\n    const uuidRegex =\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(value)) {\n      throw new ValidationException('User ID must be a valid UUID format');\n    }\n  }\n\n  /**\n   * Factory method to create UserId from string\n   */\n  static create(value: string): UserId {\n    return new UserId(value);\n  }\n\n  /**\n   * Generate new random UserId\n   */\n  static generate(): UserId {\n    const { randomUUID } = require('crypto');\n    return new UserId(randomUUID());\n  }\n\n  protected isEqual(other: ValueObject<string>): boolean {\n    return this.getValue() === other.getValue();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\domain\\value-objects\\username.value-object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\infrastructure\\user.prisma.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":21,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":21,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":25,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":25,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":26,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":26,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":308,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":308,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":308,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":308,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":309,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":309,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .username on an `any` value.","line":309,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":309,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":310,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":310,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .email on an `any` value.","line":310,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":310,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":311,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":311,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .passwordHash on an `any` value.","line":311,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":311,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":312,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":312,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .googleId on an `any` value.","line":312,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":312,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":313,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":313,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .role on an `any` value.","line":313,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":313,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":314,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":314,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":314,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":314,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":315,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":315,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isEmailVerified on an `any` value.","line":315,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":315,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":316,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":316,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .emailVerifiedAt on an `any` value.","line":316,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":316,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":317,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":317,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":317,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":318,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":318,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updatedAt on an `any` value.","line":318,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":318,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":319,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":319,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lastProfileUpdate on an `any` value.","line":319,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":321,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":321,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fullName on an `any` value.","line":321,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":322,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":322,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bio on an `any` value.","line":322,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":322,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":323,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":323,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .avatar on an `any` value.","line":323,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":323,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":324,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":324,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .location on an `any` value.","line":324,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":324,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":325,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":325,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .websiteUrl on an `any` value.","line":325,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":325,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":326,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":326,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dateOfBirth on an `any` value.","line":326,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":326,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":327,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":327,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .phoneNumber on an `any` value.","line":327,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":327,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":328,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":328,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .gender on an `any` value.","line":328,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":328,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":330,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":330,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":330,"column":21,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":330,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .following on an `any` value.","line":330,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":330,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":330,"column":57,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":330,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followingId on an `any` value.","line":330,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":330,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":331,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":331,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":331,"column":20,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":331,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followers on an `any` value.","line":331,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":331,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":331,"column":56,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":331,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .followerId on an `any` value.","line":331,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":331,"endColumn":68}],"suppressedMessages":[],"errorCount":53,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../database/prisma.service';\nimport {\n  IUserRepository,\n  User,\n  UserFactory,\n  UserId,\n  UserEmail,\n  Username,\n} from '../domain';\n\n/**\n * Prisma implementation of UserRepository\n * Updated to work with new schema structure\n */\n@Injectable()\nexport class UserPrismaRepository implements IUserRepository {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async save(user: User): Promise<void> {\n    const userData = this.mapToDataModel(user);\n\n    await this.prisma.user.upsert({\n      where: { id: user.id },\n      update: userData,\n      create: userData,\n    });\n  }\n\n  async findById(id: UserId): Promise<User | null> {\n    const userData = await this.prisma.user.findUnique({\n      where: { id: id.getValue() },\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    if (!userData) {\n      return null;\n    }\n\n    return this.mapToDomainModel(userData);\n  }\n\n  async findByEmail(email: UserEmail): Promise<User | null> {\n    const userData = await this.prisma.user.findUnique({\n      where: { email: email.getValue() },\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    if (!userData) {\n      return null;\n    }\n\n    return this.mapToDomainModel(userData);\n  }\n\n  async findByUsername(username: Username): Promise<User | null> {\n    const userData = await this.prisma.user.findUnique({\n      where: { username: username.getValue() }, // Updated to use 'userName'\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    if (!userData) {\n      return null;\n    }\n\n    return this.mapToDomainModel(userData);\n  }\n\n  async findByGoogleId(googleId: string): Promise<User | null> {\n    const userData = await this.prisma.user.findUnique({\n      where: { googleId },\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    if (!userData) {\n      return null;\n    }\n\n    return this.mapToDomainModel(userData);\n  }\n\n  async existsByEmail(email: UserEmail): Promise<boolean> {\n    const count = await this.prisma.user.count({\n      where: { email: email.getValue() },\n    });\n    return count > 0;\n  }\n\n  async existsByUsername(username: Username): Promise<boolean> {\n    const count = await this.prisma.user.count({\n      where: { username: username.getValue() }, // Updated to use 'username'\n    });\n    return count > 0;\n  }\n\n  async deleteById(id: UserId): Promise<void> {\n    await this.prisma.user.delete({\n      where: { id: id.getValue() },\n    });\n  }\n\n  async findByIds(ids: UserId[]): Promise<User[]> {\n    const userIds = ids.map((id) => id.getValue());\n    const usersData = await this.prisma.user.findMany({\n      where: { id: { in: userIds } },\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    return usersData.map((userData) => this.mapToDomainModel(userData));\n  }\n\n  async searchUsers(\n    query: string,\n    limit = 20,\n    offset = 0,\n  ): Promise<{\n    users: User[];\n    total: number;\n  }> {\n    const whereCondition = {\n      OR: [\n        { username: { contains: query, mode: 'insensitive' as const } }, // Updated field name\n        { fullName: { contains: query, mode: 'insensitive' as const } }, // Direct field access\n      ],\n    };\n\n    const [usersData, total] = await Promise.all([\n      this.prisma.user.findMany({\n        where: whereCondition,\n        include: {\n          followers: { select: { followerId: true } },\n          following: { select: { followingId: true } },\n        },\n        skip: offset,\n        take: limit,\n        orderBy: { createdAt: 'desc' },\n      }),\n      this.prisma.user.count({ where: whereCondition }),\n    ]);\n\n    return {\n      users: usersData.map((userData) => this.mapToDomainModel(userData)),\n      total,\n    };\n  }\n\n  async getFollowers(\n    userId: UserId,\n    limit = 20,\n    offset = 0,\n  ): Promise<{\n    users: User[];\n    total: number;\n  }> {\n    const [followData, total] = await Promise.all([\n      this.prisma.follow.findMany({\n        where: { followingId: userId.getValue() },\n        include: {\n          follower: {\n            include: {\n              followers: { select: { followerId: true } },\n              following: { select: { followingId: true } },\n            },\n          },\n        },\n        skip: offset,\n        take: limit,\n        orderBy: { createdAt: 'desc' },\n      }),\n      this.prisma.follow.count({\n        where: { followingId: userId.getValue() },\n      }),\n    ]);\n\n    return {\n      users: followData.map((follow) => this.mapToDomainModel(follow.follower)),\n      total,\n    };\n  }\n\n  async getFollowing(\n    userId: UserId,\n    limit = 20,\n    offset = 0,\n  ): Promise<{\n    users: User[];\n    total: number;\n  }> {\n    const [followData, total] = await Promise.all([\n      this.prisma.follow.findMany({\n        where: { followerId: userId.getValue() },\n        include: {\n          following: {\n            include: {\n              followers: { select: { followerId: true } },\n              following: { select: { followingId: true } },\n            },\n          },\n        },\n        skip: offset,\n        take: limit,\n        orderBy: { createdAt: 'desc' },\n      }),\n      this.prisma.follow.count({\n        where: { followerId: userId.getValue() },\n      }),\n    ]);\n\n    return {\n      users: followData.map((follow) =>\n        this.mapToDomainModel(follow.following),\n      ),\n      total,\n    };\n  }\n\n  async getMutualFollowers(userId1: UserId, userId2: UserId): Promise<User[]> {\n    // Get users who follow both user1 and user2\n    const mutualFollowsData = await this.prisma.user.findMany({\n      where: {\n        following: {\n          some: {\n            followingId: {\n              in: [userId1.getValue(), userId2.getValue()],\n            },\n          },\n        },\n      },\n      include: {\n        followers: { select: { followerId: true } },\n        following: { select: { followingId: true } },\n      },\n    });\n\n    return mutualFollowsData.map((userData) => this.mapToDomainModel(userData));\n  }\n\n  async getUserStats(userId: UserId): Promise<{\n    followersCount: number;\n    followingCount: number;\n    postsCount: number;\n  }> {\n    const [followersCount, followingCount, postsCount] = await Promise.all([\n      this.prisma.follow.count({\n        where: { followingId: userId.getValue() },\n      }),\n      this.prisma.follow.count({\n        where: { followerId: userId.getValue() },\n      }),\n      this.prisma.post.count({\n        where: { authorId: userId.getValue() },\n      }),\n    ]);\n\n    return {\n      followersCount,\n      followingCount,\n      postsCount,\n    };\n  }\n\n  async updateFollowRelationship(\n    followerId: UserId,\n    followeeId: UserId,\n    isFollowing: boolean,\n  ): Promise<void> {\n    if (isFollowing) {\n      await this.prisma.follow.upsert({\n        where: {\n          followerId_followingId: {\n            followerId: followerId.getValue(),\n            followingId: followeeId.getValue(),\n          },\n        },\n        update: {},\n        create: {\n          followerId: followerId.getValue(),\n          followingId: followeeId.getValue(),\n        },\n      });\n    } else {\n      await this.prisma.follow.deleteMany({\n        where: {\n          followerId: followerId.getValue(),\n          followingId: followeeId.getValue(),\n        },\n      });\n    }\n  }\n\n  private mapToDomainModel(userData: any): User {\n    return UserFactory.reconstructUser({\n      id: userData.id,\n      username: userData.username, // Updated field name\n      email: userData.email,\n      passwordHash: userData.passwordHash, // Updated field name\n      googleId: userData.googleId,\n      role: userData.role,\n      status: userData.status, // New field\n      isEmailVerified: userData.isEmailVerified,\n      emailVerifiedAt: userData.emailVerifiedAt,\n      createdAt: userData.createdAt,\n      updatedAt: userData.updatedAt,\n      lastProfileUpdate: userData.lastProfileUpdate, // New field\n      profile: {\n        fullName: userData.fullName,\n        bio: userData.bio,\n        avatar: userData.avatar,\n        location: userData.location,\n        websiteUrl: userData.websiteUrl,\n        dateOfBirth: userData.dateOfBirth,\n        phoneNumber: userData.phoneNumber,\n        gender: userData.gender,\n      },\n      followingIds: userData.following?.map((f: any) => f.followingId) || [],\n      followerIds: userData.followers?.map((f: any) => f.followerId) || [],\n    });\n  }\n\n  private mapToDataModel(user: User): any {\n    return {\n      id: user.id,\n      username: user.username, // Updated field name\n      email: user.email,\n      passwordHash: user.passwordHash, // Need to add getter in User entity\n      googleId: user.googleId,\n      role: user.role,\n      status: user.status, // New field\n      isEmailVerified: user.isEmailVerified,\n      emailVerifiedAt: user.emailVerifiedAt,\n      updatedAt: user.updatedAt,\n      lastProfileUpdate: user.lastProfileUpdate,\n      // Profile fields are now direct on User model\n      fullName: user.profile.fullName,\n      bio: user.profile.bio,\n      avatar: user.profile.avatar,\n      location: user.profile.location,\n      websiteUrl: user.profile.websiteUrl,\n      dateOfBirth: user.profile.dateOfBirth,\n      phoneNumber: user.profile.phoneNumber,\n      gender: user.profile.gender,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\presentation\\users.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CurrentUser' is defined but never used.","line":42,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":21},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'remove' has no 'await' expression.","line":129,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":129,"endColumn":15,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3708,3775],"text":"remove(@Param('id', ParseUUIDPipe) id: string): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":129,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":46}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  Query,\n  UseGuards,\n  ValidationPipe,\n  HttpCode,\n  HttpStatus,\n  ParseUUIDPipe,\n  ParseIntPipe,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse as SwaggerResponse,\n  ApiBearerAuth,\n  ApiParam,\n  ApiQuery,\n} from '@nestjs/swagger';\n\n// Clean Architecture imports\nimport { UserApplicationService } from '../application/user-application.service';\nimport {\n  CreateUserDto,\n  UpdateProfileDto,\n  UserResponseDto,\n  UserListItemDto,\n  SearchUsersDto,\n  GetFollowersDto,\n} from '../application/dto/user.dto';\n\n// Guards and decorators (using correct paths)\nimport { RolesGuard } from '../../../shared/guards/roles.guard';\nimport { SkipGuards } from '../../../shared/decorators/skipGuard.decorator';\nimport { JwtAuthGuard } from '../../../shared/guards/jwt.guard';\nimport { Roles } from '../../../shared/decorators/roles.decorator';\nimport { CurrentUser } from '../../../shared/decorators/currentUser.decorator';\nimport { ROLES } from '../../../shared/constants/roles.constant';\n\n@ApiTags('Users')\n@Controller('users')\n@ApiBearerAuth()\n@UseGuards(JwtAuthGuard, RolesGuard)\nexport class UsersController {\n  constructor(\n    private readonly userApplicationService: UserApplicationService,\n  ) {}\n\n  @Post()\n  @SkipGuards()\n  @HttpCode(HttpStatus.CREATED)\n  @ApiOperation({ summary: 'Create a new user' })\n  @SwaggerResponse({\n    status: 201,\n    description: 'User created successfully',\n  })\n  async create(\n    @Body(ValidationPipe) createUserDto: CreateUserDto,\n  ): Promise<UserResponseDto> {\n    return this.userApplicationService.createUser(createUserDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search users by query' })\n  @ApiQuery({ name: 'q', required: true, type: String })\n  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })\n  @ApiQuery({ name: 'limit', required: false, type: Number, example: 20 })\n  @SwaggerResponse({\n    status: 200,\n    description: 'Search results retrieved successfully',\n  })\n  async searchUsers(\n    @Query('q') query: string,\n    @Query('page', new ParseIntPipe({ optional: true })) page: number = 1,\n    @Query('limit', new ParseIntPipe({ optional: true })) limit: number = 20,\n    // @CurrentUser('id') requesterId?: string, // Uncomment when auth is ready\n  ): Promise<{\n    users: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n    page: number;\n    limit: number;\n  }> {\n    const searchDto: SearchUsersDto = { query, page, limit };\n    return this.userApplicationService.searchUsers(searchDto);\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get user by ID' })\n  @ApiParam({ name: 'id', type: String, description: 'User ID' })\n  @SwaggerResponse({\n    status: 200,\n    description: 'User retrieved successfully',\n  })\n  async findOne(\n    @Param('id', ParseUUIDPipe) id: string,\n  ): Promise<UserResponseDto> {\n    return this.userApplicationService.getUserProfile(id);\n  }\n\n  @Patch(':id')\n  @ApiOperation({ summary: 'Update user profile' })\n  @ApiParam({ name: 'id', type: String, description: 'User ID' })\n  @SwaggerResponse({\n    status: 200,\n    description: 'User updated successfully',\n  })\n  async update(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body(ValidationPipe) updateProfileDto: UpdateProfileDto,\n  ): Promise<UserResponseDto> {\n    return this.userApplicationService.updateProfile(id, updateProfileDto);\n  }\n\n  @Delete(':id')\n  @Roles(ROLES.ADMIN)\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete user (Admin only)' })\n  @ApiParam({ name: 'id', type: String, description: 'User ID' })\n  @SwaggerResponse({\n    status: 204,\n    description: 'User deleted successfully',\n  })\n  async remove(@Param('id', ParseUUIDPipe) id: string): Promise<void> {\n    // This would need to be implemented in UserApplicationService\n    throw new Error(\n      'Delete user functionality not yet implemented in Clean Architecture',\n    );\n  }\n\n  @Post(':userId/follow')\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ summary: 'Follow a user' })\n  @ApiParam({ name: 'userId', type: String, description: 'User ID to follow' })\n  @SwaggerResponse({\n    status: 200,\n    description: 'User followed successfully',\n  })\n  async followUser(\n    @Param('userId', ParseUUIDPipe) userId: string,\n    // @CurrentUser('id') currentUserId: string, // Uncomment when auth is ready\n  ): Promise<{ message: string }> {\n    // For now, we'll use a placeholder until auth is properly integrated\n    const currentUserId = 'placeholder-user-id';\n    await this.userApplicationService.followUser(currentUserId, userId);\n    return { message: 'User followed successfully' };\n  }\n\n  @Delete(':userId/follow')\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ summary: 'Unfollow a user' })\n  @ApiParam({\n    name: 'userId',\n    type: String,\n    description: 'User ID to unfollow',\n  })\n  @SwaggerResponse({\n    status: 200,\n    description: 'User unfollowed successfully',\n  })\n  async unfollowUser(\n    @Param('userId', ParseUUIDPipe) userId: string,\n    // @CurrentUser('id') currentUserId: string, // Uncomment when auth is ready\n  ): Promise<{ message: string }> {\n    // For now, we'll use a placeholder until auth is properly integrated\n    const currentUserId = 'placeholder-user-id';\n    await this.userApplicationService.unfollowUser(currentUserId, userId);\n    return { message: 'User unfollowed successfully' };\n  }\n\n  @Get(':userId/followers')\n  @ApiOperation({ summary: 'Get user followers' })\n  @ApiParam({ name: 'userId', type: String, description: 'User ID' })\n  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })\n  @ApiQuery({ name: 'limit', required: false, type: Number, example: 20 })\n  @SwaggerResponse({\n    status: 200,\n    description: 'Followers retrieved successfully',\n  })\n  async getFollowers(\n    @Param('userId', ParseUUIDPipe) userId: string,\n    @Query('page', new ParseIntPipe({ optional: true })) page: number = 1,\n    @Query('limit', new ParseIntPipe({ optional: true })) limit: number = 20,\n  ): Promise<{\n    followers: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const dto: GetFollowersDto = { page, limit };\n    return this.userApplicationService.getUserFollowers(userId, dto);\n  }\n\n  @Get(':userId/following')\n  @ApiOperation({ summary: 'Get users followed by user' })\n  @ApiParam({ name: 'userId', type: String, description: 'User ID' })\n  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })\n  @ApiQuery({ name: 'limit', required: false, type: Number, example: 20 })\n  @SwaggerResponse({\n    status: 200,\n    description: 'Following list retrieved successfully',\n  })\n  async getFollowing(\n    @Param('userId', ParseUUIDPipe) userId: string,\n    @Query('page', new ParseIntPipe({ optional: true })) page: number = 1,\n    @Query('limit', new ParseIntPipe({ optional: true })) limit: number = 20,\n  ): Promise<{\n    following: UserListItemDto[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const dto: GetFollowersDto = { page, limit };\n    return this.userApplicationService.getUserFollowing(userId, dto);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\users\\users.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\queues\\mail.queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\queues\\notification.queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\application\\repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\cache\\examples\\cached-user.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\common\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\common\\interfaces\\api-response.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\common\\interfaces\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\constants\\roles.constant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\constants\\time-expire.constant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\constants\\urls.constant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\decorators\\currentUser.decorator.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":6,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":6,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":7,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":7,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":7,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":7,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":9,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":9,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [data] on an `any` value.","line":9,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":9,"endColumn":30}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// filepath: c:\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\modules\\auth\\decorators\\current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: string, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    const user = request.user;\n\n    return data ? user?.[data] : user;\n  },\n);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\decorators\\roles.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\decorators\\skipGuard.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\domain\\base-id.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\domain\\domain-event.base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\domain\\entity.base.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"T\" of template literal expression.","line":63,"column":40,"nodeType":"MemberExpression","messageId":"invalidType","endLine":63,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DomainEvent } from './domain-event.base';\n\n/**\n * Base Entity class for all domain entities\n * Provides common functionality for entity lifecycle and domain events\n */\nexport abstract class Entity<T> {\n  protected readonly _id: T;\n  private _domainEvents: DomainEvent[] = [];\n\n  constructor(id: T) {\n    this._id = id;\n  }\n\n  get id(): T {\n    return this._id;\n  }\n\n  get domainEvents(): DomainEvent[] {\n    return this._domainEvents;\n  }\n\n  /**\n   * Add a domain event to be published later\n   */\n  protected addDomainEvent(domainEvent: DomainEvent): void {\n    this._domainEvents.push(domainEvent);\n  }\n\n  /**\n   * Clear all domain events\n   */\n  public clearEvents(): void {\n    this._domainEvents = [];\n  }\n\n  /**\n   * Mark events as committed (called after successful persistence)\n   */\n  public markEventsAsCommitted(): void {\n    this._domainEvents.forEach((event) => event.markAsCommitted());\n  }\n\n  /**\n   * Check if entity is equal to another entity\n   */\n  public equals(object?: Entity<T>): boolean {\n    if (object === null || object === undefined) {\n      return false;\n    }\n\n    if (this === object) {\n      return true;\n    }\n\n    return this._id === object._id;\n  }\n\n  /**\n   * Get string representation of entity\n   */\n  public toString(): string {\n    return `${this.constructor.name}(${this._id})`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\domain\\value-object.base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\events\\event-bus.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\exceptions\\domain.exception.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\exceptions\\error-response.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\exceptions\\error.utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":371,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":371,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":372,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ValidationException,\n  BusinessRuleException,\n  EntityNotFoundException,\n  EntityAlreadyExistsException,\n  UnauthorizedException,\n  ForbiddenException,\n  DatabaseException,\n  ExternalServiceException,\n  FileOperationException,\n  RateLimitException,\n  ConfigurationException,\n} from './domain.exception';\n\n/**\n * Utility class for creating domain exceptions with proper context\n * This provides a fluent interface for exception creation\n */\nexport class ErrorFactory {\n  /**\n   * Create a validation exception\n   */\n  static validation(\n    message: string,\n    errors: Record<string, string[]> = {},\n  ): ValidationException {\n    return new ValidationException(message, errors);\n  }\n\n  /**\n   * Create a business rule exception\n   */\n  static businessRule(message: string, code?: string): BusinessRuleException {\n    return new BusinessRuleException(message, code);\n  }\n\n  /**\n   * Create an entity not found exception\n   */\n  static entityNotFound(\n    entityName: string,\n    identifier: string | number,\n  ): EntityNotFoundException {\n    return new EntityNotFoundException(entityName, identifier);\n  }\n\n  /**\n   * Create an entity already exists exception\n   */\n  static entityAlreadyExists(\n    entityName: string,\n    identifier: string | number,\n  ): EntityAlreadyExistsException {\n    return new EntityAlreadyExistsException(entityName, identifier);\n  }\n\n  /**\n   * Create an unauthorized exception\n   */\n  static unauthorized(message?: string, code?: string): UnauthorizedException {\n    return new UnauthorizedException(message, code);\n  }\n\n  /**\n   * Create a forbidden exception\n   */\n  static forbidden(message?: string, code?: string): ForbiddenException {\n    return new ForbiddenException(message, code);\n  }\n\n  /**\n   * Create a database exception\n   */\n  static database(\n    operation: string,\n    message: string,\n    table?: string,\n    code?: string,\n  ): DatabaseException {\n    return new DatabaseException(operation, message, table, code);\n  }\n\n  /**\n   * Create an external service exception\n   */\n  static externalService(\n    service: string,\n    message: string,\n    operation?: string,\n    code?: string,\n  ): ExternalServiceException {\n    return new ExternalServiceException(service, message, operation, code);\n  }\n\n  /**\n   * Create a file operation exception\n   */\n  static fileOperation(\n    operation: string,\n    message: string,\n    fileName?: string,\n    fileSize?: number,\n    code?: string,\n  ): FileOperationException {\n    return new FileOperationException(\n      operation,\n      message,\n      fileName,\n      fileSize,\n      code,\n    );\n  }\n\n  /**\n   * Create a rate limit exception\n   */\n  static rateLimit(\n    limit: number,\n    windowMs: number,\n    resetTime?: Date,\n    message?: string,\n    code?: string,\n  ): RateLimitException {\n    return new RateLimitException(limit, windowMs, resetTime, message, code);\n  }\n\n  /**\n   * Create a configuration exception\n   */\n  static configuration(\n    configKey: string,\n    message: string,\n    code?: string,\n  ): ConfigurationException {\n    return new ConfigurationException(configKey, message, code);\n  }\n}\n\n/**\n * Utility class for common error scenarios in domain services\n */\nexport class DomainErrors {\n  /**\n   * User not found error\n   */\n  static userNotFound(userId: string): EntityNotFoundException {\n    return ErrorFactory.entityNotFound('User', userId);\n  }\n\n  /**\n   * Post not found error\n   */\n  static postNotFound(postId: string): EntityNotFoundException {\n    return ErrorFactory.entityNotFound('Post', postId);\n  }\n\n  /**\n   * Comment not found error\n   */\n  static commentNotFound(commentId: string): EntityNotFoundException {\n    return ErrorFactory.entityNotFound('Comment', commentId);\n  }\n\n  /**\n   * User already exists error\n   */\n  static userAlreadyExists(email: string): EntityAlreadyExistsException {\n    return ErrorFactory.entityAlreadyExists('User', email);\n  }\n\n  /**\n   * Invalid credentials error\n   */\n  static invalidCredentials(): UnauthorizedException {\n    return ErrorFactory.unauthorized(\n      'Invalid credentials',\n      'INVALID_CREDENTIALS',\n    );\n  }\n\n  /**\n   * Access token expired error\n   */\n  static accessTokenExpired(): UnauthorizedException {\n    return ErrorFactory.unauthorized(\n      'Access token has expired',\n      'ACCESS_TOKEN_EXPIRED',\n    );\n  }\n\n  /**\n   * Insufficient permissions error\n   */\n  static insufficientPermissions(action: string): ForbiddenException {\n    return ErrorFactory.forbidden(\n      `You don't have permission to ${action}`,\n      'INSUFFICIENT_PERMISSIONS',\n    );\n  }\n\n  /**\n   * Invalid file type error\n   */\n  static invalidFileType(allowedTypes: string[]): FileOperationException {\n    return ErrorFactory.fileOperation(\n      'upload',\n      `Invalid file type. Allowed types: ${allowedTypes.join(', ')}`,\n      undefined,\n      undefined,\n      'INVALID_FILE_TYPE',\n    );\n  }\n\n  /**\n   * File too large error\n   */\n  static fileTooLarge(\n    maxSize: number,\n    actualSize: number,\n    fileName?: string,\n  ): FileOperationException {\n    return ErrorFactory.fileOperation(\n      'upload',\n      `File is too large. Maximum size: ${maxSize} bytes, actual size: ${actualSize} bytes`,\n      fileName,\n      actualSize,\n      'FILE_TOO_LARGE',\n    );\n  }\n\n  /**\n   * External service unavailable error\n   */\n  static externalServiceUnavailable(\n    serviceName: string,\n  ): ExternalServiceException {\n    return ErrorFactory.externalService(\n      serviceName,\n      `${serviceName} service is currently unavailable`,\n      'connection',\n      'SERVICE_UNAVAILABLE',\n    );\n  }\n\n  /**\n   * Rate limit exceeded error\n   */\n  static rateLimitExceeded(\n    limit: number,\n    windowMs: number,\n  ): RateLimitException {\n    const resetTime = new Date(Date.now() + windowMs);\n    return ErrorFactory.rateLimit(\n      limit,\n      windowMs,\n      resetTime,\n      `Rate limit exceeded. Maximum ${limit} requests per ${windowMs / 1000} seconds`,\n    );\n  }\n\n  /**\n   * Content validation errors\n   */\n  static contentTooLong(field: string, maxLength: number): ValidationException {\n    return ErrorFactory.validation(`${field} is too long`, {\n      [field]: [`Maximum length is ${maxLength} characters`],\n    });\n  }\n\n  static contentEmpty(field: string): ValidationException {\n    return ErrorFactory.validation(`${field} cannot be empty`, {\n      [field]: ['This field is required'],\n    });\n  }\n\n  static invalidFormat(field: string, format: string): ValidationException {\n    return ErrorFactory.validation(`Invalid ${field} format`, {\n      [field]: [`Must be a valid ${format}`],\n    });\n  }\n\n  /**\n   * Business rule violations\n   */\n  static cannotPerformAction(\n    action: string,\n    reason: string,\n  ): BusinessRuleException {\n    return ErrorFactory.businessRule(\n      `Cannot ${action}: ${reason}`,\n      'ACTION_NOT_ALLOWED',\n    );\n  }\n\n  static resourceInUse(\n    resourceType: string,\n    resourceId: string,\n  ): BusinessRuleException {\n    return ErrorFactory.businessRule(\n      `${resourceType} ${resourceId} is currently in use and cannot be modified`,\n      'RESOURCE_IN_USE',\n    );\n  }\n\n  static dependencyNotMet(dependency: string): BusinessRuleException {\n    return ErrorFactory.businessRule(\n      `Required dependency not met: ${dependency}`,\n      'DEPENDENCY_NOT_MET',\n    );\n  }\n}\n\n/**\n * Utility functions for error handling in application services\n */\nexport class ErrorUtils {\n  /**\n   * Assert that a condition is true, throw exception if false\n   */\n  static assert(condition: boolean, exception: Error): void {\n    if (!condition) {\n      throw exception;\n    }\n  }\n\n  /**\n   * Assert that a value is not null or undefined\n   */\n  static assertExists<T>(value: T | null | undefined, exception: Error): T {\n    if (value == null) {\n      throw exception;\n    }\n    return value;\n  }\n\n  /**\n   * Handle async operations with proper error context\n   */\n  static async handleAsync<T>(\n    operation: () => Promise<T>,\n    errorContext: { operation: string; resource?: string },\n  ): Promise<T> {\n    try {\n      return await operation();\n    } catch (error) {\n      if (error instanceof Error) {\n        // Re-throw domain exceptions as-is\n        if (error.name.includes('Exception')) {\n          throw error;\n        }\n\n        // Wrap unknown errors as database exceptions\n        throw ErrorFactory.database(\n          errorContext.operation,\n          `Failed to ${errorContext.operation}${errorContext.resource ? ` ${errorContext.resource}` : ''}: ${error.message}`,\n        );\n      }\n\n      throw ErrorFactory.database(\n        errorContext.operation,\n        `Unknown error during ${errorContext.operation}`,\n      );\n    }\n  }\n\n  /**\n   * Safely parse JSON with error handling\n   */\n  static safeJsonParse<T>(json: string, defaultValue: T): T {\n    try {\n      return JSON.parse(json);\n    } catch (error) {\n      return defaultValue;\n    }\n  }\n\n  /**\n   * Validate array length\n   */\n  static validateArrayLength(\n    array: any[],\n    minLength: number,\n    maxLength: number,\n    fieldName: string,\n  ): void {\n    if (array.length < minLength) {\n      throw ErrorFactory.validation(\n        `${fieldName} must have at least ${minLength} items`,\n        { [fieldName]: [`Minimum ${minLength} items required`] },\n      );\n    }\n\n    if (array.length > maxLength) {\n      throw ErrorFactory.validation(\n        `${fieldName} can have at most ${maxLength} items`,\n        { [fieldName]: [`Maximum ${maxLength} items allowed`] },\n      );\n    }\n  }\n\n  /**\n   * Validate string length\n   */\n  static validateStringLength(\n    value: string,\n    minLength: number,\n    maxLength: number,\n    fieldName: string,\n  ): void {\n    if (value.length < minLength) {\n      throw ErrorFactory.validation(`${fieldName} is too short`, {\n        [fieldName]: [`Minimum length is ${minLength} characters`],\n      });\n    }\n\n    if (value.length > maxLength) {\n      throw ErrorFactory.validation(`${fieldName} is too long`, {\n        [fieldName]: [`Maximum length is ${maxLength} characters`],\n      });\n    }\n  }\n\n  /**\n   * Validate email format\n   */\n  static validateEmail(email: string): void {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      throw DomainErrors.invalidFormat('email', 'email address');\n    }\n  }\n\n  /**\n   * Validate URL format\n   */\n  static validateUrl(url: string, fieldName: string = 'url'): void {\n    try {\n      new URL(url);\n    } catch {\n      throw DomainErrors.invalidFormat(fieldName, 'URL');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\filters\\global-exception.filter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":236,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":239,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":239,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":239,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":439,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":439,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":439,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":439,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":439,"column":61,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":439,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":445,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":445,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":453,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":453,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [field] on an `any` value.","line":457,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":457,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [field] on an `any` value.","line":458,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":458,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":466,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":466,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [header] on an `any` value.","line":470,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":470,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [header] on an `any` value.","line":471,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":471,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":475,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":475,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":549,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":549,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":549,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":549,"endColumn":39}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpException,\n  HttpStatus,\n  Logger,\n  Injectable,\n} from '@nestjs/common';\nimport { ErrorMonitoringService } from '../services/error-monitoring.service';\nimport { Request, Response } from 'express';\nimport { Prisma } from '@prisma/client';\nimport { MulterError } from 'multer';\nimport { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken';\nimport {\n  DomainException,\n  ValidationException,\n  EntityNotFoundException,\n  UnauthorizedException,\n  ForbiddenException,\n  BusinessRuleException,\n  DatabaseException,\n  ExternalServiceException,\n  RateLimitException,\n  ConfigurationException,\n  FileOperationException,\n} from '../exceptions/domain.exception';\nimport {\n  IErrorResponse,\n  IErrorInfo,\n  ErrorSeverity,\n  ErrorCategory,\n  IErrorContext,\n} from '../exceptions/error-response.interface';\n\n@Injectable()\n@Catch()\nexport class GlobalExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(GlobalExceptionFilter.name);\n\n  constructor(\n    private readonly errorMonitoringService: ErrorMonitoringService,\n  ) {}\n\n  catch(exception: unknown, host: ArgumentsHost): void {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n\n    const errorInfo = this.buildErrorInfo(exception, request);\n\n    // Log error based on severity\n    this.logError(errorInfo);\n\n    // Send response\n    response.status(errorInfo.response.statusCode).json(errorInfo.response);\n  }\n\n  private buildErrorInfo(exception: unknown, request: Request): IErrorInfo {\n    const context = this.extractContext(request);\n    const requestId = this.generateRequestId();\n\n    let errorResponse: IErrorResponse;\n    let severity: ErrorSeverity;\n    let category: ErrorCategory;\n    let shouldReport = true;\n\n    if (exception instanceof DomainException) {\n      ({ errorResponse, severity, category } = this.handleDomainException(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport =\n        severity === ErrorSeverity.HIGH || severity === ErrorSeverity.CRITICAL;\n    } else if (exception instanceof HttpException) {\n      ({ errorResponse, severity, category } = this.handleHttpException(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport = exception.getStatus() >= 500;\n    } else if (exception instanceof MulterError) {\n      ({ errorResponse, severity, category } = this.handleMulterError(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport = false;\n    } else if (exception instanceof Prisma.PrismaClientKnownRequestError) {\n      ({ errorResponse, severity, category } = this.handlePrismaError(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport = true;\n    } else if (\n      exception instanceof JsonWebTokenError ||\n      exception instanceof TokenExpiredError\n    ) {\n      ({ errorResponse, severity, category } = this.handleJwtError(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport = false;\n    } else {\n      ({ errorResponse, severity, category } = this.handleUnknownError(\n        exception,\n        request,\n        requestId,\n      ));\n      shouldReport = true;\n    }\n\n    return {\n      response: errorResponse,\n      severity,\n      category,\n      context,\n      originalError:\n        exception instanceof Error ? exception : new Error(String(exception)),\n      shouldReport,\n    };\n  }\n\n  private handleDomainException(\n    exception: DomainException,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    let category: ErrorCategory;\n    let severity: ErrorSeverity;\n\n    // Determine category and severity based on exception type\n    if (exception instanceof ValidationException) {\n      category = ErrorCategory.VALIDATION;\n      severity = ErrorSeverity.LOW;\n    } else if (exception instanceof EntityNotFoundException) {\n      category = ErrorCategory.BUSINESS_LOGIC;\n      severity = ErrorSeverity.LOW;\n    } else if (exception instanceof UnauthorizedException) {\n      category = ErrorCategory.AUTHENTICATION;\n      severity = ErrorSeverity.MEDIUM;\n    } else if (exception instanceof ForbiddenException) {\n      category = ErrorCategory.AUTHORIZATION;\n      severity = ErrorSeverity.MEDIUM;\n    } else if (exception instanceof BusinessRuleException) {\n      category = ErrorCategory.BUSINESS_LOGIC;\n      severity = ErrorSeverity.MEDIUM;\n    } else if (exception instanceof DatabaseException) {\n      category = ErrorCategory.DATABASE;\n      severity = ErrorSeverity.HIGH;\n    } else if (exception instanceof ExternalServiceException) {\n      category = ErrorCategory.EXTERNAL_SERVICE;\n      severity = ErrorSeverity.HIGH;\n    } else if (exception instanceof RateLimitException) {\n      category = ErrorCategory.RATE_LIMIT;\n      severity = ErrorSeverity.LOW;\n    } else if (exception instanceof ConfigurationException) {\n      category = ErrorCategory.CONFIGURATION;\n      severity = ErrorSeverity.CRITICAL;\n    } else if (exception instanceof FileOperationException) {\n      category = ErrorCategory.FILE_OPERATION;\n      severity = ErrorSeverity.MEDIUM;\n    } else {\n      category = ErrorCategory.BUSINESS_LOGIC;\n      severity = ErrorSeverity.MEDIUM;\n    }\n\n    const errorResponse: IErrorResponse = {\n      statusCode: exception.statusCode,\n      message: exception.message,\n      code: exception.code,\n      error: exception.constructor.name,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    // Add validation errors if present\n    if (\n      exception instanceof ValidationException &&\n      exception.validationErrors\n    ) {\n      errorResponse.validationErrors = exception.validationErrors;\n    }\n\n    // Add debug info in development\n    if (process.env.NODE_ENV === 'development') {\n      errorResponse.details = exception.getDetails();\n      errorResponse.stack = exception.stack;\n    }\n\n    return { errorResponse, severity, category };\n  }\n\n  private handleHttpException(\n    exception: HttpException,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    const status = exception.getStatus();\n    const response = exception.getResponse();\n\n    let category: ErrorCategory;\n    let severity: ErrorSeverity;\n\n    if (status >= 500) {\n      category = ErrorCategory.SYSTEM;\n      severity = ErrorSeverity.HIGH;\n    } else if (status === 401) {\n      category = ErrorCategory.AUTHENTICATION;\n      severity = ErrorSeverity.MEDIUM;\n    } else if (status === 403) {\n      category = ErrorCategory.AUTHORIZATION;\n      severity = ErrorSeverity.MEDIUM;\n    } else if (status === 429) {\n      category = ErrorCategory.RATE_LIMIT;\n      severity = ErrorSeverity.LOW;\n    } else {\n      category = ErrorCategory.VALIDATION;\n      severity = ErrorSeverity.LOW;\n    }\n\n    const errorResponse: IErrorResponse = {\n      statusCode: status,\n      message:\n        typeof response === 'string'\n          ? response\n          : (response as any)?.message || exception.message,\n      code: this.getHttpErrorCode(status),\n      error: exception.constructor.name,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      errorResponse.stack = exception.stack;\n    }\n\n    return { errorResponse, severity, category };\n  }\n\n  private handleMulterError(\n    exception: MulterError,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    let message: string;\n    let statusCode: number;\n\n    switch (exception.code) {\n      case 'LIMIT_FILE_SIZE':\n        message = 'File too large. Max allowed size is 50 MB.';\n        statusCode = HttpStatus.PAYLOAD_TOO_LARGE;\n        break;\n      case 'LIMIT_UNEXPECTED_FILE':\n        message = 'Unexpected file field.';\n        statusCode = HttpStatus.BAD_REQUEST;\n        break;\n      case 'LIMIT_FILE_COUNT':\n        message = 'Too many files uploaded.';\n        statusCode = HttpStatus.BAD_REQUEST;\n        break;\n      default:\n        message = exception.message || 'File upload error';\n        statusCode = HttpStatus.BAD_REQUEST;\n    }\n\n    const errorResponse: IErrorResponse = {\n      statusCode,\n      message,\n      code: `MULTER_${exception.code}`,\n      error: 'MulterError',\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    return {\n      errorResponse,\n      severity: ErrorSeverity.LOW,\n      category: ErrorCategory.FILE_OPERATION,\n    };\n  }\n\n  private handlePrismaError(\n    exception: Prisma.PrismaClientKnownRequestError,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    let message: string;\n    let statusCode: number;\n    let code: string;\n\n    switch (exception.code) {\n      case 'P2002':\n        message = 'A record with this value already exists';\n        statusCode = HttpStatus.CONFLICT;\n        code = 'UNIQUE_CONSTRAINT_VIOLATION';\n        break;\n      case 'P2025':\n        message = 'Record not found';\n        statusCode = HttpStatus.NOT_FOUND;\n        code = 'RECORD_NOT_FOUND';\n        break;\n      case 'P2003':\n        message = 'Foreign key constraint failed';\n        statusCode = HttpStatus.BAD_REQUEST;\n        code = 'FOREIGN_KEY_CONSTRAINT';\n        break;\n      case 'P2014':\n        message =\n          'The change you are trying to make would violate the required relation';\n        statusCode = HttpStatus.BAD_REQUEST;\n        code = 'REQUIRED_RELATION_VIOLATION';\n        break;\n      default:\n        message = 'Database operation failed';\n        statusCode = HttpStatus.INTERNAL_SERVER_ERROR;\n        code = 'DATABASE_ERROR';\n    }\n\n    const errorResponse: IErrorResponse = {\n      statusCode,\n      message,\n      code,\n      error: 'DatabaseError',\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      errorResponse.details = {\n        prismaCode: exception.code,\n        prismaMessage: exception.message,\n      };\n    }\n\n    return {\n      errorResponse,\n      severity: ErrorSeverity.HIGH,\n      category: ErrorCategory.DATABASE,\n    };\n  }\n\n  private handleJwtError(\n    exception: JsonWebTokenError | TokenExpiredError,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    let message: string;\n    let code: string;\n\n    if (exception instanceof TokenExpiredError) {\n      message = 'Token has expired';\n      code = 'TOKEN_EXPIRED';\n    } else {\n      message = 'Invalid token';\n      code = 'INVALID_TOKEN';\n    }\n\n    const errorResponse: IErrorResponse = {\n      statusCode: HttpStatus.UNAUTHORIZED,\n      message,\n      code,\n      error: 'AuthenticationError',\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    return {\n      errorResponse,\n      severity: ErrorSeverity.MEDIUM,\n      category: ErrorCategory.AUTHENTICATION,\n    };\n  }\n\n  private handleUnknownError(\n    exception: unknown,\n    request: Request,\n    requestId: string,\n  ): {\n    errorResponse: IErrorResponse;\n    severity: ErrorSeverity;\n    category: ErrorCategory;\n  } {\n    const error =\n      exception instanceof Error ? exception : new Error(String(exception));\n\n    const errorResponse: IErrorResponse = {\n      statusCode: HttpStatus.INTERNAL_SERVER_ERROR,\n      message: 'An unexpected error occurred',\n      code: 'INTERNAL_SERVER_ERROR',\n      error: 'InternalServerError',\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      requestId,\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      errorResponse.message = error.message;\n      errorResponse.stack = error.stack;\n    }\n\n    return {\n      errorResponse,\n      severity: ErrorSeverity.CRITICAL,\n      category: ErrorCategory.SYSTEM,\n    };\n  }\n\n  private extractContext(request: Request): IErrorContext {\n    return {\n      userId: (request as any).user?.id || (request as any).user?.sub,\n      ipAddress: request.ip || request.connection.remoteAddress,\n      userAgent: request.get('user-agent'),\n      method: request.method,\n      url: request.url,\n      // Don't log sensitive data like passwords\n      requestBody: this.sanitizeRequestBody(request.body),\n      headers: this.sanitizeHeaders(request.headers),\n    };\n  }\n\n  private sanitizeRequestBody(body: any): any {\n    if (!body) return undefined;\n\n    const sanitized = { ...body };\n    const sensitiveFields = ['password', 'token', 'secret', 'key', 'auth'];\n\n    for (const field of sensitiveFields) {\n      if (sanitized[field]) {\n        sanitized[field] = '[REDACTED]';\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeHeaders(headers: any): Record<string, string> {\n    const sanitized = { ...headers };\n    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'];\n\n    for (const header of sensitiveHeaders) {\n      if (sanitized[header]) {\n        sanitized[header] = '[REDACTED]';\n      }\n    }\n\n    return sanitized;\n  }\n\n  private getHttpErrorCode(status: number): string {\n    const codes: Record<number, string> = {\n      400: 'BAD_REQUEST',\n      401: 'UNAUTHORIZED',\n      403: 'FORBIDDEN',\n      404: 'NOT_FOUND',\n      409: 'CONFLICT',\n      422: 'UNPROCESSABLE_ENTITY',\n      429: 'TOO_MANY_REQUESTS',\n      500: 'INTERNAL_SERVER_ERROR',\n      502: 'BAD_GATEWAY',\n      503: 'SERVICE_UNAVAILABLE',\n    };\n\n    return codes[status] || 'UNKNOWN_ERROR';\n  }\n\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private logError(errorInfo: IErrorInfo): void {\n    const { response, severity, category, context, originalError } = errorInfo;\n\n    const logMessage = `[${category.toUpperCase()}] ${response.message}`;\n    const logContext = {\n      requestId: response.requestId,\n      statusCode: response.statusCode,\n      code: response.code,\n      path: response.path,\n      userId: context.userId,\n      ip: context.ipAddress,\n      userAgent: context.userAgent,\n      method: context.method,\n    };\n\n    switch (severity) {\n      case ErrorSeverity.LOW:\n        this.logger.warn(logMessage, logContext);\n        break;\n      case ErrorSeverity.MEDIUM:\n        this.logger.error(logMessage, logContext);\n        break;\n      case ErrorSeverity.HIGH:\n      case ErrorSeverity.CRITICAL:\n        this.logger.error(logMessage, {\n          ...logContext,\n          stack: originalError?.stack,\n          originalError: originalError?.message,\n        });\n        break;\n    }\n\n    // Send to monitoring service for reportable errors\n    if (errorInfo.shouldReport) {\n      // Fire and forget - don't wait for monitoring to complete\n      this.reportToMonitoringService(errorInfo).catch(() => {\n        // Error already logged in reportToMonitoringService\n      });\n    }\n  }\n\n  private async reportToMonitoringService(\n    errorInfo: IErrorInfo,\n  ): Promise<void> {\n    try {\n      await this.errorMonitoringService.reportError(errorInfo);\n    } catch (error) {\n      // Don't let monitoring errors affect the main response\n      this.logger.error('Failed to report error to monitoring service', {\n        requestId: errorInfo.response.requestId,\n        monitoringError: error.message,\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\filters\\multer-exception.filter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":13,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":13,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":14,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":14,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is assigned a value but never used.","line":14,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":17,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":17,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":18,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":18,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":18,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":18,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":22,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":26,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":22,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":22,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":22,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":22,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":22,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":22,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .json on an `any` value.","line":22,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":22,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":31,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":35,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":31,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":31,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":31,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":31,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":31,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .json on an `any` value.","line":31,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":39,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":39,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":39,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":39,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":40,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":44,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":40,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":40,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":40,"column":14,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":40,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":40,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .json on an `any` value.","line":40,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":42,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":42,"endColumn":33}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpStatus,\n} from '@nestjs/common';\nimport { MulterError } from 'multer';\n\n@Catch()\nexport class MulterExceptionFilter implements ExceptionFilter {\n  catch(exception: any, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n\n    // Detect Multer errors thrown by the multer middleware\n    if (exception instanceof MulterError || exception?.name === 'MulterError') {\n      const code = exception.code;\n      // Customize messages per Multer error code\n      if (code === 'LIMIT_FILE_SIZE') {\n        const message = 'File too large. Max allowed size is 50 MB.';\n        return response.status(HttpStatus.PAYLOAD_TOO_LARGE).json({\n          statusCode: HttpStatus.PAYLOAD_TOO_LARGE,\n          message,\n          error: 'PayloadTooLarge',\n        });\n      }\n\n      if (code === 'LIMIT_UNEXPECTED_FILE') {\n        const message = 'Unexpected file field.';\n        return response.status(HttpStatus.BAD_REQUEST).json({\n          statusCode: HttpStatus.BAD_REQUEST,\n          message,\n          error: 'BadRequest',\n        });\n      }\n\n      // Generic multer error fallback\n      const fallbackMessage = exception.message || 'File upload error';\n      return response.status(HttpStatus.BAD_REQUEST).json({\n        statusCode: HttpStatus.BAD_REQUEST,\n        message: fallbackMessage,\n        error: 'BadRequest',\n      });\n    }\n\n    // Not a Multer error — rethrow to let other filters/handlers deal with it\n    throw exception;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\guards\\google.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\guards\\jwt.guard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'JWT' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":27,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":27,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":28,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":28,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":28,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":28,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":29,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":33,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":29,"column":24,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":33,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .headers on an `any` value.","line":30,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":30,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .query on an `any` value.","line":31,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":33,"column":7,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":33,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":34,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":34,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toLowerCase on an `any` value.","line":34,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":37,"column":35,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":37,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .startsWith on an `any` value.","line":37,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":37,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":38,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":38,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .cookies on an `any` value.","line":38,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":38,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":44,"column":43,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":44,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .startsWith on an `any` value.","line":44,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'info' is defined but never used.","line":54,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":58,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":58,"endColumn":17}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  ExecutionContext,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { AuthGuard } from '@nestjs/passport';\nimport { JWT } from 'src/config/jwt.config';\nimport { SKIP_GUARDS_KEY } from 'src/shared/decorators/skipGuard.decorator';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const skipGuards = this.reflector.getAllAndOverride<boolean>(\n      SKIP_GUARDS_KEY,\n      [context.getHandler(), context.getClass()],\n    );\n\n    if (skipGuards) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const authHeader = request.headers.authorization;\n    const clientType = (\n      request.headers['x-client-type'] ||\n      request.query.client ||\n      ''\n    ).toString();\n    const isWeb = clientType.toLowerCase() === 'web';\n\n    // For web clients, check for token in cookie if no Authorization header\n    if (isWeb && (!authHeader || !authHeader.startsWith('Bearer '))) {\n      const accessTokenCookie = request.cookies?.['access_token'];\n      if (!accessTokenCookie) {\n        throw new UnauthorizedException(\n          'Access token not found in cookies or Authorization header',\n        );\n      }\n    } else if (!isWeb && (!authHeader || !authHeader.startsWith('Bearer '))) {\n      // For non-web clients, require Authorization header\n      throw new UnauthorizedException(\n        'Authorization header missing or invalid',\n      );\n    }\n\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any) {\n    if (err || !user) {\n      throw err || new UnauthorizedException('JWT validation failed');\n    }\n    return user;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\guards\\roles.guard.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":21,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":21,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":23,"column":41,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":23,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .role on an `any` value.","line":23,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":23,"endColumn":50}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\nimport { ROLES_KEY } from '../decorators/roles.decorator';\nimport { ROLES } from '../constants/roles.constant';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<ROLES[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredRoles) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n\n    return requiredRoles.some((role) => user.role?.includes(role));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\cookie-parser.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":85,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":85,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setHeader on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":85,"column":12,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":85,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":86,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":86,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":119,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":119,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":119,"column":31,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":119,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getHeaders on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":119,"column":36,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":119,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access ['set-cookie'] on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":119,"column":49,"nodeType":"Literal","messageId":"unsafeThisMemberExpression","endLine":119,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":125,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":125,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setHeader on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":125,"column":12,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":125,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":126,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":126,"endColumn":19},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":133,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":160,"endColumn":4}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n\n@Injectable()\nexport class CookieParserMiddleware implements NestMiddleware {\n  use(req: Request, res: Response, next: NextFunction) {\n    // Parse cookies from Cookie header\n    req.cookies = this.parseCookies(req.headers.cookie);\n\n    // Add helper methods to response for setting secure cookies\n    this.addCookieHelpers(res);\n\n    next();\n  }\n\n  private parseCookies(cookieHeader?: string): { [key: string]: string } {\n    const cookies: { [key: string]: string } = {};\n\n    if (!cookieHeader) {\n      return cookies;\n    }\n\n    cookieHeader.split(';').forEach((cookie) => {\n      const [name, ...rest] = cookie.split('=');\n      const value = rest.join('=');\n\n      if (name && value) {\n        cookies[name.trim()] = decodeURIComponent(value.trim());\n      }\n    });\n\n    return cookies;\n  }\n\n  private addCookieHelpers(res: Response) {\n    // Helper to set secure auth cookies\n    res.setAuthCookie = function (\n      name: string,\n      value: string,\n      options: {\n        maxAge?: number;\n        httpOnly?: boolean;\n        secure?: boolean;\n        sameSite?: 'strict' | 'lax' | 'none';\n        domain?: string;\n        path?: string;\n      } = {},\n    ) {\n      const isProd = process.env.NODE_ENV === 'production';\n\n      const defaultOptions = {\n        httpOnly: true,\n        secure: isProd,\n        sameSite: isProd ? ('none' as const) : ('lax' as const),\n        path: '/',\n        ...options,\n      };\n\n      let cookieString = `${name}=${encodeURIComponent(value)}`;\n\n      if (defaultOptions.maxAge) {\n        cookieString += `; Max-Age=${Math.floor(defaultOptions.maxAge / 1000)}`;\n      }\n\n      if (defaultOptions.domain) {\n        cookieString += `; Domain=${defaultOptions.domain}`;\n      }\n\n      if (defaultOptions.path) {\n        cookieString += `; Path=${defaultOptions.path}`;\n      }\n\n      if (defaultOptions.httpOnly) {\n        cookieString += '; HttpOnly';\n      }\n\n      if (defaultOptions.secure) {\n        cookieString += '; Secure';\n      }\n\n      if (defaultOptions.sameSite) {\n        cookieString += `; SameSite=${defaultOptions.sameSite}`;\n      }\n\n      this.setHeader('Set-Cookie', cookieString);\n      return this;\n    };\n\n    // Helper to clear auth cookies\n    res.clearAuthCookie = function (\n      name: string,\n      options: {\n        domain?: string;\n        path?: string;\n      } = {},\n    ) {\n      const isProd = process.env.NODE_ENV === 'production';\n\n      let cookieString = `${name}=; Max-Age=0`;\n\n      if (options.domain) {\n        cookieString += `; Domain=${options.domain}`;\n      }\n\n      if (options.path) {\n        cookieString += `; Path=${options.path}`;\n      } else {\n        cookieString += '; Path=/';\n      }\n\n      cookieString += '; HttpOnly';\n\n      if (isProd) {\n        cookieString += '; Secure; SameSite=none';\n      } else {\n        cookieString += '; SameSite=lax';\n      }\n\n      const existingCookies = this.getHeaders()['set-cookie'] || [];\n      const cookiesArray = Array.isArray(existingCookies)\n        ? existingCookies\n        : [existingCookies];\n      cookiesArray.push(cookieString);\n\n      this.setHeader('Set-Cookie', cookiesArray);\n      return this;\n    };\n  }\n}\n\n// Extend Express types to include our custom methods\ndeclare global {\n  namespace Express {\n    interface Request {\n      cookies: { [key: string]: string };\n    }\n\n    interface Response {\n      setAuthCookie(\n        name: string,\n        value: string,\n        options?: {\n          maxAge?: number;\n          httpOnly?: boolean;\n          secure?: boolean;\n          sameSite?: 'strict' | 'lax' | 'none';\n          domain?: string;\n          path?: string;\n        },\n      ): Response;\n\n      clearAuthCookie(\n        name: string,\n        options?: {\n          domain?: string;\n          path?: string;\n        },\n      ): Response;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\cors.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\logger.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'contentLength' is assigned a value but never used.","line":14,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":26,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":54,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | ArrayBuffer | SharedArrayBuffer | Buffer<ArrayBufferLike> | ArrayBufferView<ArrayBufferLike>`.","line":30,"column":56,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":30,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":42,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":42,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":42,"column":40,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":42,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":43,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":43,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .logger on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":43,"column":16,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":43,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":44,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":47,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":47,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .logger on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":47,"column":16,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":47,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":50,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":50,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .logger on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":50,"column":14,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":50,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":53,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":53,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":71,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":71,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":71,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":82,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{}`.","line":106,"column":35,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":106,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":107,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":107,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":141,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":141,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [field] on an `any` value.","line":144,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":144,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [field] on an `any` value.","line":145,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":145,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":155,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":155,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":155,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":158,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":19}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n\n@Injectable()\nexport class RequestLoggerMiddleware implements NestMiddleware {\n  private readonly logger = new Logger('HTTP');\n\n  use(req: Request, res: Response, next: NextFunction) {\n    const startTime = Date.now();\n    const { method, originalUrl, ip, headers } = req;\n\n    // Get user agent and other useful info\n    const userAgent = headers['user-agent'] || 'Unknown';\n    const contentLength = headers['content-length'] || '0';\n\n    // Get user ID if authenticated (from JWT payload)\n    const userId = this.extractUserIdFromRequest(req);\n\n    // Log request start\n    this.logger.log(\n      `➤ ${method} ${originalUrl} - IP: ${ip} - User: ${userId || 'Anonymous'} - UA: ${userAgent.substring(0, 50)}...`,\n    );\n\n    // Override end method to log response\n    const originalSend = res.send;\n    res.send = function (data) {\n      const duration = Date.now() - startTime;\n      const statusCode = res.statusCode;\n      const contentLength =\n        res.get('content-length') || Buffer.byteLength(data || '', 'utf8');\n\n      // Determine log level based on status code\n      const logLevel =\n        statusCode >= 400 ? 'error' : statusCode >= 300 ? 'warn' : 'log';\n\n      // Create log message\n      const logMessage = `➤ ${method} ${originalUrl} - ${statusCode} - ${duration}ms - ${contentLength} bytes - User: ${userId || 'Anonymous'}`;\n\n      // Log errors with more detail\n      if (statusCode >= 400) {\n        try {\n          const errorData = JSON.parse(data);\n          this.logger[logLevel](\n            `${logMessage} - Error: ${errorData.message || 'Unknown error'}`,\n          );\n        } catch {\n          this.logger[logLevel](logMessage);\n        }\n      } else {\n        this.logger[logLevel](logMessage);\n      }\n\n      return originalSend.call(this, data);\n    }.bind(res);\n\n    // Handle response errors\n    res.on('error', (error) => {\n      const duration = Date.now() - startTime;\n      this.logger.error(\n        `➤ ${method} ${originalUrl} - ERROR - ${duration}ms - User: ${userId || 'Anonymous'} - ${error.message}`,\n      );\n    });\n\n    next();\n  }\n\n  private extractUserIdFromRequest(req: Request): string | null {\n    try {\n      // Check if user is attached by JWT guard\n      if (req.user && typeof req.user === 'object' && 'id' in req.user) {\n        return (req.user as any).id;\n      }\n\n      // Try to extract from Authorization header (if needed)\n      const authHeader = req.headers.authorization;\n      if (authHeader && authHeader.startsWith('Bearer ')) {\n        // Could decode JWT here if needed, but usually req.user is set by guards\n        return null;\n      }\n\n      return null;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\n// Additional middleware for sensitive operations logging\n@Injectable()\nexport class SecurityLoggerMiddleware implements NestMiddleware {\n  private readonly logger = new Logger('SECURITY');\n\n  use(req: Request, res: Response, next: NextFunction) {\n    const { method, originalUrl, ip, headers } = req;\n    const userAgent = headers['user-agent'] || 'Unknown';\n\n    // Log security-sensitive operations\n    if (this.isSensitiveOperation(originalUrl, method)) {\n      const userId = this.extractUserIdFromRequest(req);\n\n      this.logger.warn(\n        `🔒 SENSITIVE OPERATION: ${method} ${originalUrl} - IP: ${ip} - User: ${userId || 'Anonymous'} - UA: ${userAgent}`,\n      );\n\n      // Log request body for sensitive operations (excluding passwords)\n      if (req.body && Object.keys(req.body).length > 0) {\n        const sanitizedBody = this.sanitizeRequestBody(req.body);\n        this.logger.warn(`🔒 Request Body: ${JSON.stringify(sanitizedBody)}`);\n      }\n    }\n\n    next();\n  }\n\n  private isSensitiveOperation(url: string, method: string): boolean {\n    const sensitivePatterns = [\n      '/auth/login',\n      '/auth/register',\n      '/auth/refresh',\n      '/users/.*/password',\n      '/admin/',\n      '/auth/logout',\n    ];\n\n    return sensitivePatterns.some(\n      (pattern) =>\n        url.includes(pattern) ||\n        (method === 'DELETE' && url.includes('/users/')) ||\n        (method === 'PATCH' && url.includes('/users/')),\n    );\n  }\n\n  private sanitizeRequestBody(body: any): any {\n    const sensitiveFields = [\n      'password',\n      'confirmPassword',\n      'oldPassword',\n      'newPassword',\n      'token',\n    ];\n    const sanitized = { ...body };\n\n    sensitiveFields.forEach((field) => {\n      if (sanitized[field]) {\n        sanitized[field] = '[REDACTED]';\n      }\n    });\n\n    return sanitized;\n  }\n\n  private extractUserIdFromRequest(req: Request): string | null {\n    try {\n      if (req.user && typeof req.user === 'object' && 'id' in req.user) {\n        return (req.user as any).id;\n      }\n      return null;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\rate-limit.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":17,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":17,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .path on an `any` value.","line":17,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":17,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":21,"column":43,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":21,"endColumn":48}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n\ninterface RateLimitStore {\n  [key: string]: {\n    count: number;\n    resetTime: number;\n  };\n}\n\n@Injectable()\nexport class RateLimitMiddleware implements NestMiddleware {\n  private store: RateLimitStore = {};\n\n  use(req: Request, res: Response, next: NextFunction) {\n    const clientIp = this.getClientIp(req);\n    const route = req.route?.path || req.path;\n    const method = req.method;\n\n    // Define rate limits for different endpoints\n    const rateLimits = this.getRateLimits(route, method);\n\n    if (!rateLimits) {\n      return next();\n    }\n\n    const key = `${clientIp}:${route}:${method}`;\n    const now = Date.now();\n    const windowMs = rateLimits.windowMs;\n    const maxRequests = rateLimits.max;\n\n    // Clean up expired entries\n    this.cleanupExpiredEntries(now);\n\n    // Get or create rate limit entry\n    if (!this.store[key]) {\n      this.store[key] = {\n        count: 1,\n        resetTime: now + windowMs,\n      };\n    } else {\n      // Reset if window has expired\n      if (now > this.store[key].resetTime) {\n        this.store[key] = {\n          count: 1,\n          resetTime: now + windowMs,\n        };\n      } else {\n        this.store[key].count++;\n      }\n    }\n\n    const current = this.store[key];\n    const remaining = Math.max(0, maxRequests - current.count);\n    const resetTimeSeconds = Math.ceil((current.resetTime - now) / 1000);\n\n    // Set rate limit headers\n    res.setHeader('X-RateLimit-Limit', maxRequests);\n    res.setHeader('X-RateLimit-Remaining', remaining);\n    res.setHeader('X-RateLimit-Reset', resetTimeSeconds);\n\n    // Check if rate limit exceeded\n    if (current.count > maxRequests) {\n      res.status(429).json({\n        error: 'Too Many Requests',\n        message: `Rate limit exceeded. Try again in ${resetTimeSeconds} seconds.`,\n        retryAfter: resetTimeSeconds,\n      });\n      return;\n    }\n\n    next();\n  }\n\n  private getClientIp(req: Request): string {\n    return (\n      (req.headers['x-forwarded-for'] as string) ||\n      (req.headers['x-real-ip'] as string) ||\n      req.connection.remoteAddress ||\n      req.socket.remoteAddress ||\n      'unknown'\n    )\n      .split(',')[0]\n      .trim();\n  }\n\n  private getRateLimits(\n    route: string,\n    method: string,\n  ): { windowMs: number; max: number } | null {\n    // Authentication endpoints - stricter limits\n    if (route.includes('/auth/login')) {\n      return { windowMs: 15 * 60 * 1000, max: 5 }; // 5 attempts per 15 minutes\n    }\n\n    if (route.includes('/auth/register')) {\n      return { windowMs: 60 * 60 * 1000, max: 3 }; // 3 registrations per hour\n    }\n\n    if (route.includes('/auth/refresh')) {\n      return { windowMs: 60 * 1000, max: 10 }; // 10 refresh per minute\n    }\n\n    // Content creation - moderate limits\n    if (method === 'POST' && route.includes('/posts')) {\n      return { windowMs: 60 * 1000, max: 5 }; // 5 posts per minute\n    }\n\n    if (method === 'POST' && route.includes('/comments')) {\n      return { windowMs: 60 * 1000, max: 10 }; // 10 comments per minute\n    }\n\n    if (method === 'POST' && route.includes('/reactions')) {\n      return { windowMs: 60 * 1000, max: 30 }; // 30 reactions per minute\n    }\n\n    // Follow/Unfollow actions\n    if (route.includes('/follow')) {\n      return { windowMs: 60 * 1000, max: 20 }; // 20 follow actions per minute\n    }\n\n    // File uploads\n    if (route.includes('/cloudinary') || route.includes('/upload')) {\n      return { windowMs: 60 * 1000, max: 10 }; // 10 uploads per minute\n    }\n\n    // General API - lenient limits\n    if (method === 'GET') {\n      return { windowMs: 60 * 1000, max: 100 }; // 100 GET requests per minute\n    }\n\n    if (method === 'POST' || method === 'PUT' || method === 'PATCH') {\n      return { windowMs: 60 * 1000, max: 30 }; // 30 write operations per minute\n    }\n\n    if (method === 'DELETE') {\n      return { windowMs: 60 * 1000, max: 10 }; // 10 delete operations per minute\n    }\n\n    return null; // No rate limiting\n  }\n\n  private cleanupExpiredEntries(now: number) {\n    // Clean up expired entries every 5 minutes\n    if (!this.lastCleanup || now - this.lastCleanup > 5 * 60 * 1000) {\n      Object.keys(this.store).forEach((key) => {\n        if (now > this.store[key].resetTime) {\n          delete this.store[key];\n        }\n      });\n      this.lastCleanup = now;\n    }\n  }\n\n  private lastCleanup = 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\middlewares\\security.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\services\\error-monitoring.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":33,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":33,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":33,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":33,"endColumn":39},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'reportToSentry' has no 'await' expression.","line":81,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":81,"endColumn":31,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2223,2281],"text":"reportToSentry(errorInfo: IErrorInfo): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'reportToDatadog' has no 'await' expression.","line":113,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":113,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3257,3316],"text":"reportToDatadog(errorInfo: IErrorInfo): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'reportToSlack' has no 'await' expression.","line":141,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":141,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4100,4157],"text":"reportToSlack(errorInfo: IErrorInfo): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":144,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":144,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":159,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":159,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .text on an `any` value.","line":159,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":33},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'saveToDatabase' has no 'await' expression.","line":166,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":166,"endColumn":31,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4849,4907],"text":"saveToDatabase(errorInfo: IErrorInfo): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getErrorStats' has no 'await' expression.","line":280,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":280,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7898,8168],"text":"getErrorStats(\n    startDate: Date,\n    endDate: Date,\n  ): {\n    totalErrors: number;\n    errorsByCategory: Record<ErrorCategory, number>;\n    errorsBySeverity: Record<ErrorSeverity, number>;\n    topErrorCodes: Array<{ code: string; count: number }>;\n  }"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'startDate' is defined but never used.","line":281,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'endDate' is defined but never used.","line":282,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":282,"endColumn":12},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'checkSystemHealth' has no 'await' expression.","line":302,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":302,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8534,8705],"text":"checkSystemHealth(): {\n    status: 'healthy' | 'warning' | 'critical';\n    errorRate: number;\n    criticalErrors: number;\n    recommendations: string[];\n  }"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport {\n  IErrorInfo,\n  ErrorSeverity,\n  ErrorCategory,\n} from '../exceptions/error-response.interface';\n\n/**\n * Service for monitoring and reporting errors to external services\n */\n@Injectable()\nexport class ErrorMonitoringService {\n  private readonly logger = new Logger(ErrorMonitoringService.name);\n\n  /**\n   * Report error to monitoring services\n   */\n  async reportError(errorInfo: IErrorInfo): Promise<void> {\n    try {\n      // Log locally first\n      this.logErrorLocally(errorInfo);\n\n      // Report to external services based on configuration\n      await Promise.allSettled([\n        this.reportToSentry(errorInfo),\n        this.reportToDatadog(errorInfo),\n        this.reportToSlack(errorInfo),\n        this.saveToDatabase(errorInfo),\n      ]);\n    } catch (error) {\n      this.logger.error('Failed to report error to monitoring services', {\n        originalError: errorInfo.response.requestId,\n        monitoringError: error.message,\n      });\n    }\n  }\n\n  /**\n   * Log error locally with structured format\n   */\n  private logErrorLocally(errorInfo: IErrorInfo): void {\n    const { response, severity, category, context, originalError } = errorInfo;\n\n    const logData = {\n      requestId: response.requestId,\n      statusCode: response.statusCode,\n      errorCode: response.code,\n      message: response.message,\n      path: response.path,\n      severity,\n      category,\n      timestamp: response.timestamp,\n      userId: context.userId,\n      ipAddress: context.ipAddress,\n      userAgent: context.userAgent,\n      method: context.method,\n      url: context.url,\n      stack: originalError?.stack,\n    };\n\n    switch (severity) {\n      case ErrorSeverity.LOW:\n        this.logger.warn(`[${category}] ${response.message}`, logData);\n        break;\n      case ErrorSeverity.MEDIUM:\n        this.logger.error(`[${category}] ${response.message}`, logData);\n        break;\n      case ErrorSeverity.HIGH:\n      case ErrorSeverity.CRITICAL:\n        this.logger.error(\n          `[CRITICAL][${category}] ${response.message}`,\n          logData,\n        );\n        break;\n    }\n  }\n\n  /**\n   * Report error to Sentry (placeholder implementation)\n   */\n  private async reportToSentry(errorInfo: IErrorInfo): Promise<void> {\n    if (!this.shouldReportToSentry(errorInfo)) return;\n\n    // TODO: Implement Sentry integration\n    // Example:\n    // import * as Sentry from '@sentry/node';\n    //\n    // Sentry.withScope(scope => {\n    //   scope.setTag('errorCategory', errorInfo.category);\n    //   scope.setTag('severity', errorInfo.severity);\n    //   scope.setUser({\n    //     id: errorInfo.context.userId,\n    //     ip_address: errorInfo.context.ipAddress,\n    //   });\n    //   scope.setContext('request', {\n    //     url: errorInfo.context.url,\n    //     method: errorInfo.context.method,\n    //     headers: errorInfo.context.headers,\n    //   });\n    //   Sentry.captureException(errorInfo.originalError);\n    // });\n\n    this.logger.debug('Would report to Sentry', {\n      requestId: errorInfo.response.requestId,\n      category: errorInfo.category,\n      severity: errorInfo.severity,\n    });\n  }\n\n  /**\n   * Report error metrics to Datadog (placeholder implementation)\n   */\n  private async reportToDatadog(errorInfo: IErrorInfo): Promise<void> {\n    if (!this.shouldReportToDatadog(errorInfo)) return;\n\n    // TODO: Implement Datadog integration\n    // Example:\n    // import { StatsD } from 'node-statsd';\n    //\n    // const statsd = new StatsD();\n    // statsd.increment('errors.total', 1, {\n    //   category: errorInfo.category,\n    //   severity: errorInfo.severity,\n    //   status_code: errorInfo.response.statusCode.toString(),\n    // });\n\n    this.logger.debug('Would report to Datadog', {\n      requestId: errorInfo.response.requestId,\n      metric: 'errors.total',\n      tags: {\n        category: errorInfo.category,\n        severity: errorInfo.severity,\n        status_code: errorInfo.response.statusCode,\n      },\n    });\n  }\n\n  /**\n   * Send critical errors to Slack (placeholder implementation)\n   */\n  private async reportToSlack(errorInfo: IErrorInfo): Promise<void> {\n    if (!this.shouldReportToSlack(errorInfo)) return;\n\n    const slackMessage = this.formatSlackMessage(errorInfo);\n\n    // TODO: Implement Slack webhook integration\n    // Example:\n    // const webhookUrl = process.env.SLACK_WEBHOOK_URL;\n    // if (webhookUrl) {\n    //   await fetch(webhookUrl, {\n    //     method: 'POST',\n    //     headers: { 'Content-Type': 'application/json' },\n    //     body: JSON.stringify(slackMessage),\n    //   });\n    // }\n\n    this.logger.debug('Would send to Slack', {\n      requestId: errorInfo.response.requestId,\n      message: slackMessage.text,\n    });\n  }\n\n  /**\n   * Save error to database for analysis (placeholder implementation)\n   */\n  private async saveToDatabase(errorInfo: IErrorInfo): Promise<void> {\n    if (!this.shouldSaveToDatabase(errorInfo)) return;\n\n    // TODO: Implement database logging\n    // This could be useful for:\n    // - Error analytics and trends\n    // - User-specific error patterns\n    // - Performance monitoring\n    // - Audit trails\n\n    this.logger.debug('Would save to database', {\n      requestId: errorInfo.response.requestId,\n      table: 'error_logs',\n    });\n  }\n\n  /**\n   * Determine if error should be reported to Sentry\n   */\n  private shouldReportToSentry(errorInfo: IErrorInfo): boolean {\n    return !!(\n      process.env.SENTRY_DSN &&\n      errorInfo.shouldReport &&\n      (errorInfo.severity === ErrorSeverity.HIGH ||\n        errorInfo.severity === ErrorSeverity.CRITICAL)\n    );\n  }\n\n  /**\n   * Determine if error should be reported to Datadog\n   */\n  private shouldReportToDatadog(errorInfo: IErrorInfo): boolean {\n    return !!(\n      process.env.DATADOG_API_KEY && errorInfo.severity !== ErrorSeverity.LOW\n    );\n  }\n\n  /**\n   * Determine if error should be sent to Slack\n   */\n  private shouldReportToSlack(errorInfo: IErrorInfo): boolean {\n    return !!(\n      process.env.SLACK_WEBHOOK_URL &&\n      errorInfo.severity === ErrorSeverity.CRITICAL &&\n      errorInfo.category !== ErrorCategory.VALIDATION\n    );\n  }\n\n  /**\n   * Determine if error should be saved to database\n   */\n  private shouldSaveToDatabase(errorInfo: IErrorInfo): boolean {\n    return (\n      process.env.ENABLE_ERROR_DB_LOGGING === 'true' &&\n      errorInfo.severity !== ErrorSeverity.LOW\n    );\n  }\n\n  /**\n   * Format error message for Slack\n   */\n  private formatSlackMessage(errorInfo: IErrorInfo): any {\n    const { response, severity, category, context } = errorInfo;\n\n    const color = severity === ErrorSeverity.CRITICAL ? 'danger' : 'warning';\n\n    return {\n      text: `🚨 ${severity.toUpperCase()} Error Alert`,\n      attachments: [\n        {\n          color,\n          title: `${category.toUpperCase()}: ${response.message}`,\n          fields: [\n            {\n              title: 'Request ID',\n              value: response.requestId,\n              short: true,\n            },\n            {\n              title: 'Status Code',\n              value: response.statusCode,\n              short: true,\n            },\n            {\n              title: 'Path',\n              value: response.path,\n              short: true,\n            },\n            {\n              title: 'User ID',\n              value: context.userId || 'Anonymous',\n              short: true,\n            },\n            {\n              title: 'IP Address',\n              value: context.ipAddress,\n              short: true,\n            },\n            {\n              title: 'Timestamp',\n              value: response.timestamp,\n              short: true,\n            },\n          ],\n          footer: 'Error Monitoring System',\n          ts: Math.floor(new Date(response.timestamp).getTime() / 1000),\n        },\n      ],\n    };\n  }\n\n  /**\n   * Get error statistics for dashboard/reporting\n   */\n  async getErrorStats(\n    startDate: Date,\n    endDate: Date,\n  ): Promise<{\n    totalErrors: number;\n    errorsByCategory: Record<ErrorCategory, number>;\n    errorsBySeverity: Record<ErrorSeverity, number>;\n    topErrorCodes: Array<{ code: string; count: number }>;\n  }> {\n    // TODO: Implement actual statistics gathering from database\n    // This is a placeholder implementation\n    return {\n      totalErrors: 0,\n      errorsByCategory: {} as Record<ErrorCategory, number>,\n      errorsBySeverity: {} as Record<ErrorSeverity, number>,\n      topErrorCodes: [],\n    };\n  }\n\n  /**\n   * Check system health based on error rates\n   */\n  async checkSystemHealth(): Promise<{\n    status: 'healthy' | 'warning' | 'critical';\n    errorRate: number;\n    criticalErrors: number;\n    recommendations: string[];\n  }> {\n    // TODO: Implement actual health checking logic\n    // This could analyze error rates, patterns, and provide recommendations\n    return {\n      status: 'healthy',\n      errorRate: 0,\n      criticalErrors: 0,\n      recommendations: [],\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\connection-manager.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\room-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'socketId' is defined but never used.","line":77,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":327,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":327,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":328,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":328,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":347,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":347,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .totalRooms on an `any` value.","line":349,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":349,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .totalParticipants on an `any` value.","line":349,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":349,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":353,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":359,"endColumn":8}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport {\n  WebSocketRoom,\n  WebSocketRoomType,\n  WebSocketNamespace,\n  IRoomManager,\n} from '../interfaces/websocket.interface';\n\n@Injectable()\nexport class RoomManagerService implements IRoomManager {\n  private readonly logger = new Logger(RoomManagerService.name);\n  private rooms = new Map<string, WebSocketRoom>(); // roomId -> WebSocketRoom\n  private userRooms = new Map<string, Set<string>>(); // userId -> Set<roomId>\n  private namespaceRooms = new Map<WebSocketNamespace, Set<string>>(); // namespace -> Set<roomId>\n\n  createRoom(\n    roomData: Omit<WebSocketRoom, 'participants' | 'sockets'>,\n  ): WebSocketRoom {\n    const room: WebSocketRoom = {\n      ...roomData,\n      participants: new Set(),\n      sockets: new Set(),\n    };\n\n    this.rooms.set(room.id, room);\n\n    // Track namespace rooms\n    if (!this.namespaceRooms.has(room.namespace)) {\n      this.namespaceRooms.set(room.namespace, new Set());\n    }\n    this.namespaceRooms.get(room.namespace)!.add(room.id);\n\n    this.logger.debug(`Created room ${room.id} in namespace ${room.namespace}`);\n    return room;\n  }\n\n  getRoom(roomId: string): WebSocketRoom | undefined {\n    return this.rooms.get(roomId);\n  }\n\n  joinRoom(roomId: string, userId: string, socketId: string): boolean {\n    const room = this.rooms.get(roomId);\n    if (!room) {\n      this.logger.warn(`Attempted to join non-existent room: ${roomId}`);\n      return false;\n    }\n\n    // Add participant and socket to room\n    room.participants.add(userId);\n    room.sockets.add(socketId);\n    room.metadata.lastActivity = new Date();\n\n    // Track user rooms\n    if (!this.userRooms.has(userId)) {\n      this.userRooms.set(userId, new Set());\n    }\n    this.userRooms.get(userId)!.add(roomId);\n\n    this.logger.debug(\n      `User ${userId} joined room ${roomId} (socket: ${socketId})`,\n    );\n    return true;\n  }\n\n  leaveRoom(roomId: string, userId: string, socketId: string): boolean {\n    const room = this.rooms.get(roomId);\n    if (!room) {\n      this.logger.warn(`Attempted to leave non-existent room: ${roomId}`);\n      return false;\n    }\n\n    // Remove socket from room\n    room.sockets.delete(socketId);\n    room.metadata.lastActivity = new Date();\n\n    // Check if user has other sockets in the room\n    const userSocketsInRoom = Array.from(room.sockets).filter((socketId) => {\n      // This would need connection manager to check socket ownership\n      // For now, we'll assume the socket belongs to the user\n      return true;\n    });\n\n    // If user has no more sockets in the room, remove them from participants\n    if (userSocketsInRoom.length === 0) {\n      room.participants.delete(userId);\n\n      // Remove room from user's room list\n      const userRooms = this.userRooms.get(userId);\n      if (userRooms) {\n        userRooms.delete(roomId);\n        if (userRooms.size === 0) {\n          this.userRooms.delete(userId);\n        }\n      }\n    }\n\n    this.logger.debug(\n      `User ${userId} left room ${roomId} (socket: ${socketId})`,\n    );\n    return true;\n  }\n\n  deleteRoom(roomId: string): boolean {\n    const room = this.rooms.get(roomId);\n    if (!room) {\n      return false;\n    }\n\n    // Remove room from all participants' room lists\n    for (const userId of room.participants) {\n      const userRooms = this.userRooms.get(userId);\n      if (userRooms) {\n        userRooms.delete(roomId);\n        if (userRooms.size === 0) {\n          this.userRooms.delete(userId);\n        }\n      }\n    }\n\n    // Remove from namespace rooms\n    const namespaceRooms = this.namespaceRooms.get(room.namespace);\n    if (namespaceRooms) {\n      namespaceRooms.delete(roomId);\n    }\n\n    // Remove from rooms map\n    this.rooms.delete(roomId);\n\n    this.logger.debug(`Deleted room ${roomId}`);\n    return true;\n  }\n\n  getRoomsByUser(userId: string): WebSocketRoom[] {\n    const roomIds = this.userRooms.get(userId);\n    if (!roomIds) {\n      return [];\n    }\n\n    return Array.from(roomIds)\n      .map((roomId) => this.rooms.get(roomId))\n      .filter(Boolean) as WebSocketRoom[];\n  }\n\n  getRoomsByNamespace(namespace: WebSocketNamespace): WebSocketRoom[] {\n    const roomIds = this.namespaceRooms.get(namespace);\n    if (!roomIds) {\n      return [];\n    }\n\n    return Array.from(roomIds)\n      .map((roomId) => this.rooms.get(roomId))\n      .filter(Boolean) as WebSocketRoom[];\n  }\n\n  cleanupEmptyRooms(): number {\n    let removedCount = 0;\n\n    for (const [roomId, room] of this.rooms.entries()) {\n      if (room.participants.size === 0 && room.sockets.size === 0) {\n        this.deleteRoom(roomId);\n        removedCount++;\n      }\n    }\n\n    if (removedCount > 0) {\n      this.logger.log(`Cleaned up ${removedCount} empty rooms`);\n    }\n\n    return removedCount;\n  }\n\n  // Utility methods\n  getRoomParticipantCount(roomId: string): number {\n    const room = this.rooms.get(roomId);\n    return room ? room.participants.size : 0;\n  }\n\n  getRoomSocketCount(roomId: string): number {\n    const room = this.rooms.get(roomId);\n    return room ? room.sockets.size : 0;\n  }\n\n  isUserInRoom(roomId: string, userId: string): boolean {\n    const room = this.rooms.get(roomId);\n    return room ? room.participants.has(userId) : false;\n  }\n\n  getRoomsByType(type: WebSocketRoomType): WebSocketRoom[] {\n    return Array.from(this.rooms.values()).filter((room) => room.type === type);\n  }\n\n  // Create predefined room types\n  createUserRoom(userId: string, namespace: WebSocketNamespace): WebSocketRoom {\n    const roomId = `user:${userId}`;\n\n    // Check if room already exists\n    const existingRoom = this.getRoom(roomId);\n    if (existingRoom) {\n      return existingRoom;\n    }\n\n    return this.createRoom({\n      id: roomId,\n      type: WebSocketRoomType.USER,\n      namespace,\n      metadata: {\n        createdAt: new Date(),\n        lastActivity: new Date(),\n        isPrivate: true,\n      },\n    });\n  }\n\n  createConversationRoom(\n    conversationId: string,\n    namespace: WebSocketNamespace,\n  ): WebSocketRoom {\n    const roomId = `conversation:${conversationId}`;\n\n    const existingRoom = this.getRoom(roomId);\n    if (existingRoom) {\n      return existingRoom;\n    }\n\n    return this.createRoom({\n      id: roomId,\n      type: WebSocketRoomType.CONVERSATION,\n      namespace,\n      metadata: {\n        createdAt: new Date(),\n        lastActivity: new Date(),\n        isPrivate: true,\n        totalMessages: 0,\n      },\n    });\n  }\n\n  createPostRoom(postId: string, namespace: WebSocketNamespace): WebSocketRoom {\n    const roomId = `post:${postId}`;\n\n    const existingRoom = this.getRoom(roomId);\n    if (existingRoom) {\n      return existingRoom;\n    }\n\n    return this.createRoom({\n      id: roomId,\n      type: WebSocketRoomType.POST,\n      namespace,\n      metadata: {\n        createdAt: new Date(),\n        lastActivity: new Date(),\n        isPrivate: false,\n      },\n    });\n  }\n\n  createTopicRoom(topic: string, namespace: WebSocketNamespace): WebSocketRoom {\n    const roomId = `topic:${topic}`;\n\n    const existingRoom = this.getRoom(roomId);\n    if (existingRoom) {\n      return existingRoom;\n    }\n\n    return this.createRoom({\n      id: roomId,\n      type: WebSocketRoomType.TOPIC,\n      namespace,\n      metadata: {\n        createdAt: new Date(),\n        lastActivity: new Date(),\n        isPrivate: false,\n      },\n    });\n  }\n\n  createFeedRoom(userId: string, namespace: WebSocketNamespace): WebSocketRoom {\n    const roomId = `feed:${userId}`;\n\n    const existingRoom = this.getRoom(roomId);\n    if (existingRoom) {\n      return existingRoom;\n    }\n\n    return this.createRoom({\n      id: roomId,\n      type: WebSocketRoomType.FEED,\n      namespace,\n      metadata: {\n        createdAt: new Date(),\n        lastActivity: new Date(),\n        isPrivate: true,\n      },\n    });\n  }\n\n  // Bulk operations\n  removeUserFromAllRooms(userId: string): number {\n    const userRooms = this.userRooms.get(userId);\n    if (!userRooms) {\n      return 0;\n    }\n\n    let removedFromCount = 0;\n\n    for (const roomId of userRooms) {\n      const room = this.rooms.get(roomId);\n      if (room) {\n        room.participants.delete(userId);\n        room.metadata.lastActivity = new Date();\n        removedFromCount++;\n      }\n    }\n\n    this.userRooms.delete(userId);\n\n    this.logger.debug(`Removed user ${userId} from ${removedFromCount} rooms`);\n    return removedFromCount;\n  }\n\n  // Statistics and monitoring\n  getRoomStats(): any {\n    const totalRooms = this.rooms.size;\n    const totalParticipants = this.userRooms.size;\n\n    const roomsByType: Record<WebSocketRoomType, number> = {} as any;\n    const roomsByNamespace: Record<WebSocketNamespace, number> = {} as any;\n\n    for (const room of this.rooms.values()) {\n      roomsByType[room.type] = (roomsByType[room.type] || 0) + 1;\n      roomsByNamespace[room.namespace] =\n        (roomsByNamespace[room.namespace] || 0) + 1;\n    }\n\n    return {\n      totalRooms,\n      totalParticipants,\n      roomsByType,\n      roomsByNamespace,\n      lastUpdated: new Date(),\n    };\n  }\n\n  // Health check\n  healthCheck(): { healthy: boolean; details: any } {\n    const stats = this.getRoomStats();\n\n    const healthy = stats.totalRooms >= 0 && stats.totalParticipants >= 0;\n\n    return {\n      healthy,\n      details: {\n        ...stats,\n        roomsWithoutParticipants: Array.from(this.rooms.values()).filter(\n          (room) => room.participants.size === 0,\n        ).length,\n        timestamp: new Date(),\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\websocket-connection.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":32,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":33,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":42,"column":47,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":42,"endColumn":52},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":51,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":56,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1566,1571],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":70,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":72,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2111,2116],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":84,"column":9,"nodeType":"AwaitExpression","messageId":"await","endLine":84,"endColumn":78,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2526,2531],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":98,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":100,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2925,2930],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":131,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":133,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3808,3813],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validateToken' has no 'await' expression.","line":178,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":178,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5181,5239],"text":"validateToken(token: string): string | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'token' is defined but never used.","line":178,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":178,"endColumn":36}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Server, Socket } from 'socket.io';\n\nimport { ConnectionManagerService } from './connection-manager.service';\nimport { RoomManagerService } from './room-manager.service';\nimport { PresenceWebSocketService } from '../services/presence-websocket.service';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n} from '../interfaces/websocket.interface';\n\n@Injectable()\nexport class WebSocketConnectionService {\n  private readonly logger = new Logger(WebSocketConnectionService.name);\n  private server: Server;\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n    private readonly presenceService: PresenceWebSocketService,\n  ) {}\n\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  async handleConnection(client: Socket): Promise<void> {\n    try {\n      this.logger.debug(`Client attempting connection: ${client.id}`);\n\n      // Extract user info from handshake\n      const token =\n        client.handshake.auth?.token || client.handshake.query?.token;\n\n      if (!token) {\n        this.logger.warn(`No token provided for client: ${client.id}`);\n        client.disconnect(true);\n        return;\n      }\n\n      // Validate JWT token and extract user info\n      const userId = await this.validateToken(token);\n\n      if (!userId) {\n        this.logger.warn(`Invalid token for client: ${client.id}`);\n        client.disconnect(true);\n        return;\n      }\n\n      // Store connection\n      const connection = await this.connectionManager.addConnectionAsync(\n        userId,\n        client.id,\n        WebSocketNamespace.SOCIAL,\n        client,\n      );\n\n      if (connection) {\n        await this.setupUserConnection(client, userId);\n        this.logger.log(`User ${userId} connected with socket ${client.id}`);\n      }\n    } catch (error) {\n      this.logger.error(`Connection error for client ${client.id}:`, error);\n      client.disconnect(true);\n    }\n  }\n\n  async handleDisconnect(client: Socket): Promise<void> {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n\n      if (connection) {\n        const userId = connection.userId;\n\n        // Notify presence service about user disconnection\n        await this.presenceService.handleUserDisconnected(userId, client.id);\n\n        // Remove from all rooms\n        this.roomManager.removeUserFromAllRooms(userId);\n\n        // Remove connection\n        await this.connectionManager.removeConnectionAsync(userId, client.id);\n\n        this.logger.log(`User ${userId} disconnected (socket: ${client.id})`);\n      }\n    } catch (error) {\n      this.logger.error(`Disconnect error for client ${client.id}:`, error);\n    }\n  }\n\n  async handleJoinRoom(\n    client: Socket,\n    data: { roomId: string },\n  ): Promise<void> {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) {\n        client.emit('error', { message: 'Connection not found' });\n        return;\n      }\n\n      await client.join(data.roomId);\n      const joined = this.roomManager.joinRoom(\n        data.roomId,\n        connection.userId,\n        client.id,\n      );\n\n      if (joined) {\n        client.emit('room_joined', { roomId: data.roomId });\n        client.to(data.roomId).emit(WebSocketEvent.USER_JOINED_ROOM, {\n          userId: connection.userId,\n          roomId: data.roomId,\n        });\n      }\n    } catch (error) {\n      this.logger.error(`Error joining room:`, error);\n      client.emit('error', { message: 'Failed to join room' });\n    }\n  }\n\n  async handleLeaveRoom(\n    client: Socket,\n    data: { roomId: string },\n  ): Promise<void> {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) {\n        client.emit('error', { message: 'Connection not found' });\n        return;\n      }\n\n      await client.leave(data.roomId);\n      this.roomManager.leaveRoom(data.roomId, connection.userId, client.id);\n\n      client.emit('room_left', { roomId: data.roomId });\n      client.to(data.roomId).emit(WebSocketEvent.USER_LEFT_ROOM, {\n        userId: connection.userId,\n        roomId: data.roomId,\n      });\n    } catch (error) {\n      this.logger.error(`Error leaving room:`, error);\n      client.emit('error', { message: 'Failed to leave room' });\n    }\n  }\n\n  private async setupUserConnection(\n    client: Socket,\n    userId: string,\n  ): Promise<void> {\n    // Join user's personal room\n    const userRoom = this.roomManager.createUserRoom(\n      userId,\n      WebSocketNamespace.SOCIAL,\n    );\n    await client.join(userRoom.id);\n    this.roomManager.joinRoom(userRoom.id, userId, client.id);\n\n    // Emit connection success\n    client.emit(WebSocketEvent.CONNECTION_ESTABLISHED, {\n      userId,\n      socketId: client.id,\n      timestamp: new Date(),\n    });\n\n    // Notify presence service about user connection\n    await this.presenceService.handleUserConnected(userId, client.id, {\n      device: client.handshake.headers['user-agent'],\n    });\n  }\n\n  private async validateToken(token: string): Promise<string | null> {\n    try {\n      // This should use your JWT service to validate the token\n      // For now, returning a mock implementation\n      // You should inject and use your JWT service here\n\n      // Example:\n      // const payload = await this.jwtService.verifyAsync(token);\n      // return payload.sub || payload.userId;\n\n      // Mock implementation - replace with actual JWT validation\n      return 'mock-user-id';\n    } catch (error) {\n      this.logger.error('Token validation error:', error);\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\websocket-emitter.service.ts","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":33,"column":27,"nodeType":"AwaitExpression","messageId":"await","endLine":36,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[881,886],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":47,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":47,"endColumn":13},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'emitToRoom' has no 'await' expression.","line":76,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":76,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1951,2052],"text":"emitToRoom(\n    roomId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":90,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":90,"endColumn":13},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'broadcastToNamespace' has no 'await' expression.","line":107,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":107,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2693,2819],"text":"broadcastToNamespace(\n    namespace: WebSocketNamespace,\n    event: WebSocketEvent,\n    data: any,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":115,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":115,"endColumn":13}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Server } from 'socket.io';\n\nimport { ConnectionManagerService } from './connection-manager.service';\nimport { RoomManagerService } from './room-manager.service';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n  WebSocketEventPayload,\n} from '../interfaces/websocket.interface';\n\n@Injectable()\nexport class WebSocketEmitterService {\n  private readonly logger = new Logger(WebSocketEmitterService.name);\n  private server: Server;\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n  ) {}\n\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  async emitToUser(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n    namespace?: WebSocketNamespace,\n  ): Promise<boolean> {\n    try {\n      const connections = await this.connectionManager.getUserConnectionsAsync(\n        userId,\n        namespace,\n      );\n\n      if (connections.length === 0) {\n        this.logger.debug(\n          `No connections found for user ${userId} in namespace ${namespace}`,\n        );\n        return false;\n      }\n\n      const payload: WebSocketEventPayload = {\n        event,\n        data,\n        metadata: {\n          timestamp: new Date(),\n          eventId: `${Date.now()}-${Math.random()}`,\n          version: '1.0',\n        },\n        namespace: namespace || WebSocketNamespace.SOCIAL,\n      };\n\n      let emitted = false;\n      for (const connection of connections) {\n        try {\n          this.server.to(connection.socketId).emit(event, payload);\n          emitted = true;\n        } catch (error) {\n          this.logger.error(\n            `Failed to emit to socket ${connection.socketId}:`,\n            error,\n          );\n        }\n      }\n\n      return emitted;\n    } catch (error) {\n      this.logger.error(`Error emitting to user ${userId}:`, error);\n      return false;\n    }\n  }\n\n  async emitToRoom(\n    roomId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    try {\n      const room = this.roomManager.getRoom(roomId);\n      if (!room) {\n        this.logger.warn(`Room ${roomId} not found for emission`);\n        return false;\n      }\n\n      const payload: WebSocketEventPayload = {\n        event,\n        data,\n        metadata: {\n          timestamp: new Date(),\n          eventId: `${Date.now()}-${Math.random()}`,\n          version: '1.0',\n        },\n        namespace: room.namespace,\n      };\n\n      this.server.to(roomId).emit(event, payload);\n      return true;\n    } catch (error) {\n      this.logger.error(`Error emitting to room ${roomId}:`, error);\n      return false;\n    }\n  }\n\n  async broadcastToNamespace(\n    namespace: WebSocketNamespace,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    try {\n      const payload: WebSocketEventPayload = {\n        event,\n        data,\n        metadata: {\n          timestamp: new Date(),\n          eventId: `${Date.now()}-${Math.random()}`,\n          version: '1.0',\n        },\n        namespace,\n      };\n\n      this.server.emit(event, payload);\n      return true;\n    } catch (error) {\n      this.logger.error(`Error broadcasting to namespace ${namespace}:`, error);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\websocket-gateway.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ conversationId: string; content: string; messageType: \"file\" | \"image\" | \"text\"; receiverId?: string | undefined; }`.","line":131,"column":60,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":131,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ conversationId: string; isTyping: boolean; }`.","line":139,"column":64,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":139,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ conversationId: string; messageId: string; }`.","line":147,"column":64,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":147,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ postId: string; liked: boolean; }`.","line":164,"column":54,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":164,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ postId: string; content: string; parentCommentId?: string | undefined; }`.","line":172,"column":56,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":172,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ targetUserId: string; follow: boolean; }`.","line":180,"column":56,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":180,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ status: \"online\" | \"offline\" | \"away\" | \"busy\"; }`.","line":189,"column":60,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":189,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ activity: \"viewing_post\" | \"browsing_feed\" | \"in_conversation\" | \"idle\"; targetId?: string | undefined; }`.","line":197,"column":62,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":197,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport {\n  WebSocketGateway,\n  WebSocketServer,\n  SubscribeMessage,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  ConnectedSocket,\n  MessageBody,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\n\nimport { WebSocketConnectionService } from './websocket-connection.service';\nimport { WebSocketEmitterService } from './websocket-emitter.service';\nimport { WebSocketUtilityService } from './websocket-utility.service';\nimport { MessagingWebSocketService } from '../services/messaging-websocket.service';\nimport { SocialWebSocketService } from '../services/social-websocket.service';\nimport { PresenceWebSocketService } from '../services/presence-websocket.service';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n  IWebSocketGatewayService,\n} from '../interfaces/websocket.interface';\n\n@WebSocketGateway({\n  cors: {\n    origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n    credentials: true,\n  },\n  namespace: '/',\n})\n@Injectable()\nexport class WebSocketGatewayService\n  implements IWebSocketGatewayService, OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer()\n  server: Server;\n\n  private readonly logger = new Logger(WebSocketGatewayService.name);\n\n  constructor(\n    private readonly connectionService: WebSocketConnectionService,\n    private readonly emitterService: WebSocketEmitterService,\n    private readonly utilityService: WebSocketUtilityService,\n    private readonly messagingService: MessagingWebSocketService,\n    private readonly socialService: SocialWebSocketService,\n    private readonly presenceService: PresenceWebSocketService,\n  ) {}\n\n  // ============ LIFECYCLE HOOKS ============\n  afterInit(server: Server) {\n    this.server = server;\n    this.initializeServices();\n  }\n\n  private initializeServices(): void {\n    this.connectionService.setServer(this.server);\n    this.emitterService.setServer(this.server);\n    this.utilityService.setServer(this.server);\n    this.messagingService.setServer(this.server);\n    this.socialService.setServer(this.server);\n    this.presenceService.setServer(this.server);\n  }\n\n  // ============ CONNECTION LIFECYCLE (DELEGATE) ============\n  async handleConnection(client: Socket) {\n    return this.connectionService.handleConnection(client);\n  }\n\n  async handleDisconnect(client: Socket) {\n    return this.connectionService.handleDisconnect(client);\n  }\n\n  // ============ CORE MESSAGING METHODS (DELEGATE) ============\n  async emitToUser(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n    namespace?: WebSocketNamespace,\n  ): Promise<boolean> {\n    return this.emitterService.emitToUser(userId, event, data, namespace);\n  }\n\n  async emitToRoom(\n    roomId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    return this.emitterService.emitToRoom(roomId, event, data);\n  }\n\n  async broadcastToNamespace(\n    namespace: WebSocketNamespace,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    return this.emitterService.broadcastToNamespace(namespace, event, data);\n  }\n\n  // ============ CORE ROOM MANAGEMENT (DELEGATE) ============\n  @SubscribeMessage('join_room')\n  async handleJoinRoom(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: { roomId: string },\n  ) {\n    return this.connectionService.handleJoinRoom(client, data);\n  }\n\n  @SubscribeMessage('leave_room')\n  async handleLeaveRoom(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: { roomId: string },\n  ) {\n    return this.connectionService.handleLeaveRoom(client, data);\n  }\n\n  // ============ MESSAGING FEATURE HANDLERS (DELEGATE) ============\n  @SubscribeMessage('join_conversation')\n  async handleJoinConversation(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: { conversationId: string },\n  ) {\n    return this.messagingService.handleJoinConversation(client, data);\n  }\n\n  @SubscribeMessage('send_message')\n  async handleSendMessage(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.messagingService.handleSendMessage(client, data);\n  }\n\n  @SubscribeMessage('typing_indicator')\n  async handleTypingIndicator(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.messagingService.handleTypingIndicator(client, data);\n  }\n\n  @SubscribeMessage('mark_message_read')\n  async handleMarkMessageRead(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.messagingService.handleMarkMessageRead(client, data);\n  }\n\n  // ============ SOCIAL FEATURE HANDLERS (DELEGATE) ============\n  @SubscribeMessage('join_post')\n  async handleJoinPost(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: { postId: string },\n  ) {\n    return this.socialService.handleJoinPost(client, data);\n  }\n\n  @SubscribeMessage('like_post')\n  async handleLikePost(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.socialService.handleLikePost(client, data);\n  }\n\n  @SubscribeMessage('add_comment')\n  async handleAddComment(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.socialService.handleAddComment(client, data);\n  }\n\n  @SubscribeMessage('follow_user')\n  async handleFollowUser(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.socialService.handleFollowUser(client, data);\n  }\n\n  // ============ PRESENCE FEATURE HANDLERS (DELEGATE) ============\n  @SubscribeMessage('update_status')\n  async handleUpdateStatus(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.presenceService.handleUpdateStatus(client, data);\n  }\n\n  @SubscribeMessage('update_activity')\n  async handleUpdateActivity(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: any,\n  ) {\n    return this.presenceService.handleUpdateActivity(client, data);\n  }\n\n  @SubscribeMessage('get_online_users')\n  async handleGetOnlineUsers(@ConnectedSocket() client: Socket) {\n    return this.presenceService.handleGetOnlineUsers(client);\n  }\n\n  @SubscribeMessage('update_presence')\n  async handleUpdatePresence(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() data: { status: string; activity?: string },\n  ) {\n    return this.presenceService.handleUpdateStatus(client, {\n      status: data.status as 'online' | 'offline' | 'away' | 'busy',\n    });\n  }\n\n  // ============ HEALTH AND MONITORING (DELEGATE) ============\n  async getConnectionStats(): Promise<any> {\n    return this.utilityService.getConnectionStats();\n  }\n\n  async healthCheck(): Promise<{ healthy: boolean; details: any }> {\n    return this.utilityService.healthCheck();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\core\\websocket-utility.service.ts","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":22,"column":29,"nodeType":"AwaitExpression","messageId":"await","endLine":22,"endColumn":68,"suggestions":[{"messageId":"removeAwait","fix":{"range":[658,663],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":23,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":23,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":27,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":27,"endColumn":23},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":37,"column":30,"nodeType":"AwaitExpression","messageId":"await","endLine":37,"endColumn":72,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1085,1090],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":45,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":45,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":46,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":46,"endColumn":34},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validateToken' has no 'await' expression.","line":54,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":54,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1492,1550],"text":"validateToken(token: string): string | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'token' is defined but never used.","line":54,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":28}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Server } from 'socket.io';\n\nimport { ConnectionManagerService } from './connection-manager.service';\nimport { RoomManagerService } from './room-manager.service';\n\n@Injectable()\nexport class WebSocketUtilityService {\n  private readonly logger = new Logger(WebSocketUtilityService.name);\n  private server: Server;\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n  ) {}\n\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  async getConnectionStats(): Promise<any> {\n    const connectionStats = await this.connectionManager.getStats();\n    const roomStats = this.roomManager.getRoomStats();\n\n    return {\n      connections: connectionStats,\n      rooms: roomStats,\n      server: {\n        connectedClients: this.server.engine.clientsCount,\n        uptime: process.uptime(),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  async healthCheck(): Promise<{ healthy: boolean; details: any }> {\n    const connectionHealth = await this.connectionManager.healthCheck();\n    const roomHealth = this.roomManager.healthCheck();\n\n    const healthy = connectionHealth.healthy && roomHealth.healthy;\n\n    return {\n      healthy,\n      details: {\n        connections: connectionHealth.details,\n        rooms: roomHealth.details,\n        server: {\n          connected: this.server.engine.clientsCount >= 0,\n        },\n      },\n    };\n  }\n\n  async validateToken(token: string): Promise<string | null> {\n    try {\n      // This should use your JWT service to validate the token\n      // For now, returning a mock implementation\n      // You should inject and use your JWT service here\n\n      // Example:\n      // const payload = await this.jwtService.verifyAsync(token);\n      // return payload.sub || payload.userId;\n\n      // Mock implementation - replace with actual JWT validation\n      return 'mock-user-id';\n    } catch (error) {\n      this.logger.error('Token validation error:', error);\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\interfaces\\websocket.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\services\\messaging-websocket.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserConnection' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":17},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":61,"column":9,"nodeType":"AwaitExpression","messageId":"await","endLine":61,"endColumn":69,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1437,1442],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":98,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":100,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2379,2384],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":143,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":145,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3533,3538],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":191,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":193,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[4931,4936],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":220,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":222,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[5767,5772],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleTyping' has no 'await' expression.","line":270,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":270,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7237,7293],"text":"handleTyping(data: TypingEventData): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleMessageRead' has no 'await' expression.","line":295,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":295,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7972,8038],"text":"handleMessageRead(data: MessageReadEventData): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'joinConversation' has no 'await' expression.","line":310,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":310,"endColumn":25,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8437,8552],"text":"joinConversation(\n    userId: string,\n    socketId: string,\n    conversationId: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'leaveConversation' has no 'await' expression.","line":331,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":331,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8941,9057],"text":"leaveConversation(\n    userId: string,\n    socketId: string,\n    conversationId: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyConversationUpdate' has no 'await' expression.","line":348,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":348,"endColumn":33,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9436,9535],"text":"notifyConversationUpdate(\n    conversationId: string,\n    updateData: any,\n  ): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Socket, Server } from 'socket.io';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n  UserConnection,\n} from '../interfaces/websocket.interface';\nimport { RoomManagerService } from '../core/room-manager.service';\nimport { ConnectionManagerService } from '../core/connection-manager.service';\n\nexport interface MessageEventData {\n  conversationId: string;\n  senderId: string;\n  receiverId?: string;\n  content: string;\n  messageId: string;\n  timestamp: Date;\n  messageType: 'text' | 'image' | 'file';\n}\n\nexport interface TypingEventData {\n  conversationId: string;\n  userId: string;\n  isTyping: boolean;\n}\n\nexport interface MessageReadEventData {\n  conversationId: string;\n  messageId: string;\n  userId: string;\n  readAt: Date;\n}\n\n@Injectable()\nexport class MessagingWebSocketService {\n  private readonly logger = new Logger(MessagingWebSocketService.name);\n  private server: Server;\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n  ) {}\n\n  // Set server instance from gateway\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  // ============ HELPER METHODS ============\n\n  /**\n   * Emit to specific user\n   */\n  private async emitToUser(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    try {\n      const connections =\n        await this.connectionManager.getUserConnectionsAsync(userId);\n\n      if (connections.length === 0) {\n        this.logger.debug(`No connections found for user ${userId}`);\n        return false;\n      }\n\n      let emitted = false;\n      for (const connection of connections) {\n        try {\n          this.server.to(connection.socketId).emit(event, data);\n          emitted = true;\n        } catch (error) {\n          this.logger.error(\n            `Failed to emit to socket ${connection.socketId}:`,\n            error,\n          );\n        }\n      }\n\n      return emitted;\n    } catch (error) {\n      this.logger.error(`Error emitting to user ${userId}:`, error);\n      return false;\n    }\n  }\n\n  // ============ WEBSOCKET EVENT HANDLERS ============\n\n  /**\n   * Handle join conversation event from client\n   */\n  async handleJoinConversation(\n    client: Socket,\n    data: { conversationId: string },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) {\n        client.emit('error', { message: 'Connection not found' });\n        return;\n      }\n\n      const conversationRoom = this.roomManager.createConversationRoom(\n        data.conversationId,\n        WebSocketNamespace.MESSAGING,\n      );\n\n      const joined = this.roomManager.joinRoom(\n        conversationRoom.id,\n        connection.userId,\n        client.id,\n      );\n\n      if (joined) {\n        await client.join(conversationRoom.id);\n        client.emit('conversation_joined', {\n          conversationId: data.conversationId,\n          roomId: conversationRoom.id,\n        });\n      }\n    } catch (error) {\n      this.logger.error('Error joining conversation:', error);\n      client.emit('error', { message: 'Failed to join conversation' });\n    }\n  }\n\n  /**\n   * Handle send message event from client\n   */\n  async handleSendMessage(\n    client: Socket,\n    data: {\n      conversationId: string;\n      content: string;\n      messageType: 'text' | 'image' | 'file';\n      receiverId?: string;\n    },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) {\n        client.emit('error', { message: 'Connection not found' });\n        return;\n      }\n\n      const messageData = {\n        conversationId: data.conversationId,\n        senderId: connection.userId,\n        receiverId: data.receiverId,\n        content: data.content,\n        messageId: `msg_${Date.now()}_${Math.random()}`,\n        timestamp: new Date(),\n        messageType: data.messageType,\n      };\n\n      // Emit to conversation room\n      const conversationRoom = `conversation:${data.conversationId}`;\n      this.server\n        .to(conversationRoom)\n        .emit(WebSocketEvent.MESSAGE_SENT, messageData);\n\n      // If private message, also notify receiver directly\n      if (data.receiverId) {\n        await this.emitToUser(\n          data.receiverId,\n          WebSocketEvent.MESSAGE_RECEIVED,\n          messageData,\n        );\n      }\n\n      client.emit('message_sent_ack', { messageId: messageData.messageId });\n    } catch (error) {\n      this.logger.error('Error sending message:', error);\n      client.emit('error', { message: 'Failed to send message' });\n    }\n  }\n\n  /**\n   * Handle typing indicator event from client\n   */\n  async handleTypingIndicator(\n    client: Socket,\n    data: { conversationId: string; isTyping: boolean },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const event = data.isTyping\n        ? WebSocketEvent.TYPING_START\n        : WebSocketEvent.TYPING_STOP;\n      const conversationRoom = `conversation:${data.conversationId}`;\n\n      // Emit to others in the conversation (exclude sender)\n      client.to(conversationRoom).emit(event, {\n        conversationId: data.conversationId,\n        userId: connection.userId,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      this.logger.error('Error handling typing indicator:', error);\n    }\n  }\n\n  /**\n   * Handle mark message as read event from client\n   */\n  async handleMarkMessageRead(\n    client: Socket,\n    data: { conversationId: string; messageId: string },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const conversationRoom = `conversation:${data.conversationId}`;\n      this.server.to(conversationRoom).emit(WebSocketEvent.MESSAGE_READ, {\n        conversationId: data.conversationId,\n        messageId: data.messageId,\n        userId: connection.userId,\n        readAt: new Date(),\n      });\n    } catch (error) {\n      this.logger.error('Error marking message as read:', error);\n    }\n  }\n\n  // ============ BUSINESS LOGIC METHODS ============\n\n  /**\n   * Handle new message sent (called from business logic)\n   */\n  async handleMessageSent(data: MessageEventData): Promise<void> {\n    try {\n      const conversationRoom = this.getConversationRoomId(data.conversationId);\n\n      // Emit to conversation room\n      this.server.to(conversationRoom).emit(WebSocketEvent.MESSAGE_SENT, {\n        ...data,\n        namespace: WebSocketNamespace.MESSAGING,\n      });\n\n      // If it's a private conversation, also notify the receiver directly\n      if (data.receiverId) {\n        await this.emitToUser(\n          data.receiverId,\n          WebSocketEvent.MESSAGE_RECEIVED,\n          data,\n        );\n      }\n\n      this.logger.debug(`Message sent to conversation ${data.conversationId}`);\n    } catch (error) {\n      this.logger.error('Error handling message sent:', error);\n    }\n  }\n\n  /**\n   * Handle typing indicators (called from business logic)\n   */\n  async handleTyping(data: TypingEventData): Promise<void> {\n    try {\n      const conversationRoom = this.getConversationRoomId(data.conversationId);\n\n      const event = data.isTyping\n        ? WebSocketEvent.TYPING_START\n        : WebSocketEvent.TYPING_STOP;\n\n      this.server.to(conversationRoom).emit(event, {\n        conversationId: data.conversationId,\n        userId: data.userId,\n        timestamp: new Date(),\n      });\n\n      this.logger.debug(\n        `Typing ${data.isTyping ? 'started' : 'stopped'} by ${data.userId} in ${data.conversationId}`,\n      );\n    } catch (error) {\n      this.logger.error('Error handling typing:', error);\n    }\n  }\n\n  /**\n   * Handle message read receipts (called from business logic)\n   */\n  async handleMessageRead(data: MessageReadEventData): Promise<void> {\n    try {\n      const conversationRoom = this.getConversationRoomId(data.conversationId);\n\n      this.server.to(conversationRoom).emit(WebSocketEvent.MESSAGE_READ, data);\n\n      this.logger.debug(`Message ${data.messageId} read by ${data.userId}`);\n    } catch (error) {\n      this.logger.error('Error handling message read:', error);\n    }\n  }\n\n  /**\n   * Join user to conversation room\n   */\n  async joinConversation(\n    userId: string,\n    socketId: string,\n    conversationId: string,\n  ): Promise<boolean> {\n    try {\n      const room = this.roomManager.createConversationRoom(\n        conversationId,\n        WebSocketNamespace.MESSAGING,\n      );\n\n      return this.roomManager.joinRoom(room.id, userId, socketId);\n    } catch (error) {\n      this.logger.error(`Error joining conversation ${conversationId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Leave conversation room\n   */\n  async leaveConversation(\n    userId: string,\n    socketId: string,\n    conversationId: string,\n  ): Promise<boolean> {\n    try {\n      const roomId = this.getConversationRoomId(conversationId);\n      return this.roomManager.leaveRoom(roomId, userId, socketId);\n    } catch (error) {\n      this.logger.error(`Error leaving conversation ${conversationId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Notify about conversation updates (metadata changes, participants added/removed)\n   */\n  async notifyConversationUpdate(\n    conversationId: string,\n    updateData: any,\n  ): Promise<void> {\n    try {\n      const conversationRoom = this.getConversationRoomId(conversationId);\n\n      this.server\n        .to(conversationRoom)\n        .emit(WebSocketEvent.CONVERSATION_UPDATED, {\n          conversationId,\n          ...updateData,\n          timestamp: new Date(),\n        });\n\n      this.logger.debug(`Conversation ${conversationId} updated`);\n    } catch (error) {\n      this.logger.error('Error notifying conversation update:', error);\n    }\n  }\n\n  /**\n   * Notify about new conversation creation\n   */\n  async notifyConversationCreated(\n    participants: string[],\n    conversationData: any,\n  ): Promise<void> {\n    try {\n      // Notify all participants\n      for (const userId of participants) {\n        await this.emitToUser(\n          userId,\n          WebSocketEvent.CONVERSATION_CREATED,\n          conversationData,\n        );\n      }\n\n      this.logger.debug(\n        `New conversation created with ${participants.length} participants`,\n      );\n    } catch (error) {\n      this.logger.error('Error notifying conversation creation:', error);\n    }\n  }\n\n  /**\n   * Get conversation room ID\n   */\n  private getConversationRoomId(conversationId: string): string {\n    return `conversation:${conversationId}`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\services\\presence-websocket.service.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'broadcastToNamespace' has no 'await' expression.","line":49,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":49,"endColumn":37,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1402,1525],"text":"broadcastToNamespace(\n    namespace: WebSocketNamespace,\n    event: WebSocketEvent,\n    data: any,\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":71,"column":9,"nodeType":"AwaitExpression","messageId":"await","endLine":71,"endColumn":69,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1886,1891],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":108,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":110,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2844,2849],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":144,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":146,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3764,3769],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":149,"column":7,"nodeType":"AwaitExpression","messageId":"await","endLine":149,"endColumn":73,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3882,3887],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleGetOnlineUsers' has no 'await' expression.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":172,"endColumn":29,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4459,4465],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":298,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":298,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .device on an `any` value.","line":298,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":298,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":299,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":299,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .location on an `any` value.","line":299,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":299,"endColumn":37},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyContacts' has no 'await' expression.","line":385,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":385,"endColumn":31,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9865,9981],"text":"notifyContacts(\n    userId: string,\n    event: WebSocketEvent,\n    data: PresenceEventData,\n  ): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'checkOtherConnections' has no 'await' expression.","line":403,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":403,"endColumn":38,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10407,10506],"text":"checkOtherConnections(\n    userId: string,\n    excludeSocketId: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":404,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":404,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'excludeSocketId' is defined but never used.","line":405,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":405,"endColumn":20}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Socket, Server } from 'socket.io';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n} from '../interfaces/websocket.interface';\nimport { RoomManagerService } from '../core/room-manager.service';\nimport { ConnectionManagerService } from '../core/connection-manager.service';\n\nexport interface PresenceEventData {\n  userId: string;\n  status: 'online' | 'offline' | 'away' | 'busy';\n  lastSeen?: Date;\n  device?: string;\n  location?: string;\n}\n\nexport interface ActivityEventData {\n  userId: string;\n  activity: 'viewing_post' | 'browsing_feed' | 'in_conversation' | 'idle';\n  targetId?: string; // postId, conversationId, etc.\n  timestamp: Date;\n}\n\n@Injectable()\nexport class PresenceWebSocketService {\n  private readonly logger = new Logger(PresenceWebSocketService.name);\n  private server: Server;\n\n  // Store user presence data in memory (in production, use Redis)\n  private userPresence = new Map<string, PresenceEventData>();\n  private userActivities = new Map<string, ActivityEventData>();\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n  ) {}\n\n  // Set server instance from gateway\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  // ============ HELPER METHODS ============\n\n  /**\n   * Broadcast to namespace\n   */\n  private async broadcastToNamespace(\n    namespace: WebSocketNamespace,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<void> {\n    try {\n      this.server.emit(event, data);\n    } catch (error) {\n      this.logger.error(`Error broadcasting to namespace ${namespace}:`, error);\n    }\n  }\n\n  /**\n   * Emit to specific user\n   */\n  private async emitToUser(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    try {\n      const connections =\n        await this.connectionManager.getUserConnectionsAsync(userId);\n\n      if (connections.length === 0) {\n        this.logger.debug(`No connections found for user ${userId}`);\n        return false;\n      }\n\n      let emitted = false;\n      for (const connection of connections) {\n        try {\n          this.server.to(connection.socketId).emit(event, data);\n          emitted = true;\n        } catch (error) {\n          this.logger.error(\n            `Failed to emit to socket ${connection.socketId}:`,\n            error,\n          );\n        }\n      }\n\n      return emitted;\n    } catch (error) {\n      this.logger.error(`Error emitting to user ${userId}:`, error);\n      return false;\n    }\n  }\n\n  // ============ WEBSOCKET EVENT HANDLERS ============\n\n  /**\n   * Handle update status event from client\n   */\n  async handleUpdateStatus(\n    client: Socket,\n    data: { status: 'online' | 'offline' | 'away' | 'busy' },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const presenceData = {\n        userId: connection.userId,\n        status: data.status,\n        timestamp: new Date(),\n      };\n\n      // Broadcast to presence namespace\n      await this.broadcastToNamespace(\n        WebSocketNamespace.PRESENCE,\n        WebSocketEvent.USER_STATUS_CHANGE,\n        presenceData,\n      );\n\n      client.emit('status_updated', presenceData);\n    } catch (error) {\n      this.logger.error('Error updating status:', error);\n      client.emit('error', { message: 'Failed to update status' });\n    }\n  }\n\n  /**\n   * Handle update activity event from client\n   */\n  async handleUpdateActivity(\n    client: Socket,\n    data: {\n      activity: 'viewing_post' | 'browsing_feed' | 'in_conversation' | 'idle';\n      targetId?: string;\n    },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      await this.connectionManager.updateUserActivity(connection.userId);\n\n      const activityData = {\n        userId: connection.userId,\n        activity: data.activity,\n        targetId: data.targetId,\n        timestamp: new Date(),\n      };\n\n      // Broadcast activity update\n      await this.broadcastToNamespace(\n        WebSocketNamespace.PRESENCE,\n        WebSocketEvent.PRESENCE_UPDATED,\n        activityData,\n      );\n    } catch (error) {\n      this.logger.error('Error updating activity:', error);\n    }\n  }\n\n  /**\n   * Handle get online users event from client\n   */\n  async handleGetOnlineUsers(client: Socket) {\n    try {\n      const onlineUsers = this.getOnlineUsers();\n      client.emit('online_users', {\n        users: onlineUsers,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      this.logger.error('Error getting online users:', error);\n      client.emit('error', { message: 'Failed to get online users' });\n    }\n  }\n\n  // ============ BUSINESS LOGIC METHODS ============\n\n  /**\n   * Update user presence status\n   */\n  async updatePresence(data: PresenceEventData): Promise<void> {\n    try {\n      const previousPresence = this.userPresence.get(data.userId);\n      this.userPresence.set(data.userId, data);\n\n      // Only broadcast if status actually changed\n      if (!previousPresence || previousPresence.status !== data.status) {\n        let event: WebSocketEvent;\n\n        switch (data.status) {\n          case 'online':\n            event = WebSocketEvent.USER_ONLINE;\n            break;\n          case 'offline':\n            event = WebSocketEvent.USER_OFFLINE;\n            break;\n          default:\n            event = WebSocketEvent.USER_STATUS_CHANGE;\n        }\n\n        // Broadcast to presence namespace\n        await this.broadcastToNamespace(\n          WebSocketNamespace.PRESENCE,\n          event,\n          data,\n        );\n\n        // Also notify friends/contacts specifically\n        await this.notifyContacts(data.userId, event, data);\n      }\n\n      this.logger.debug(\n        `Presence updated for user ${data.userId}: ${data.status}`,\n      );\n    } catch (error) {\n      this.logger.error('Error updating presence:', error);\n    }\n  }\n\n  /**\n   * Update user activity\n   */\n  async updateActivity(data: ActivityEventData): Promise<void> {\n    try {\n      this.userActivities.set(data.userId, data);\n\n      // Broadcast activity updates to interested parties\n      await this.broadcastToNamespace(\n        WebSocketNamespace.PRESENCE,\n        WebSocketEvent.PRESENCE_UPDATED,\n        {\n          userId: data.userId,\n          activity: data.activity,\n          targetId: data.targetId,\n          timestamp: data.timestamp,\n        },\n      );\n\n      this.logger.debug(\n        `Activity updated for user ${data.userId}: ${data.activity}`,\n      );\n    } catch (error) {\n      this.logger.error('Error updating activity:', error);\n    }\n  }\n\n  /**\n   * Get user presence\n   */\n  getUserPresence(userId: string): PresenceEventData | null {\n    return this.userPresence.get(userId) || null;\n  }\n\n  /**\n   * Get user activity\n   */\n  getUserActivity(userId: string): ActivityEventData | null {\n    return this.userActivities.get(userId) || null;\n  }\n\n  /**\n   * Get online users\n   */\n  getOnlineUsers(): string[] {\n    const onlineUsers: string[] = [];\n\n    this.userPresence.forEach((presence, userId) => {\n      if (presence.status === 'online') {\n        onlineUsers.push(userId);\n      }\n    });\n\n    return onlineUsers;\n  }\n\n  /**\n   * Handle user connection\n   */\n  async handleUserConnected(\n    userId: string,\n    socketId: string,\n    metadata?: any,\n  ): Promise<void> {\n    try {\n      // Update presence to online\n      await this.updatePresence({\n        userId,\n        status: 'online',\n        device: metadata?.device,\n        location: metadata?.location,\n      });\n\n      // Join presence room\n      const presenceRoom = this.roomManager.createUserRoom(\n        userId,\n        WebSocketNamespace.PRESENCE,\n      );\n      this.roomManager.joinRoom(presenceRoom.id, userId, socketId);\n\n      this.logger.debug(`User ${userId} connected to presence service`);\n    } catch (error) {\n      this.logger.error('Error handling user connected:', error);\n    }\n  }\n\n  /**\n   * Handle user disconnection\n   */\n  async handleUserDisconnected(\n    userId: string,\n    socketId: string,\n  ): Promise<void> {\n    try {\n      // Check if user has other active connections\n      // If not, mark as offline\n      const hasOtherConnections = await this.checkOtherConnections(\n        userId,\n        socketId,\n      );\n\n      if (!hasOtherConnections) {\n        await this.updatePresence({\n          userId,\n          status: 'offline',\n          lastSeen: new Date(),\n        });\n\n        // Clean up activity data\n        this.userActivities.delete(userId);\n      }\n\n      this.logger.debug(`User ${userId} disconnected from presence service`);\n    } catch (error) {\n      this.logger.error('Error handling user disconnected:', error);\n    }\n  }\n\n  /**\n   * Set user as away (after inactivity)\n   */\n  async setUserAway(userId: string): Promise<void> {\n    try {\n      const currentPresence = this.userPresence.get(userId);\n\n      if (currentPresence && currentPresence.status === 'online') {\n        await this.updatePresence({\n          ...currentPresence,\n          status: 'away',\n        });\n      }\n    } catch (error) {\n      this.logger.error('Error setting user away:', error);\n    }\n  }\n\n  /**\n   * Cleanup old presence data\n   */\n  cleanup(): void {\n    const now = new Date();\n    const threshold = 15 * 60 * 1000; // 15 minutes\n\n    this.userPresence.forEach((presence, userId) => {\n      if (presence.status === 'offline' && presence.lastSeen) {\n        if (now.getTime() - presence.lastSeen.getTime() > threshold) {\n          this.userPresence.delete(userId);\n          this.userActivities.delete(userId);\n        }\n      }\n    });\n  }\n\n  /**\n   * Notify user's contacts about presence changes\n   */\n  private async notifyContacts(\n    userId: string,\n    event: WebSocketEvent,\n    data: PresenceEventData,\n  ): Promise<void> {\n    try {\n      // In a real app, you'd fetch the user's contacts/friends from database\n      // For demo purposes, we'll just broadcast to a contacts room\n      const contactsRoom = `contacts:${userId}`;\n      this.server.to(contactsRoom).emit(event, data);\n    } catch (error) {\n      this.logger.error('Error notifying contacts:', error);\n    }\n  }\n\n  /**\n   * Check if user has other active connections\n   */\n  private async checkOtherConnections(\n    userId: string,\n    excludeSocketId: string,\n  ): Promise<boolean> {\n    try {\n      // This should check with ConnectionManagerService\n      // For now, return false to simulate single connection\n      return false;\n    } catch (error) {\n      this.logger.error('Error checking other connections:', error);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\services\\social-websocket.service.ts","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":74,"column":9,"nodeType":"AwaitExpression","messageId":"await","endLine":74,"endColumn":69,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1745,1750],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":108,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":110,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2650,2655],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":147,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":149,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3607,3612],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":186,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":188,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[4593,4598],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":218,"column":26,"nodeType":"AwaitExpression","messageId":"await","endLine":220,"endColumn":8,"suggestions":[{"messageId":"removeAwait","fix":{"range":[5509,5514],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'handleCommentEvent' has no 'await' expression.","line":298,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":298,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7718,7781],"text":"handleCommentEvent(data: CommentEventData): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'joinPostRoom' has no 'await' expression.","line":373,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":373,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9912,10015],"text":"joinPostRoom(\n    userId: string,\n    socketId: string,\n    postId: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'leavePostRoom' has no 'await' expression.","line":393,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":393,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10365,10469],"text":"leavePostRoom(\n    userId: string,\n    socketId: string,\n    postId: string,\n  ): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'joinFeedRoom' has no 'await' expression.","line":410,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":410,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[10796,10866],"text":"joinFeedRoom(userId: string, socketId: string): boolean"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyFollowers' has no 'await' expression.","line":426,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":426,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[11256,11359],"text":"notifyFollowers(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Socket, Server } from 'socket.io';\nimport {\n  WebSocketEvent,\n  WebSocketNamespace,\n} from '../interfaces/websocket.interface';\nimport { RoomManagerService } from '../core/room-manager.service';\nimport { ConnectionManagerService } from '../core/connection-manager.service';\n\nexport interface SocialEventData {\n  userId: string;\n  targetId: string; // postId, commentId, userId (for follows)\n  type: 'post' | 'comment' | 'like' | 'follow';\n  action:\n    | 'created'\n    | 'updated'\n    | 'deleted'\n    | 'liked'\n    | 'unliked'\n    | 'followed'\n    | 'unfollowed';\n  data?: any;\n  timestamp: Date;\n}\n\nexport interface PostEventData extends SocialEventData {\n  postId: string;\n  authorId: string;\n  content?: string;\n  mediaUrls?: string[];\n}\n\nexport interface CommentEventData extends SocialEventData {\n  postId: string;\n  commentId: string;\n  authorId: string;\n  content?: string;\n  parentCommentId?: string;\n}\n\nexport interface FollowEventData extends SocialEventData {\n  followerId: string;\n  followingId: string;\n  isAccepted?: boolean;\n}\n\n@Injectable()\nexport class SocialWebSocketService {\n  private readonly logger = new Logger(SocialWebSocketService.name);\n  private server: Server;\n\n  constructor(\n    private readonly connectionManager: ConnectionManagerService,\n    private readonly roomManager: RoomManagerService,\n  ) {}\n\n  // Set server instance from gateway\n  setServer(server: Server): void {\n    this.server = server;\n  }\n\n  // ============ HELPER METHODS ============\n\n  /**\n   * Emit to specific user\n   */\n  private async emitToUser(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<boolean> {\n    try {\n      const connections =\n        await this.connectionManager.getUserConnectionsAsync(userId);\n\n      if (connections.length === 0) {\n        this.logger.debug(`No connections found for user ${userId}`);\n        return false;\n      }\n\n      let emitted = false;\n      for (const connection of connections) {\n        try {\n          this.server.to(connection.socketId).emit(event, data);\n          emitted = true;\n        } catch (error) {\n          this.logger.error(\n            `Failed to emit to socket ${connection.socketId}:`,\n            error,\n          );\n        }\n      }\n\n      return emitted;\n    } catch (error) {\n      this.logger.error(`Error emitting to user ${userId}:`, error);\n      return false;\n    }\n  }\n\n  // ============ WEBSOCKET EVENT HANDLERS ============\n\n  /**\n   * Handle join post event from client\n   */\n  async handleJoinPost(client: Socket, data: { postId: string }) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) {\n        client.emit('error', { message: 'Connection not found' });\n        return;\n      }\n\n      const postRoom = this.roomManager.createPostRoom(\n        data.postId,\n        WebSocketNamespace.SOCIAL,\n      );\n      const joined = this.roomManager.joinRoom(\n        postRoom.id,\n        connection.userId,\n        client.id,\n      );\n\n      if (joined) {\n        await client.join(postRoom.id);\n        client.emit('post_joined', {\n          postId: data.postId,\n          roomId: postRoom.id,\n        });\n      }\n    } catch (error) {\n      this.logger.error('Error joining post:', error);\n      client.emit('error', { message: 'Failed to join post' });\n    }\n  }\n\n  /**\n   * Handle like post event from client\n   */\n  async handleLikePost(\n    client: Socket,\n    data: { postId: string; liked: boolean },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const event = data.liked\n        ? WebSocketEvent.POST_LIKED\n        : WebSocketEvent.POST_UNLIKED;\n      const postRoom = `post:${data.postId}`;\n\n      const eventData = {\n        postId: data.postId,\n        userId: connection.userId,\n        action: data.liked ? 'liked' : 'unliked',\n        timestamp: new Date(),\n      };\n\n      // Notify users in post room\n      this.server.to(postRoom).emit(event, eventData);\n\n      client.emit('like_post_ack', eventData);\n    } catch (error) {\n      this.logger.error('Error handling post like:', error);\n      client.emit('error', { message: 'Failed to like/unlike post' });\n    }\n  }\n\n  /**\n   * Handle add comment event from client\n   */\n  async handleAddComment(\n    client: Socket,\n    data: {\n      postId: string;\n      content: string;\n      parentCommentId?: string;\n    },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const commentData = {\n        postId: data.postId,\n        commentId: `comment_${Date.now()}_${Math.random()}`,\n        authorId: connection.userId,\n        content: data.content,\n        parentCommentId: data.parentCommentId,\n        timestamp: new Date(),\n      };\n\n      const postRoom = `post:${data.postId}`;\n      this.server.to(postRoom).emit(WebSocketEvent.COMMENT_ADDED, commentData);\n\n      client.emit('comment_added_ack', commentData);\n    } catch (error) {\n      this.logger.error('Error adding comment:', error);\n      client.emit('error', { message: 'Failed to add comment' });\n    }\n  }\n\n  /**\n   * Handle follow user event from client\n   */\n  async handleFollowUser(\n    client: Socket,\n    data: { targetUserId: string; follow: boolean },\n  ) {\n    try {\n      const connection = await this.connectionManager.getConnectionBySocket(\n        client.id,\n      );\n      if (!connection) return;\n\n      const event = data.follow\n        ? WebSocketEvent.FOLLOW_REQUEST\n        : 'unfollow_request';\n\n      const followData = {\n        followerId: connection.userId,\n        followingId: data.targetUserId,\n        action: data.follow ? 'followed' : 'unfollowed',\n        timestamp: new Date(),\n      };\n\n      // Notify target user\n      await this.emitToUser(\n        data.targetUserId,\n        event as WebSocketEvent,\n        followData,\n      );\n\n      client.emit('follow_user_ack', followData);\n    } catch (error) {\n      this.logger.error('Error handling follow user:', error);\n      client.emit('error', { message: 'Failed to follow/unfollow user' });\n    }\n  }\n\n  // ============ BUSINESS LOGIC METHODS ============\n\n  /**\n   * Handle post creation/update/deletion\n   */\n  async handlePostEvent(data: PostEventData): Promise<void> {\n    try {\n      let event: WebSocketEvent;\n\n      switch (data.action) {\n        case 'created':\n          event = WebSocketEvent.POST_CREATED;\n          break;\n        case 'updated':\n          event = WebSocketEvent.POST_UPDATED;\n          break;\n        case 'deleted':\n          event = WebSocketEvent.POST_DELETED;\n          break;\n        case 'liked':\n          event = WebSocketEvent.POST_LIKED;\n          break;\n        case 'unliked':\n          event = WebSocketEvent.POST_UNLIKED;\n          break;\n        default:\n          this.logger.warn(`Unknown post action: ${data.action}`);\n          return;\n      }\n\n      // Notify followers and interested users\n      await this.notifyFollowers(data.authorId, event, data);\n\n      // Also notify users in the post's room (for comments/likes on posts they're engaged with)\n      if (data.action === 'liked' || data.action === 'unliked') {\n        const postRoom = this.getPostRoomId(data.postId);\n        this.server.to(postRoom).emit(event, data);\n      }\n\n      this.logger.debug(\n        `Post ${data.action} event handled for post ${data.postId}`,\n      );\n    } catch (error) {\n      this.logger.error('Error handling post event:', error);\n    }\n  }\n\n  /**\n   * Handle comment events\n   */\n  async handleCommentEvent(data: CommentEventData): Promise<void> {\n    try {\n      let event: WebSocketEvent;\n\n      switch (data.action) {\n        case 'created':\n          event = WebSocketEvent.COMMENT_ADDED;\n          break;\n        case 'liked':\n          event = WebSocketEvent.COMMENT_LIKED;\n          break;\n        case 'unliked':\n          event = WebSocketEvent.COMMENT_UNLIKED;\n          break;\n        default:\n          this.logger.warn(`Unknown comment action: ${data.action}`);\n          return;\n      }\n\n      // Notify post room (users interested in this post)\n      const postRoom = this.getPostRoomId(data.postId);\n      this.server.to(postRoom).emit(event, data);\n\n      this.logger.debug(\n        `Comment ${data.action} event handled for post ${data.postId}`,\n      );\n    } catch (error) {\n      this.logger.error('Error handling comment event:', error);\n    }\n  }\n\n  /**\n   * Handle follow events\n   */\n  async handleFollowEvent(data: FollowEventData): Promise<void> {\n    try {\n      let event: WebSocketEvent;\n\n      switch (data.action) {\n        case 'followed':\n          event = WebSocketEvent.FOLLOW_REQUEST;\n          break;\n        case 'unfollowed':\n          // Could add FOLLOW_REMOVED event if needed\n          return;\n        default:\n          if (data.isAccepted === true) {\n            event = WebSocketEvent.FOLLOW_ACCEPTED;\n          } else if (data.isAccepted === false) {\n            event = WebSocketEvent.FOLLOW_DECLINED;\n          } else {\n            this.logger.warn(`Unknown follow action: ${data.action}`);\n            return;\n          }\n      }\n\n      // Notify the target user\n      await this.emitToUser(data.followingId, event, data);\n\n      // If accepted, also notify the follower\n      if (event === WebSocketEvent.FOLLOW_ACCEPTED) {\n        await this.emitToUser(data.followerId, event, data);\n      }\n\n      this.logger.debug(\n        `Follow ${data.action} event handled between ${data.followerId} and ${data.followingId}`,\n      );\n    } catch (error) {\n      this.logger.error('Error handling follow event:', error);\n    }\n  }\n\n  /**\n   * Join user to post room (for real-time updates on post they're viewing/commenting)\n   */\n  async joinPostRoom(\n    userId: string,\n    socketId: string,\n    postId: string,\n  ): Promise<boolean> {\n    try {\n      const room = this.roomManager.createPostRoom(\n        postId,\n        WebSocketNamespace.SOCIAL,\n      );\n      return this.roomManager.joinRoom(room.id, userId, socketId);\n    } catch (error) {\n      this.logger.error(`Error joining post room ${postId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Leave post room\n   */\n  async leavePostRoom(\n    userId: string,\n    socketId: string,\n    postId: string,\n  ): Promise<boolean> {\n    try {\n      const roomId = this.getPostRoomId(postId);\n      return this.roomManager.leaveRoom(roomId, userId, socketId);\n    } catch (error) {\n      this.logger.error(`Error leaving post room ${postId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Join user to their feed room for real-time feed updates\n   */\n  async joinFeedRoom(userId: string, socketId: string): Promise<boolean> {\n    try {\n      const room = this.roomManager.createFeedRoom(\n        userId,\n        WebSocketNamespace.SOCIAL,\n      );\n      return this.roomManager.joinRoom(room.id, userId, socketId);\n    } catch (error) {\n      this.logger.error(`Error joining feed room for user ${userId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Notify followers about user's activity\n   */\n  private async notifyFollowers(\n    userId: string,\n    event: WebSocketEvent,\n    data: any,\n  ): Promise<void> {\n    try {\n      // In a real app, you'd fetch the user's followers from database\n      // For now, we'll use a feed-based approach\n      const feedRoom = this.getFeedRoomId(userId);\n      this.server.to(feedRoom).emit(event, data);\n    } catch (error) {\n      this.logger.error('Error notifying followers:', error);\n    }\n  }\n\n  /**\n   * Get post room ID\n   */\n  private getPostRoomId(postId: string): string {\n    return `post:${postId}`;\n  }\n\n  /**\n   * Get feed room ID\n   */\n  private getFeedRoomId(userId: string): string {\n    return `feed:${userId}`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\src\\shared\\websocket\\websocket.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Personal\\PersonalProjects\\SocialMediaMini\\SocialMediaMini_Backend\\test\\app.e2e-spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]